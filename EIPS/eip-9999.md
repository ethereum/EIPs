---
eip: <TBD>
title: Payload Chunking with Chunk Access Lists
description: Semantic block chunking with separated state diffs for streaming validation and reduced latency
author: Toni Wahrstätter (@nerolation), Jihoon Song (@jihoonsong), Milos Stankovic (@morph-dev), Bharath Vedartham (@bharath-123), Raúl Kripalani (@raulk)
discussions-to: https://ethereum-magicians.org/t/<TBD>
status: Draft
type: Standards Track
category: Core
created: 2025-01-27
requires: 4844, 7928
---

## Abstract

This EIP introduces Payload Chunking, a protocol upgrade that restructures Ethereum blocks into self-contained execution chunks forming a hash chain with separated Chunk Access Lists (CALs). CALs propagate separately and contain state diffs that enable streaming chunk execution. Chunks can execute before beacon block arrival using slot and proposer identification. Each chunk applies CALs 0..N-1 to parent state, generates CAL N, creating a streaming cascade. After all chunks execute, the CL validates the hash chain and finalizes the block. This architecture transforms block processing from a monolithic operation into a streaming pipeline while preserving block atomicity.

## Motivation

As Ethereum's gas limits increase, block sizes and execution complexity grow correspondingly. The current monolithic block structure requires validators to download the entire block before beginning execution, creating a critical bottleneck in the consensus timeline. This latency becomes increasingly problematic as larger blocks take longer to propagate and decompress before execution can begin.

This proposal addresses these issues by:

- Enabling streaming validation where execution begins as chunks arrive
- Bounding resource requirements to per-chunk maximums (`2**24` gas)
- Allowing early rejection of invalid blocks without processing all chunks
- Supporting independent chunk execution using CALs containing state diffs
- Creating natural boundaries for future proving systems

## Specification

### Constants

```python
CHUNK_GAS_LIMIT = 2**24  # From EIP-7825 (16,777,216 gas per chunk)
MAX_CHUNKS_PER_BLOCK = 16  # Maximum chunks in a block
MIN_CHUNK_FILL_RATIO = 0.5  # Non-terminal chunks must be ≥50% full (with an exception; see below)
CHUNK_INCLUSION_PROOF_DEPTH = 5  # Merkle proof depth for chunk inclusion
```

### Data Structures

#### Execution Layer Structures

```python
# Chunk header containing execution commitments
class ExecutionChunkHeader(Container):
    index: uint8                     # Position in block (0 to MAX_CHUNKS_PER_BLOCK-1)
    parent_chunk_hash: Hash32        # Hash of parent chunk (previous chunk or last chunk of prev slot)
    timestamp: uint64                # Timestamp of chunk execution
    txs_root: Root                   # Merkle root of transactions
    receipts_root: Root              # Merkle root of receipts
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]  # Bloom filter for logs
    gas_used: uint64                 # Gas consumed in chunk
    state_root: Root                 # Post-execution state root
    withdrawals_root: Root           # Merkle root of withdrawals (only for last chunk)

# Self-contained execution chunk
class ExecutionChunk(Container):
    chunk_header: ExecutionChunkHeader
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_CHUNK]
    withdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]  # Only in last chunk
```

#### Chunk Access Lists (CALs)

CALs use the same RLP encoding as Block Access Lists from [EIP-7928](./eip-7928.md) but scoped to individual chunks. They contain state diffs from chunk execution:

```python
# Type aliases matching EIP-7928
Address = bytes  # 20-byte Ethereum address
StorageKey = bytes  # 32-byte storage slot key  
StorageValue = bytes  # 32-byte storage value
Balance = uint256  # Post-execution balance
Nonce = uint64  # Account nonce
CodeData = bytes  # Contract bytecode
TxIndex = uint16  # Transaction index within chunk

# Storage change: [tx_index, new_value]
StorageChange = [TxIndex, StorageValue]

# Balance change: [tx_index, post_balance]
BalanceChange = [TxIndex, Balance]

# Nonce change: [tx_index, new_nonce]
NonceChange = [TxIndex, Nonce]

# Code change: [tx_index, new_code]
CodeChange = [TxIndex, CodeData]

# All changes to a single storage slot
SlotChanges = [StorageKey, List[StorageChange]]

# All changes for a single account within the chunk
AccountChanges = [
    Address,                    # address
    List[SlotChanges],         # storage_changes
    List[StorageKey],          # storage_reads (read-only)
    List[BalanceChange],       # balance_changes
    List[NonceChange],         # nonce_changes
    List[CodeChange]           # code_changes
]

# Chunk Access List: All account changes in the chunk
ChunkAccessList = List[AccountChanges]
```

#### Consensus Layer Structures

```python
# Modified beacon block body
class BeaconBlockBody(Container):
    # ... existing fields ...
    chunk_roots: List[Root, MAX_CHUNKS_PER_BLOCK]  # Commitments to chunks
    chunk_access_list_roots: List[Root, MAX_CHUNKS_PER_BLOCK]  # Commitments to CALs
```

#### Network Sidecars

```python
# Chunk propagated as sidecar (can arrive before beacon block)
class ExecutionChunkSidecar(Container):
    slot: Slot                      # Slot this chunk belongs to
    proposer_index: ValidatorIndex   # Proposer who created this chunk
    chunk_index: uint8
    chunk: ExecutionChunk
    chunk_signature: BLSSignature

# CAL propagated as separate sidecar
class ChunkAccessListSidecar(Container):
    slot: Slot                      # Slot this CAL belongs to
    proposer_index: ValidatorIndex   # Proposer who created this CAL
    chunk_index: uint8
    chunk_access_list: ChunkAccessList
    cal_signature: BLSSignature
```

### Chunk Construction Rules

Block producers MUST follow these rules when creating chunks:

1. **Gas Limits**: Each chunk MUST NOT exceed `CHUNK_GAS_LIMIT` (16,777,216 gas)
2. **Minimum Fill**: Non-terminal chunks MUST use at least `MIN_CHUNK_FILL_RATIO * CHUNK_GAS_LIMIT` gas (8,388,608 gas), **unless** their gas usage combined with that of the subsequent chunk equals or exceeds the full `CHUNK_GAS_LIMIT`; in other words, if a chunk is underfilled, the sum of its gas and the next chunk's gas MUST be at least one full chunk's worth.
3. **Transaction Integrity**: Transactions MUST NOT be split across chunks
4. **Withdrawal Placement**: Withdrawals MUST only appear in the final chunk
5. **Hash Chain**: First chunk's `parent_chunk_hash` MUST reference the previous slot's last chunk hash; subsequent chunks MUST reference the previous chunk's hash
6. **Maximum Chunks**: A block MUST contain at most `MAX_CHUNKS_PER_BLOCK` chunks
7. **Ordering**: Chunks MUST be numbered sequentially from 0 to N-1

### Execution Semantics

#### Streaming Chunk Execution

The execution layer processes chunks in a streaming cascade where each chunk applies all prior CALs to the parent state:

```python
def el_state_transition(chunk, prior_cals):
    """EL executes chunk using CALs 0..N-1 applied to parent state"""
    chunk_index = chunk.chunk_header.index
    
    # Validate CAL availability
    if len(prior_cals) != chunk_index:
        # Missing required CALs
        return ChunkExecutionResult(
            status="INSUFFICIENT_INFORMATION",
            chunk_index=chunk_index,
            missing_cal_indices=list(range(len(prior_cals), chunk_index))
        )
    
    # Get parent block state
    parent_state = get_parent_block_state()
    if not parent_state:
        return ChunkExecutionResult(status="SYNCING", chunk_index=chunk_index)
    
    # Streaming cascade: Chunk N applies CALs 0..N-1 to parent state
    if chunk_index == 0:
        pre_state = parent_state
    else:
        # Apply ALL prior CALs (0 to chunk_index-1) to parent state
        pre_state = parent_state
        for i in range(chunk_index):
            pre_state = apply_state_diffs(pre_state, prior_cals[i])
    
    # Execute chunk transactions
    post_state = execute_transactions(pre_state, chunk.transactions)
    
    # Generate CAL for this chunk
    generated_cal = generate_chunk_access_list(chunk, post_state)
    
    return ChunkExecutionResult(
        status="VALID",
        chunk_index=chunk_index,
        post_state_root=post_state.root,
        chunk_access_list=generated_cal  # Enables execution of chunk N+1
    )
```

#### CAL Generation

The execution layer MUST generate CALs during chunk building and validation:

```python
def generate_chunk_access_list(chunk, post_state):
    """Generate CAL containing state diffs from chunk execution"""
    cal = ChunkAccessList()
    
    for tx_index, tx in enumerate(chunk.transactions):
        # Track all state changes from transaction
        for address in get_touched_addresses(tx):
            account_changes = AccountChanges(address)
            
            # Storage changes
            for slot, value in get_storage_writes(address, tx):
                account_changes.storage_changes.append([slot, [[tx_index, value]]])
            
            # Storage reads (no writes)
            for slot in get_storage_reads(address, tx):
                if slot not in account_changes.storage_changes:
                    account_changes.storage_reads.append(slot)
            
            # Balance, nonce, code changes
            if balance_changed(address):
                account_changes.balance_changes.append([tx_index, get_balance(post_state, address)])
            if nonce_changed(address):
                account_changes.nonce_changes.append([tx_index, get_nonce(post_state, address)])
            if code_changed(address):
                account_changes.code_changes.append([tx_index, get_code(post_state, address)])
            
            cal.append(account_changes)
    
    # Sort by address lexicographically
    return sort_cal_by_address(cal)
```

### Network Protocol

#### Early Chunk Propagation

Chunks can propagate before beacon block arrival, identified by (slot, proposer_index, chunk_index):

- **Chunks**: Published on `execution_chunk_sidecar_{subnet_id}` where `subnet_id = chunk_index % 16`
- **CALs**: Published on `chunk_access_list_sidecar_{subnet_id}` where `subnet_id = cal_index % 16`

Nodes MUST subscribe to all subnets to ensure full block availability. Chunks received before the beacon block are stored as "orphans" and confirmed when the block arrives with matching commitments.

#### Two-Phase Validation

##### Phase 1: Streaming Chunk Execution

The consensus layer orchestrates streaming chunk execution as CALs become available, enabling a cascade where each validated chunk produces a CAL for the next:

```python
def streaming_chunk_execution(store, block_root):
    """Phase 1: Streaming cascade execution as CALs arrive"""
    block = store.blocks[block_root]
    executed_chunks = {}
    available_cals = {}
    
    # Process chunks in streaming fashion
    for chunk_index in range(len(block.body.chunk_roots)):
        chunk = get_chunk(block_root, chunk_index)
        
        # Validate chunk structure and parent hash chain
        if not verify_chunk_structure(chunk):
            return False
        
        # Verify parent chunk hash
        if chunk_index == 0:
            # First chunk must reference previous slot's last chunk
            if chunk.chunk_header.parent_chunk_hash != store.latest_chunk_hash:
                return False
        else:
            # Subsequent chunks reference previous chunk
            prev_chunk = get_chunk(block_root, chunk_index - 1)
            if chunk.chunk_header.parent_chunk_hash != compute_chunk_hash(prev_chunk):
                return False
        
        # Execute chunk with CALs 0..chunk_index-1
        if chunk_index == 0:
            # First chunk executes on parent state
            result = engine_executeChunkWithCALs(block_root, chunk, [])
        else:
            # Gather CALs 0..chunk_index-1
            required_cals = []
            for i in range(chunk_index):
                while i not in available_cals:
                    cal = wait_for_cal(block_root, i)
                    available_cals[i] = cal
                required_cals.append(available_cals[i])
            
            # Send chunk with all prior CALs to EL
            result = engine_executeChunkWithCALs(block_root, chunk, required_cals)
        
        # Handle execution result
        if result.status == "VALID":
            executed_chunks[chunk_index] = result.post_state_root
            # Store generated CAL for next chunk (streaming cascade)
            available_cals[chunk_index] = result.chunk_access_list
        else:
            return False
    
    store.chunk_execution_status[block_root] = executed_chunks
    return True
```


### Consensus Layer Changes

#### Store Extensions

```python
class Store:
    # ... existing fields ...
    chunks: Dict[Tuple[Root, ChunkIndex], ExecutionChunk]
    chunk_hashes: Dict[Tuple[Root, ChunkIndex], Hash32]  # Track chunk hashes for chain validation
    chunk_access_lists: Dict[Tuple[Root, ChunkIndex], ChunkAccessList]
    chunk_execution_status: Dict[Root, Dict[ChunkIndex, Hash32]]  # chunk_index -> post_state_root
    
    # Orphan chunk storage (before block arrives)
    orphan_chunks: Dict[Tuple[Slot, ValidatorIndex, ChunkIndex], ExecutionChunk]
    orphan_cals: Dict[Tuple[Slot, ValidatorIndex, ChunkIndex], ChunkAccessList]
    
    # Block finalization tracking
    block_finalized: Dict[Root, bool]
    latest_chunk_hash: Hash32  # Track last chunk hash for chain continuity
```

#### Attestation Rules

Validators MUST NOT attest to a block until:

1. All chunks have been individually validated (Phase 1)
2. The complete state transition has been verified (Phase 2)
3. All chunk and CAL commitments match received sidecars

#### Block Validation

##### Phase 2: Hash Chain Validation and Block Finalization

After all chunks have been executed, the CL validates the hash chain and finalizes the block:

```python
def validate_block_state(store, block_root):
    """Phase 2: Validate hash chain and finalize block"""
    block = store.blocks[block_root]
    
    # Verify all chunks have been executed
    if block_root not in store.chunk_execution_status:
        return False
    
    executed_chunks = store.chunk_execution_status[block_root]
    if len(executed_chunks) != len(block.body.chunk_roots):
        return False
    
    # Validate hash chain continuity
    chunk_hashes = []
    for i in range(len(block.body.chunk_roots)):
        chunk = store.chunks[(block_root, i)]
        chunk_hash = compute_chunk_hash(chunk)
        chunk_hashes.append(chunk_hash)
        
        # Validate parent chunk hash
        if i == 0:
            # First chunk points to previous slot's last chunk
            if chunk.chunk_header.parent_chunk_hash != store.latest_chunk_hash:
                return False
        else:
            # Subsequent chunks point to previous chunk
            if chunk.chunk_header.parent_chunk_hash != chunk_hashes[i-1]:
                return False
    
    # Send finalization request to EL with validated chain
    result = engine_finalizeBlock(
        block_root,
        block.header.state_root,
        chunk_hashes
    )
    
    if result.status == "VALID":
        # Update latest chunk hash for next slot
        store.latest_chunk_hash = chunk_hashes[-1]
        store.block_finalized[block_root] = True
        return True
    
    return False
```


### Engine API

#### New Methods

The consensus layer drives chunk execution by sending chunks to the execution layer with their required Chunk Access Lists attached. The EL processes chunks as they arrive with sufficient prerequisites.

```python
# CL sends chunk with required CALs to EL for execution
engine_executeChunkWithCALs(
    block_hash: Hash32,
    chunk: ExecutionChunk, 
    required_cals: List[ChunkAccessList]  # CALs from chunks 0 to chunk.index-1
) -> ChunkExecutionResult

# Finalize block after all chunks have been executed
engine_finalizeBlock(
    block_hash: Hash32,
    state_root: Hash32,
    chunk_hashes: List[Hash32]  # For hash chain validation
) -> PayloadStatus
```

#### Response Types

```python
class ChunkExecutionResult(Container):
    status: str  # "VALID", "INVALID", "INSUFFICIENT_INFORMATION", "SYNCING"
    chunk_index: uint8
    validation_error: Optional[str]  # Error details if INVALID
    missing_cal_indices: Optional[List[uint8]]  # Which CALs are missing if INSUFFICIENT_INFORMATION
    post_state_root: Optional[Hash32]  # State root after chunk execution if VALID
    chunk_access_list: Optional[ChunkAccessList]  # Generated CAL for streaming cascade if VALID

class PayloadStatus(Container):
    status: str  # "VALID", "INVALID", "SYNCING"
    validation_error: Optional[str]
    final_state_root: Optional[Hash32]
```

### CL-EL Coordination

The consensus layer orchestrates chunk execution by managing CAL availability and sending chunks to the execution layer at the appropriate time:

```python
def consensus_layer_chunk_coordination(store, block):
    """CL logic for sending chunks to EL with required CALs"""
    block_hash = hash(block)
    received_cals = {}  # Track which CALs have been received
    executed_chunks = set()  # Track which chunks have been executed
    
    # Monitor for arriving CALs and chunks
    while len(executed_chunks) < len(block.body.chunk_roots):
        # Check which chunks can be executed based on CAL availability
        for chunk_index in range(len(block.body.chunk_roots)):
            if chunk_index in executed_chunks:
                continue
                
            # Chunk 0 doesn't require any CALs
            if chunk_index == 0:
                chunk = get_chunk(block_hash, 0)
                if chunk:
                    result = engine_executeChunkWithCALs(block_hash, chunk, [])
                    if result.status == "VALID":
                        executed_chunks.add(0)
            else:
                # Check if all required CALs are available
                required_cals = []
                cals_available = True
                for i in range(chunk_index):
                    if i not in received_cals:
                        cals_available = False
                        break
                    required_cals.append(received_cals[i])
                
                # Send chunk if all prerequisites are met
                if cals_available:
                    chunk = get_chunk(block_hash, chunk_index)
                    if chunk:
                        result = engine_executeChunkWithCALs(block_hash, chunk, required_cals)
                        if result.status == "VALID":
                            executed_chunks.add(chunk_index)
                        elif result.status == "INSUFFICIENT_INFORMATION":
                            # EL is missing some CALs, wait for them
                            print(f"Chunk {chunk_index} missing CALs: {result.missing_cal_indices}")
        
        # Update received CALs from network
        for cal_index, cal in get_new_cals_from_network():
            received_cals[cal_index] = cal
    
    # All chunks executed, finalize the block
    result = engine_finalizeBlock(
        block_hash,
        block.header.state_root,
        len(block.body.chunk_roots)
    )
    return result.status == "VALID"
```

## Rationale

### Why Streaming Cascade with Hash Chain?

The streaming cascade approach where chunk N applies CALs 0..N-1 to parent state provides:

1. **Parallel Execution**: Multiple chunks can execute simultaneously once their CALs are available
2. **Early Validation**: Invalid blocks can be rejected at the first invalid chunk
3. **Hash Chain Security**: The parent_chunk_hash chain ensures chunk ordering integrity
4. **Bounded Resources**: Each chunk independently bounded to `CHUNK_GAS_LIMIT`

### Why CL-Driven Architecture?

The consensus layer drives the execution layer for several key reasons:

1. **CAL Dependency Management**: The CL has the global view of which CALs have been received from the network and can orchestrate chunk execution in the optimal order based on availability
2. **Early Chunk Processing**: The CL can identify chunks by (slot, proposer, index) before block arrival
3. **Simplified EL Design**: The EL doesn't need to track or request CALs - it simply executes chunks when provided with sufficient prerequisites
4. **Natural Ordering**: The CL naturally enforces that chunks are executed only when their dependencies are met

### Why Separate CALs from Chunks?

Separating Chunk Access Lists (containing state diffs) from chunks provides several benefits:

1. **Independent Propagation**: CALs are typically much smaller than chunks (containing only state diffs) and propagate faster
2. **Parallel Execution**: Multiple chunks can execute independently by applying prior CALs to reconstruct required pre-states
3. **Modularity**: State diffs are logically separate from transaction data
4. **Future Compatibility**: CALs can be extended with additional metadata without modifying chunk structure
5. **Streaming Validation**: Validators can begin executing chunks as soon as required CALs arrive

### Why Semantic Chunking Over Simple Fragmentation?

Unlike simple byte-level fragmentation, semantic chunking:

1. **Enables Streaming Validation**: Chunks are self-contained execution units that can be validated as they arrive
2. **Bounds Resources**: Each chunk has maximum gas limits, bounding memory and CPU usage
3. **Supports Early Processing**: Chunks can begin execution before beacon block arrival using proposer identification

### Choice of Parameters

- **`CHUNK_GAS_LIMIT = 2**24`** (16.7M gas): Balances parallelization benefits with chunk overhead. Large enough for complex transactions, small enough for bounded proving
- **`MAX_CHUNKS_PER_BLOCK = 16`**: Supports up to 268M gas blocks
- **`MIN_CHUNK_FILL_RATIO = 0.5`**: Prevents excessive fragmentation while allowing flexibility in chunk construction

## Backwards Compatibility

This EIP introduces breaking changes to:

1. **Block Structure**: Replaces monolithic execution payload with chunked structure
2. **Network Protocol**: Adds new gossip topics for chunks and CALs
3. **Engine API**: Requires new streaming validation methods
4. **Fork Choice**: Adds two-phase validation logic

These changes require a coordinated hard fork.

## Security Considerations

### Data Availability

Chunk separation creates new data availability requirements:

1. **Withholding Attacks**: Proposers could withhold specific chunks or CALs to make blocks unvalidatable
   - **Mitigation**: Attestation rules require full chunk availability before voting
   - **Detection**: Missing chunks are easily identified by commitment mismatches

2. **Partial Withholding**: Withholding CALs (state diffs) while publishing chunks
   - **Impact**: Delays streaming execution but doesn't prevent sequential validation
   - **Mitigation**: CALs can be reconstructed by executing chunks sequentially to capture state diffs

3. **Orphan Chunk Handling**: Chunks arriving before beacon blocks
   - **Storage**: Orphan chunks stored temporarily with (slot, proposer, index) identification
   - **Validation**: Confirmed against commitments when beacon block arrives
   - **Limits**: Bounded orphan storage prevents DoS attacks

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
