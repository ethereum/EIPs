---
eip: 9999
title: ZW-Token — Single-State Irreversible-Supply ERC-20
description: A fungible token whose total supply can only decrease…
author: …
status: Draft
type: Standards Track
category: ERC
created: 2025-11-23
requires: 20, 165
---
Abstract

This EIP introduces ZW-Token, a fungible token whose total supply is irreversible, strictly non-increasing, and represented in a single canonical state.
Unlike existing burn or privacy extensions, ZW-Token disallows:

re-minting burned supply,

mirrored or synthetic representations,

wrapped layers that fragment total supply.

The standard also defines an optional privacy obfuscation layer that preserves single-state value semantics without altering supply representation.

Motivation

Fungible ERC-20 tokens today allow:

reclaimable burns,

synthetic supply mirrors,

off-chain mirrored states,

wrapped variants representing the same value,

privacy layers that temporarily break supply invariants.

These patterns introduce ambiguity in “what is the real supply,” complicating accounting, audits and trust minimization.

Irreversibility

In contrast, NFTs (ERC-721) can be permanently destroyed without re-entry.
ZW-Token extends that semantic guarantee to fungible assets.

Single-State Supply

This ERC mandates:

no shadow supply,

no synthetic supply offsets,

no alternate representations,

no reintroductions after burn.

Motivation — Live Implementation

Before drafting this EIP, I deployed a mainnet experiment (TEN.IO Fragment 0 “EL UMBRAL”) demonstrating irreversible-supply semantics:

11 tokens minted

3 irreversibly burned

0 wrapped representations

all value represented in exactly one state

This proves irreversible fungible supply is viable without wrappers, bridges or synthetic mirrors.

Specification
1. Immutable Total Supply Constraint

Total supply MUST satisfy:

totalSupply(t+1) ≤ totalSupply(t)


At all times.

2. Burn Semantic

burn(uint256 amount) MUST:

reduce totalSupply permanently

not allow future re-minting of burned units

not be overridable by governance

3. Mint Constraint

Minting MUST follow:

mintAllowed == (totalSupply == 0)


Meaning:

The only allowed minting is initial supply.

After initialization, the ERC is permanently deflationary.

4. Single-State Representation

The token MUST NOT:

produce wrapped variants representing the same supply

maintain mirrored or synthetic supply layers

rely on zk-buckets that alter supply-accounting

Privacy layers MUST act only as obfuscation, not supply fragmentation.

5. Optional Privacy Layer

If implemented, private transfers MUST satisfy:

value_hidden == value_real


And the privacy circuit MUST NOT allow:

hidden minting

alternate value states

reversible burns

Rationale
Why irreversible supply?

Irreversible supply minimizes the attack surface of:

re-minting vulnerabilities

governance supply corruption

trust dependencies in wrapped tokens

supply mismatch between layers

Why single-state?

A single supply layer eliminates fragmentation, simplifies proof-of-reserves, improves DeFi composability, and prevents accounting drift.

Privacy systems often introduce synthetic accounting layers; ZW-Token ensures privacy without breaking supply invariants.

Reference Implementation
pragma solidity ^0.8.20;

contract ZWToken {
    string public name = "ZW-Token";
    string public symbol = "ZW";
    uint8 public decimals = 18;

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply;
        balanceOf[msg.sender] = initialSupply;
    }

    function burn(uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "insufficient");
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount);
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        require(balanceOf[from] >= amount);
        require(allowance[from][msg.sender] >= amount);
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
}

Backwards Compatibility

Fully compatible with:

ERC-20

ERC-20 metadata

ETH-based tooling

Indexers

Bridges (as consumers, not producers of synthetic supply)

Security Considerations

Burn irreversibility minimizes governance capture

No synthetic supply reduces systemic risk

Privacy layer MUST NOT allow hidden minting

No alternate supply states prevents economic attacks through wrappers

Copyright

CC0.
