---
eip: <TBD>
title: Payload Chunking with Chunk Access Lists
description: Semantic block chunking with separated state diffs for streaming validation and reduced latency
author: Toni Wahrstätter (@nerolation), Jihoon Song (@jihoonsong), Milos Stankovic (@morph-dev), Bharath Vedartham (@bharath-123), Raúl Kripalani (@raulk)
discussions-to: https://ethereum-magicians.org/t/<TBD>
status: Draft
type: Standards Track
category: Core
created: 2025-01-27
requires: 4844, 7928
---

## Abstract

This EIP introduces Payload Chunking, a protocol upgrade that restructures Ethereum blocks into self-contained execution chunks with separated Chunk Access Lists (CALs). Each chunk can be validated independently as it arrives, enabling streaming validation that reduces block processing latency. CALs propagate separately and enable the execution layer to process chunks independently without sequential dependencies. This architecture transforms block processing from a monolithic operation into a composable pipeline while preserving block atomicity.

## Motivation

As Ethereum's gas limits increase, block sizes and execution complexity grow correspondingly. The current monolithic block structure requires validators to download the entire block before beginning execution, creating a critical bottleneck in the consensus timeline. This latency becomes increasingly problematic as larger blocks take longer to propagate and decompress before execution can begin.

This proposal addresses these issues by:

- Enabling streaming validation where execution begins as chunks arrive
- Bounding resource requirements to per-chunk maximums (`2**24` gas)
- Allowing early rejection of invalid blocks without processing all chunks
- Supporting independent chunk execution using CALs containing cumulative state diffs
- Creating natural boundaries for future per-chunk proving systems

## Specification

### Constants

```python
CHUNK_GAS_LIMIT = 2**24  # 16,777,216 gas per chunk
MAX_CHUNKS_PER_BLOCK = 16  # Maximum chunks in a block
MIN_CHUNK_FILL_RATIO = 0.5  # Non-terminal chunks must be ≥50% full
CHUNK_INCLUSION_PROOF_DEPTH = 5  # Merkle proof depth for chunk inclusion
```

### Data Structures

#### Execution Layer Structures

```python
# Chunk header containing execution commitments
class ExecutionChunkHeader(Container):
    index: uint8                    # Position in block (0 to MAX_CHUNKS_PER_BLOCK-1)
    txs_root: Root                  # Merkle root of transactions
    pre_state_root: Root            # State root before chunk execution
    receipts_root: Root             # Merkle root of receipts
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]  # Bloom filter for logs
    gas_used: uint64                # Gas consumed in chunk
    withdrawals_root: Root          # Merkle root of withdrawals (if present)

# Self-contained execution chunk
class ExecutionChunk(Container):
    chunk_header: ExecutionChunkHeader
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_CHUNK]
    withdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]  # Only in last chunk
```

#### Chunk Access Lists (CALs)

CALs use the same RLP encoding as Block Access Lists from [EIP-7928](./eip-7928.md) but scoped to individual chunks. They contain state diffs from chunk execution:

```python
# Type aliases matching EIP-7928
Address = bytes  # 20-byte Ethereum address
StorageKey = bytes  # 32-byte storage slot key  
StorageValue = bytes  # 32-byte storage value
Balance = uint256  # Post-execution balance
Nonce = uint64  # Account nonce
CodeData = bytes  # Contract bytecode
TxIndex = uint16  # Transaction index within chunk

# Storage change: [tx_index, new_value]
StorageChange = [TxIndex, StorageValue]

# Balance change: [tx_index, post_balance]
BalanceChange = [TxIndex, Balance]

# Nonce change: [tx_index, new_nonce]
NonceChange = [TxIndex, Nonce]

# Code change: [tx_index, new_code]
CodeChange = [TxIndex, CodeData]

# All changes to a single storage slot
SlotChanges = [StorageKey, List[StorageChange]]

# All changes for a single account within the chunk
AccountChanges = [
    Address,                    # address
    List[SlotChanges],         # storage_changes
    List[StorageKey],          # storage_reads (read-only)
    List[BalanceChange],       # balance_changes
    List[NonceChange],         # nonce_changes
    List[CodeChange]           # code_changes
]

# Chunk Access List: All account changes in the chunk
ChunkAccessList = List[AccountChanges]
```

#### Consensus Layer Structures

```python
# Modified beacon block body
class BeaconBlockBody(Container):
    # ... existing fields ...
    chunk_roots: List[Root, MAX_CHUNKS_PER_BLOCK]  # Commitments to chunks
    chunk_access_list_roots: List[Root, MAX_CHUNKS_PER_BLOCK]  # Commitments to CALs
    # execution_payload field removed - replaced by chunks
```

#### Network Sidecars

```python
# Chunk propagated as sidecar
class ExecutionChunkSidecar(Container):
    chunk: ExecutionChunk
    chunk_signature: SignedBeaconBlockHeader
    chunk_root_inclusion_proof: Vector[Bytes32, CHUNK_INCLUSION_PROOF_DEPTH]

# CAL propagated as separate sidecar
class ChunkAccessListSidecar(Container):
    chunk_access_list: ChunkAccessList
    cal_signature: SignedBeaconBlockHeader
    cal_root_inclusion_proof: Vector[Bytes32, CHUNK_INCLUSION_PROOF_DEPTH]
```

### Chunk Construction Rules

Block producers MUST follow these rules when creating chunks:

1. **Gas Limits**: Each chunk MUST NOT exceed `CHUNK_GAS_LIMIT` (16,777,216 gas)
2. **Minimum Fill**: Non-terminal chunks MUST use at least `MIN_CHUNK_FILL_RATIO * CHUNK_GAS_LIMIT` gas (8,388,608 gas), except if the subsequent chunk exceeds the miniumum fill ratio again.
3. **Transaction Integrity**: Transactions MUST NOT be split across chunks
4. **Withdrawal Placement**: Withdrawals MUST only appear in the final chunk
5. **State Continuity**: The post-state root of chunk N-1 MUST equal the pre-state of chunk N
6. **Maximum Chunks**: A block MUST contain at most `MAX_CHUNKS_PER_BLOCK` chunks
7. **Ordering**: Chunks MUST be numbered sequentially from 0 to N-1

### Execution Semantics

#### Independent Chunk Execution

Chunks can execute independently using CALs containing state diffs from prior chunks:

```python
def execute_chunk_independent(chunk_index, chunk, parent_state, prior_cals):
    """Execute chunk using CALs for pre-state reconstruction"""
    if chunk_index == 0:
        pre_state = parent_state
    else:
        # Apply prior CALs to reconstruct pre-state
        pre_state = parent_state
        for cal in prior_cals[0:chunk_index]:
            pre_state = apply_state_diffs(pre_state, cal)
    
    # Execute chunk transactions
    post_state, receipts = execute_transactions(pre_state, chunk.transactions)
    
    # Apply withdrawals if present
    if chunk.withdrawals:
        post_state = apply_withdrawals(post_state, chunk.withdrawals)
    
    # Verify state root
    assert post_state.root == chunk.chunk_header.post_state_root
    
    return post_state, receipts
```

#### CAL Generation

The execution layer MUST generate CALs containing state diffs during chunk execution:

```python
def generate_chunk_access_list(chunk, pre_state, post_state):
    """Generate CAL containing state diffs from chunk execution"""
    cal = ChunkAccessList()
    
    for tx_index, tx in enumerate(chunk.transactions):
        # Track all state changes from transaction
        for address in get_touched_addresses(tx):
            account_changes = AccountChanges(address)
            
            # Storage changes
            for slot, value in get_storage_writes(address, tx):
                account_changes.storage_changes.append([slot, [[tx_index, value]]])
            
            # Storage reads (no writes)
            for slot in get_storage_reads(address, tx):
                if slot not in account_changes.storage_changes:
                    account_changes.storage_reads.append(slot)
            
            # Balance, nonce, code changes
            if balance_changed(address):
                account_changes.balance_changes.append([tx_index, get_balance(post_state, address)])
            if nonce_changed(address):
                account_changes.nonce_changes.append([tx_index, get_nonce(post_state, address)])
            if code_changed(address):
                account_changes.code_changes.append([tx_index, get_code(post_state, address)])
            
            cal.append(account_changes)
    
    # Sort by address lexicographically
    return sort_cal_by_address(cal)
```

### Network Protocol

#### Gossip Topics

Chunks and CALs are propagated on separate subnet-based gossip topics:

- **Chunks**: `execution_chunk_sidecar_{subnet_id}` where `subnet_id = chunk_index % 16`
- **CALs**: `chunk_access_list_sidecar_{subnet_id}` where `subnet_id = cal_index % 16`

Nodes MUST subscribe to all subnets to ensure full block availability.

### Fork Choice Modifications

#### Store Extensions

```python
class Store:
    # ... existing fields ...
    chunks: Dict[Tuple[Root, ChunkIndex], ExecutionChunk]
    chunk_access_lists: Dict[Tuple[Root, ChunkIndex], ChunkAccessList]
    chunk_validation_status: Dict[Tuple[Root, ChunkIndex], bool]  # Phase 1
    block_state_valid: Dict[Root, bool]  # Phase 2
```

#### Two-Phase Validation

##### Phase 1: Chunk Validation (Streaming)

As chunks arrive, validators verify:

```python
def validate_chunk(store, block_root, chunk_index, chunk):
    """Phase 1: Validate individual chunk"""
    # Verify chunk internally
    if not verify_chunk_header(chunk.chunk_header):
        return False
    
    # Verify transactions are valid
    for tx in chunk.transactions:
        if not validate_transaction(tx):
            return False
    
    # Verify gas limit and minimum fill
    if chunk.chunk_header.gas_used > CHUNK_GAS_LIMIT:
        return False
    
    # Non-terminal chunks must meet minimum fill
    is_last_chunk = (chunk_index == len(store.blocks[block_root].body.chunk_roots) - 1)
    if not is_last_chunk:
        if chunk.chunk_header.gas_used < CHUNK_GAS_LIMIT * MIN_CHUNK_FILL_RATIO:
            return False
    
    # Mark chunk as validated
    store.chunk_validation_status[(block_root, chunk_index)] = True
    return True
```

##### Phase 2: Block State Validation

After all chunks are received:

```python
def validate_block_state(store, block_root):
    """Phase 2: Verify complete state transition"""
    block = store.blocks[block_root]
    
    # Verify all chunks validated
    for i in range(len(block.body.chunk_roots)):
        if not store.chunk_validation_status.get((block_root, i), False):
            return False
    
    # Verify state continuity
    for i in range(1, len(block.body.chunk_roots)):
        prev_chunk = store.chunks[(block_root, i-1)]
        curr_chunk = store.chunks[(block_root, i)]
        if prev_chunk.chunk_header.post_state_root != get_pre_state(curr_chunk):
            return False
    
    # Verify final state matches header
    final_chunk = store.chunks[(block_root, len(block.body.chunk_roots) - 1)]
    if final_chunk.chunk_header.post_state_root != block.header.state_root:
        return False
    
    store.block_state_valid[block_root] = True
    return True
```

#### Attestation Rules

Validators MUST NOT attest to a block until:

1. All chunks have been individually validated (Phase 1)
2. The complete state transition has been verified (Phase 2)
3. All chunk and CAL commitments match received sidecars

### Engine API

#### New Methods

```python
# Phase 1: Stream chunks as they arrive
engine_newChunk(chunk: ExecutionChunk, parent_hash: Hash32) -> ChunkValidationResult

# Provide CAL for independent execution
engine_newChunkAccessList(block_hash: Hash32, index: uint8, cal: ChunkAccessList) -> bool

# Phase 2: Finalize block validation
engine_finalizeChunkedPayload(
    block_hash: Hash32,
    expected_chunks: List[ChunkIndex],
    state_root: Hash32
) -> PayloadStatus
```

## Rationale

### Why Separate CALs from Chunks?

Separating Chunk Access Lists (containing state diffs) from chunks provides several benefits:

1. **Independent Propagation**: CALs are typically much smaller than chunks (containing only state diffs) and propagate faster
2. **Parallel Execution**: Multiple chunks can execute independently by applying prior CALs to reconstruct required pre-states
3. **Modularity**: State diffs are logically separate from transaction data
4. **Future Compatibility**: CALs can be extended with additional metadata without modifying chunk structure
5. **Streaming Validation**: Validators can begin executing chunks as soon as required CALs arrive

### Why Semantic Chunking Over Simple Fragmentation?

Unlike simple byte-level fragmentation, semantic chunking:

1. **Enables Streaming Validation**: Chunks are self-contained execution units that can be validated immediately
2. **Bounds Resources**: Each chunk has maximum gas limits, bounding memory and CPU usage
3. **Supports Early Rejection**: Invalid chunks fail fast without processing the entire block
4. **Natural Proving Boundaries**: Each chunk can be proven independently with bounded computation

### Choice of Parameters

- **`CHUNK_GAS_LIMIT = 2**24`** (16.7M gas): Balances parallelization benefits with chunk overhead. Large enough for complex transactions, small enough for bounded proving
- **`MAX_CHUNKS_PER_BLOCK = 16`**: Supports up to 268M gas blocks
- **`MIN_CHUNK_FILL_RATIO = 0.5`**: Prevents excessive fragmentation while allowing flexibility in chunk construction

## Backwards Compatibility

This EIP introduces breaking changes to:

1. **Block Structure**: Replaces monolithic execution payload with chunked structure
2. **Network Protocol**: Adds new gossip topics for chunks and CALs
3. **Engine API**: Requires new streaming validation methods
4. **Fork Choice**: Adds two-phase validation logic

These changes require a coordinated hard fork. Nodes that do not upgrade will be unable to:

- Validate new blocks
- Participate in consensus
- Sync with the network post-fork

## Security Considerations

### Data Availability

Chunk separation creates new data availability requirements:

1. **Withholding Attacks**: Proposers could withhold specific chunks or CALs to make blocks unvalidatable
   - **Mitigation**: Attestation rules require full chunk availability before voting
   - **Detection**: Missing chunks are easily identified by commitment mismatches

2. **Partial Withholding**: Withholding CALs (state diffs) while publishing chunks
   - **Impact**: Delays independent execution but doesn't prevent sequential validation
   - **Mitigation**: CALs can be reconstructed by executing chunks sequentially to capture state diffs

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
