---
eip: 9999
title: Block-Level Access Lists
description: Enforced block-level access lists for parallalizing transaction validation
author: Toni Wahrstätter (@nerolation), Dankrad Feist (@dankrad), Francesco D`Amato (@fradamt), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat)
discussions-to: https://ethereum-magicians.org/t/eip-xxxx-block-level-access-lists/23337
status: Draft
type: Standards Track
category: Core
created: 2025-03-31
---

## Abstract

This EIP proposes adding block-level access lists. By including a complete list of all addresses and storage keys accessed during a block—along with their initial values—in the block header, we can improve execution efficiency and enable better parallelization.

## Motivation

Currently, transactions without an explicit transaction access list cannot be efficiently parallelized, as the execution engine cannot determine in advance which addresses and storage slots will be accessed. While transaction-level access lists exist, they are not enforced, making it difficult to optimize execution pipelines.

By enforcing access lists at the block level, we shift the responsibility of declaring storage accesses to the block builder. This enables the execution engine to efficiently parallelize transaction execution, knowing in advance the exact scope of storage interactions for each transaction. 

With access lists at the block level, transactions can be scheduled and executed in parallel, allowing for performance improvements.

## Specification

### Block Header Modification

Introduce a new field in the block header:

```python
class BlockBody:
    ...
    # Each access → ordered list of tx indices and associated values
    block_level_accesses: Dict[
        Tuple[Address, StorageKey],
        Tuple[
            List[int],  # The transaction indices that accessed this slot
            List[Union[Value, Tuple[Value, Optional[Value]]]]  # The corresponding read or write values
        ]
    ]
```

The block_level_access_list maps each accessed address and storage key to the index of the transaction that accesses it, along with the corresponding storage values, old and new ones. This structure enables efficient validation and execution by explicitly tying storage interactions and their values to specific transactions.

### State Transition Function

Modify the state transition function to validate the block-level access lists asynchronously:

```python 
async def state_transition(block: Block) -> None:
    computed_access_list = []

    for tx in block.transactions:
        accessed_items = execute_transaction(tx)
        computed_access_list.append(accessed_items)

    if computed_access_list != block.header.block_level_access_list:
        raise InvalidBlock("Mismatch in block-level access list.")
```

Transactions must not touch any address or storage key outside those declared in the block-level access list. Additionally, the block is invalid if the access list includes addresses or storage keys that were not actually accessed during execution.

###  Opcode Handling

## Rationale

### Block Size Considerations

Including access lists increases block size, potentially impacting network propagation times. Empirically, typical access lists are around 30 KiB, with occasional peaks up to 120 KiB. Efficient encoding and potential limits on access list sizes should be considered.

### Asynchronous Verification

Block execution can proceed immediately, while verification of the access list occurs in parallel, ensuring correctness without delaying execution.

## Backwards Compatibility

This proposal requires changes to the block structure and the EVM's gas calculation mechanisms are not backwards compatible and require a hard fork. 

## Security Considerations

### Validation Overhead

Nodes must verify that the access lists in the block header accurately reflect the actual accesses during execution. Discrepancies should result in block invalidation.

### Block Size

Including comprehensive access lists may increase block size, potentially impacting network propagation times. Empirical analysis shows typical access lists around 30 KiB, with occasional peaks up to 120 KiB.

## Copyright

Copyright and related rights waived via [CC0](./LICENSE.md).

