---
eip: 4762
title: Statelessness gas cost changes
description: Changes the gas schedule to reflect the costs of creating a witness by requiring clients update their database layout to match.
author: Guillaume Ballet (@gballet), Vitalik Buterin (@vbuterin), Dankrad Feist (@dankrad), Ignacio Hagopian (@jsign), Tanishq Jasoria (@tanishqjasoria), Gajinder Singh (@g11tech)
discussions-to: https://ethereum-magicians.org/t/eip-4762-statelessness-gas-cost-changes/8714
status: Draft
type: Standards Track
category: Core
created: 2022-02-03
---
## Abstract

This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.

## Motivation

The introduction of Stateless Ethereum requires fundamental changes, and this EIP introduces changes to the gas schedule, reflecting the new storage model, which seeks to disincentivize state and witness growth.

## Specification

### Helper functions

```python
def get_storage_slot_tree_keys(storage_key: int) -> [int, int]:
    if storage_key < (CODE_OFFSET - HEADER_STORAGE_OFFSET):
        pos = HEADER_STORAGE_OFFSET + storage_key
    else:
        pos = MAIN_STORAGE_OFFSET + storage_key
    return (
        pos // 256,
        pos % 256
    )
```

### Access events

Whenever the state is read or written to, one or more of the access events of the form `(address, sub_key, leaf_key)` take place, determining what data is being accessed. We define access events as follows:

```python3
def add_access_event(address: bytes20, sub_key: bytes31, leaf_key: byte, is_write: bool):
  event = (address, sub_key, leaf_key)
  if is_write:
    tx.access_events.writes.append(event)
  else:
    tx.acess_events.reads.append(event)

def add_write_access_events(address: bytes20, sub_key: bytes31, leaf_key: byte):
  add_read_acess_events(address, sub_key, leaf_key)
  add_access_event(address, sub_key, leaf_key, True)
  
def add_read_access_events(address: bytes20, sub_key: bytes31, leaf_key: byte):
  add_access_event(address, sub_key, leaf_key, False)
```

The consequence of this model, is that it created group-locality in the state, with each "group" containing 256 contiguous leaves.

An event will be triggered:

 * Every time a group is accessed
 * Every time a single leaf is accessed

The model makes a distinction between read and write events. As we will see later, gas costs are associated to these events.

#### Atomicity

The calls to `charge_gas()` are here to delimit the atomic boundaries of an operation. All the events emitted between two consecutive calls to `charge_gas` are charged together. If there isn't enough gas to pay for all events, none of the associated values are added to the witness.

#### Access events for account headers

```python3
# Emit all access events given an instruction. It is meant to be called before
# the gas charging method for a given instruction is called, as these events
# are subsequently used to process witness-related gas costs.
def emit_access_events(opcode: int, stack: Stack, contract: Contract, new_contract: Optional[Contract]):
  match opcode:
    case OP_CALL | OP_DELEGATECALL | OP_STATICCALL | OP_CALLCODE | OP_SELFDESTRUCT:
      address = stack.peek(1)

      # XXX the previous version of the spec says OP_CALLCODE is concerned, but the geth
      # code says it isn't.
      if value_bearing and (opcode == OP_CALL or opcode == OP_SELFDESTRUCT or opcode == OP_CALLCODE):
        add_write_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)
        add_write_access_event(address, 0, BASIC_DATA_LEAF_KEY)

        # If the operation triggers an account creation, charge the
        # full cost of account creation
        if not state.has_account(address):
          add_write_access_event(address, 0, CODEHASH_LEAF_KEY)
      else:
        if is_precompile(address) or is_system_contract(address):
          # XXX charge warm costs
        else:
          add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)
       
      add_read_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)

    case OP_EXTCODECOPY | OP_EXTCODESIZE:
      address = stack.peek(0)
      add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)

    case OP_BALANCE:
      address = stack.peek(0)
      add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)

    case OP_CODECOPY:
       if not contract.is_deployment:
         add_read_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)

    case OP_EXTCODEHASH:
      address = stack.peek(0)
      if not (is_precompile(address) or is_system_contract(address)):
        add_read_access_event(address, 0, CODEHASH_LEAF_KEY)

    case OP_SLOAD:
      key = stack.peek(0)
      read_access_for_storage(contract.address, key)

    case OP_SSTORE:
      key = stack.peek(0)
      write_access_for_storage(contract.address, key)

    case OP_CREATE | OP_CREATE2:
      # Explitly specify that the witness costs for contract
      # creation are not charged as part of the instruction,
      # but as part of the creation execution it triggers.
      # This means, among other things, that the subtraction
      # of 1/64th of the gas is done before.

  charge_gas()

# This function is to be called right when it is known that the
# account will be created.
def emit_access_events_for_contract_creation_init(address: Address):
  add_write_access_event(address, 0, BASIC_DATA_LEAF_KEY)
  add_write_access_event(address, 0, CODEHASH_LEAF_KEY)
  charge_gas()

def emit_access_events_for_contract_creation_account_check(address: Address):
  add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)
  add_read_access_event(address, 0, CODEHASH_LEAF_KEY)
  charge_gas()
  
def read_access_for_storage(contract_address: bytes20, storage_key: byte32):
  index, suffix = get_storage_slot_tree_keys(contract_address, storage_key)
  add_read_access_event(contract_address, index, suffix)
  charge_gas()
```

##### Access events for delegation

When `contract_address` is that of a delegating EoA, process the following events:

 - For an `EXTCODEHASH`:

```
(delegated_address, 0, CODEHASH_LEAF_KEY)
```

 - For an `EXTCODESIZE`, or any other `*CALL`, `CALLCODE`:

```
(delegated_address, 0, BASIC_DATA_LEAF_KEY)
```

#### Access events for code

```python3
def interpreter_loop(code: bytes, contract_address: bytes20):
  pc = 0

  # ...

  while True:
    if pc < len(code):
      emit_code_access_events(pc, code, contract_address)
      # ... rest of the interpreter loop

# Executed when decoding an instruction when running the interpreter loop
def emit_code_access_events(pc: int, code: bytes, contract_address: Address):
  opcode = OP_STOP # pad chunk with 0s
  # if the code walks beyond the code size, it is not considered to be accessed.
  # XXX I don't think that this is true on mainnet, even before the atomic stuff!
  if pc >= len(code):
    return

  opcode = code[pc]
  chunk = pc // CHUNK_SIZE

  add_read_access_event(contract_address, (chunk + CODE_OFFSET) // 256, (chunk + CODE_OFFSET) % 256)
  charge_gas() # Note that the witness gas for instruction access is charged immediately,
               # independently of access costs for its immediates.

  # add access events for immediates, if the instruction has them
  match opcode:
    case OP_JUMP:
      dest = stack.peek(0)
      # The destination of a jump is not considered to be accessed if it is beyond the code
      if dest < len(code):
        # The destination of a `JUMP` is considered to be accessed, even if the destination is not a jumpdest or is inside pushdata
        add_read_access_event(contract_address, (dest_chunk + CODE_OFFSET) // 256, (dest_chunk + CODE_OFFSET) % 256)

    case OP_JUMPI:
      dest = stack.peek(0)
      cond = stack.peek(1)
      # The destination of a jump is not considered to be accessed if it is beyond the code
      if dest < len(code):
        dest_chunk = dest // CHUNK_SIZE
        # The destination of a positively evaluated `JUMPI` is considered to be accessed, even if the destination is not a jumpdest or is inside pushdata
        # The destination of a `JUMPI` is not considered to be accessed if the jump conditional is `false`
        if opcode == OP_JUMP or cond:
          add_read_access_event(contract_address, (dest_chunk + CODE_OFFSET) // 256, (dest_chunk + CODE_OFFSET) % 256)

    case OP_PUSH1 | OP_PUSH2 | ... | OP_PUSH32:
      nbytes = opcode - OP_PUSH0 # determine the number of extra bytes to touch
      for i in range(nbytes):
        immediate_chunk = (pc+i) // CHUNK_SIZE
        if immediate_chunk <= (len(code)+CHUNK_SIZE-1) // CHUNK_SIZE:
          add_read_access_event(contract_address, (immediate_chunk + CODE_OFFSET) // 256, (immediate_chunk + CODE_OFFSET) % 256)

    case OP_CODECOPY | OP_EXTCODECOPY:
      addr = contract_address
      size = 0
      offset = 0
      if opcode == OP_EXTCODECOPY:
        addr = stack.peek(0)
        offset = stack.peek(2)
        size = stack.peek(3)
      else:
        offset = stack.peek(1)
        size = stack.peek(2)

      for i in range(size):
        copied_byte_chunk = (offset+i) // CHUNK_SIZE 
        if copied_byte_chunk <= (len(code)+CHUNK_SIZE-1) // CHUNK_SIZE:
          add_read_access_event(contract_address, (copied_byte_chunk + CODE_OFFSET) // 256, (copied_byte_chunk + CODE_OFFSET) % 256)

    case OP_CODESIZE | OP_EXTCODESIZE | OP_EXTCODEHASH:
      # None of these operations access any chunk, it is
      # explicitly documented here as a no-op.

  charge_gas()
```

Note: since no access list existed for code up until this EIP, note that no warm costs are charged for code accesses.

When a contract is created, access chunks `0 ... (len(code)+30)//31`:

```python3
def emit_code_write_access_events(address: Address, code: bytes):
    # Calculate the number of code chunks required, rounding up for any partial final chunk.
    # This ensures that all code bytes are covered, even if the code size is not a multiple of CHUNK_SIZE.
  last_chunk_num = (len(code) + CHUNK_SIZE - 1) // CHUNK_SIZE

  for chunk_num in range(last_chunk_num):
    add_write_access_event(address, (chunk_num + CODE_OFFSET) // 256, (chunk_num + CODE_OFFSET) % 256)

  charge_gas()
```

### Transaction

For a transaction, make these access events:

```python3
def emit_tx_prologue_events(from: Address, to: Address, value: int):
  add_write_access_event(from, 0, BASIC_DATA_LEAF_KEY) # Note this is the only write, because of the nonce
  add_read_access_event(from, 0, CODEHASH_LEAF_KEY)
  add_read_access_event(to, 0, BASIC_DATA_LEAF_KEY)
  add_read_access_event(to, 0, CODEHASH_LEAF_KEY)

  if value != 0:
    add_write_access_event(to, 0, BASIC_DATA_LEAF_KEY)

    if not state.has_account(to):
      add_write_access_event(to, 0, CODEHASH_LEAF_KEY)

  # Note that gas isn't charged, as it's considered covered by
  # the transaction's intrinsic gas.
```

For a contract-creating transaction, the emitted events are defined by:

```python
def contract_creation(address: Address, code: bytes):
  # ...
  # Just after incrementing the caller's nonce
  emit_access_events_for_contract_creation_init(address)

  # ...
  # Just before creating the contract's account
  emit_access_events_for_contract_creation_account_check(address)

  # ...
  # Just before setting the contract's code
  emit_code_write_access_events(address, code)
  
```

### Witness gas costs

Remove the following gas costs:

 * Increased gas cost of `CALL` if it is nonzero-value-sending
 * [EIP-2200](./eip-2200.md) `SSTORE` gas costs except for the `SLOAD_GAS`
 * 200 per byte contract code cost
 * All `CALLCODE` costs related to nonzero-value-sending

Reduce gas cost:

 * `CREATE`/`CREATE2` to 1000

| Constant              | Value |
| --------------------- | ----- |
| `WITNESS_BRANCH_COST` | 1900  |
| `WITNESS_CHUNK_COST`  | 200   |
| `SUBTREE_EDIT_COST`   | 3000  |
| `CHUNK_EDIT_COST`     | 500   |
| `CHUNK_FILL_COST`     | 6200  |

When executing a transaction, maintain four sets:

 * `accessed_subtrees: Set[Tuple[address, int]]`
 * `accessed_leaves: Set[Tuple[address, int, int]]`
 * `edited_subtrees: Set[Tuple[address, int]]`
 * `edited_leaves: Set[Tuple[address, int, int]]`


When an **access** event of `(address, sub_key, leaf_key)` occurs, perform the following checks:

 * Perform the following steps unless event is a _Transaction access event_;
 * If `(address, sub_key)` is not in `accessed_subtrees`, charge `WITNESS_BRANCH_COST` gas and add that tuple to `accessed_subtrees`.
 * If `leaf_key` is not `None` and `(address, sub_key, leaf_key)` is not in `accessed_leaves`, charge `WITNESS_CHUNK_COST` gas and add it to `accessed_leaves`

When a **write** event of `(address, sub_key, leaf_key)` occurs, perform the following checks:

 * If event is _Transaction write event_, skip the following steps.
 * If `(address, sub_key)` is not in `edited_subtrees`, charge `SUBTREE_EDIT_COST` gas and add that tuple to `edited_subtrees`.
 * If `leaf_key` is not `None` and `(address, sub_key, leaf_key)` is not in `edited_leaves`, charge `CHUNK_EDIT_COST` gas and add it to `edited_leaves`
     * Additionally, if there was no value stored at `(address, sub_key, leaf_key)` (ie. the state held `None` at that position), charge `CHUNK_FILL_COST`

Note that tree keys can no longer be emptied: only the values `0...2**256-1` can be written to a tree key, and 0 is distinct from `None`. Once a tree key is changed from `None` to not-`None`, it can never go back to `None`.

Note that values should only be added to the witness if there is sufficient gas to cover their associated event costs. If there is not enough gas to cover the event costs, all the remaining gas should be consumed.

`CREATE*` and `*CALL` reserve 1/64th of the gas before the nested execution. In order to match the behavior of this charge with the pre-fork behavior of access lists: 

 * this minimum 1/64th gas reservation is checked **AFTER** charging the witness costs when performing a `CALL`, `CALLCODE`, `DELEGATECALL` or`STATICCALL`
 * this 1/64th of the gas is subtracted **BEFORE** charging the witness costs when performing a `CREATE` or `CREATE2`

### Block-level operations

None of:

* Precompile accounts, system contract accounts and slots of a system contract that are accessed during a system call,
* The coinbase account
* Withdrawal accounts

are warm at the start of a transaction.

### System contracts

When (and only when) calling a system contract either

 * _via a system call_ or
 * _to resolve a precompile/opcode_,

 the system contract's _code chunks_ and _account headers_ accesses should not appear in the witness as these should be known/cached in the clients. However any other accesses and all writes should appear in the witness.

Also corresponding witness costs need to be charged for _precompile/opcode resolution_ but are not charged in the _system call_.

### Account abstraction

TODO: complete spec update for 7702

## Rationale

### Gas reform

Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. `WITNESS_CHUNK_COST` is set to charge 6.25 gas per byte for chunks, and `WITNESS_BRANCH_COST` is set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.

The main differences from gas costs in Berlin are:

 * 200 gas charged per 31 byte chunk of code. This has been estimated to increase average gas usage by ~6-12% suggesting 10-20% gas usage increases at a 350 gas per chunk level).
 * Cost for accessing adjacent storage slots (`key1 // 256 == key2 // 256`) decreases from 2100 to 200 for all slots after the first in the group,
 * Cost for accessing storage slots 0…63 decreases from 2100 to 200, including the first storage slot. This is likely to significantly improve performance of many existing contracts, which use those storage slots for single persistent variables.

Gains from the latter two properties have not yet been analyzed, but are likely to significantly offset the losses from the first property. It’s likely that once compilers adapt to these rules, efficiency will increase further.

The precise specification of when access events take place, which makes up most of the complexity of the gas repricing, is necessary to clearly specify when data needs to be saved to the period 1 tree.

## Backwards Compatibility

This EIP requires a hard fork, since it modifies consensus rules.

The main backwards-compatibility-breaking changes is the gas costs for code chunk access making some applications less economically viable. It can be mitigated by increasing the gas limit at the same time as implementing this EIP, reducing the risk that applications will no longer work at all due to transaction gas usage rising above the block gas limit. 

## Security Considerations

This EIP will mean that certain operations, mostly reading and writing several elements in the same suffix tree, become cheaper. If clients retain the same database structure as they have now, this would result in a DOS vector.

So some adaptation of the database is required in order to make this work:

 * In all possible futures, it is important to logically separate the commitment scheme from data storage. In particular, no traversal of the commitment scheme tree should be necessary to find any given state element
 * In order to make accesses to the same stem cheap as required for this EIP, the best way is probably to store each stem in the same location in the database. Basically the 256 leaves of 32 bytes each would be stored in an 8kB BLOB. The overhead of reading/writing this BLOB is small because most of the cost of disk access is seeking and not the amount transferred.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
