---
eip: 4762
title: Statelessness gas cost changes
description: Changes the gas schedule to reflect the costs of creating a witness by requiring clients update their database layout to match.
author: Guillaume Ballet (@gballet), Vitalik Buterin (@vbuterin), Dankrad Feist (@dankrad), Ignacio Hagopian (@jsign), Tanishq Jasoria (@tanishqjasoria), Gajinder Singh (@g11tech)
discussions-to: https://ethereum-magicians.org/t/eip-4762-statelessness-gas-cost-changes/8714
status: Draft
type: Standards Track
category: Core
created: 2022-02-03
---
## Abstract

This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.

## Motivation

The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes client developers to migrate their database format ahead of the verkle fork.

## Specification

### Helper functions

```python
def get_storage_slot_tree_keys(storage_key: int) -> [int, int]:
    if storage_key < (CODE_OFFSET - HEADER_STORAGE_OFFSET):
        pos = HEADER_STORAGE_OFFSET + storage_key
    else:
        pos = MAIN_STORAGE_OFFSET + storage_key
    return (
        pos // 256,
        pos % 256
    )
```

### Access events

Whenever the state is read or written to, one or more of the access events of the form`(address, sub_key, leaf_key)` take place, determining what data is being accessed. We define access events as follows:

```python3
def add_access_event(address: bytes20, sub_key: bytes31, leaf_key: byte, is_write: bool):
  event = (address, sub_key_leaf_key)
  if is_write:
    tx.access_events.writes.append(event)
  else:
    tx.acess_events.reads.append(event)

def add_write_access_events(address: bytes20, sub_key: bytes31, leaf_key: byte):
  add_read_acess_events(address, sub_key, leaf_key)
  add_access_event(address, sub_key, leaf_key, True)
  
def add_read_access_events(address: bytes20, sub_key: bytes31, leaf_key: byte):
  add_access_event(address, sub_key, leaf_key, False)
```

The consequence of this model, is that it created group-locality in the state, with each "group" containing 256 contiguous leaves.

An event will be triggered:

 * Every time a group is accessed
 * Every time a single leaf is accessed

The model makes a distinction between read and write events. As we will see later, gas costs are associated to these events.

#### Access events for account headers

```python3
# Emit all access events given an instruction. It is meant to be called before
# the gas charging method for a given instruction is called, as these events
# are subsequently used to process witness-related gas costs.
def emit_access_events(opcode: int, stack: Stack, contract: Contract, new_contract: Optional[Contract]):
  match opcode:
    case OP_CALL | OP_DELEGATECALL | OP_STATICCALL | OP_CALLCODE | OP_SELFDESTRUCT:
      address = stack.peek(1)

      if value_bearing and op == OP_CALL:
        add_write_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)
        add_write_access_event(address, 0, BASIC_DATA_LEAF_KEY)
      else:
        if is_precompile(address) or is_system_contract(address):
          # XXX charge warm costs
        else:
          add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)
       
      add_read_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)

    case OP_EXTCODECOPY | OP_EXTCODESIZE:
      address = stack.peek(0)
      add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)

    case OP_BALANCE:
      address = stack.peek(0)
      add_read_access_event(address, 0, BASIC_DATA_LEAF_KEY)

    case OP_CODECOPY:
       if not contract.is_deployment:
         add_read_access_event(contract.address, 0, BASIC_DATA_LEAF_KEY)

    case OP_EXTCODEHASH:
      address = stack.peek(0)
      if not (is_precompile(address) or is_system_contract(address)):
        add_read_access_event(address, 0, CODEHASH_LEAF_KEY)

    case OP_SLOAD | OP_SSTORE:
      address = stack.peek(0)
      key = stack.peek(1)
      read_access_for_storage(address, key)

    case OP_CREATE | OP_CREATE2:
      # This is to be called before the operation is created,
      # XXX it makes no sense to do this here, it should be
      # specified, in a way that reflects that this is created
      # when either a tx creates a contract by setting to:null
      # or when executing the CREATEn opcode. To be clear, this
      # is incorrect because this is not part of the CREATE
      # instruction's gas function at all, but of its execution.
      if not (is_precompile(address) or not is_system_contract(address)):
        add_read_access_event(new_contract.address, 0, BASIC_DATA_LEAF_KEY)
        add_read_access_event(new_contract.address, 0, CODEHASH_LEAF_KEY)

# This function is to be called right when it is known that the
# account will be created.
def emit_accesses_for_contract_creation_init(target_address):
  add_write_access_event(address, 0, BASIC_DATA_LEAF_KEY)
  add_write_access_event(address, 0, CODEHASH_LEAF_KEY)
  
def read_access_for_storage(contract_address: bytes20, storage_key: byte32):
  index, suffix = get_storage_slot_key(contract_address, storage_key)
  add_read_access_event(contract_address, index, suffix)
```

When a contract is created, process these access events:

```
(contract_address, 0, BASIC_DATA_LEAF_KEY)
(contract_address, 0, CODEHASH_LEAF_KEY)
```

##### Access events for delegation

When `contract_address` is that of a delegating EoA, process the following events:

 - For an `EXTCODEHASH`:

```
(delegated_address, 0, CODEHASH_LEAF_KEY)
```

 - For an `EXTCODESIZE`, or any other `*CALL`, `CALLCODE`:

```
(delegated_address, 0, BASIC_DATA_LEAF_KEY)
```

#### Access events for code

```python3
def interpreter_loop(code: bytes, contract_address: bytes20):
  pc = 0

  # ...

  while True:
    if pc < len(code):
      code_read_access_event(pc, code, contract_address)
      # ... rest of the interpreter loop

def code_read_access_event(pc: int, code: bytes, contract_address: Address):
  chunk = pc // CHUNK_SIZE
  # XXX this is what we do, but this isn't what is in the spec
  if chunk > (len(code)+CHUNK_SIZE-1)/CHUNK_SIZE:
    return # No access events for code beyond the last code chunk

  opcode = OP_STOP # pad chunk with 0s
  # if the code walks beyond the code size, it is not considered to be accessed.
  # XXX I don't think that this is true on mainnet, even before the atomic stuff!
  if pc < len(code):
    opcode = code[pc]

  add_read_access_event(contract_addresss, (chunk+128) // 256, (chunk + 128) % 256)

  # add access events for immediates, if the instruction has them
  match opcode:
    case OP_JUMP:
      dest = stack.peek(0)
      if dest < len(code):
        # The destination of a `JUMP` is considered to be accessed, even if the destination is not a jumpdest or is inside pushdata
        add_read_access_event(dest)

    case OP_JUMPI:
      dest = stack.peek(0)
      cond = stack.peek(1)
      # if the code walks beyond the code size, it is not considered to be accessed.
      if dest < len(code):
        dest_chunk = dest // CHUNK_SIZE
        # The destination of a positively evaluated `JUMPI` is considered to be accessed, even if the destination is not a jumpdest or is inside pushdata
        # The destination of a `JUMPI` is not considered to be accessed if the jump conditional is `false`
        if op == OP_JUMP or cond:
          add_read_access_event(contract_address, (dest_chunk+128) // 256, (dest_chunk+128) % 256)

    case OP_PUSH1 | OP_PUSH2 | ... | OP_PUSH32:
      nbytes = opcode - OP_PUSH0 # determine the number of extra bytes to touch
      for i in range(nbytes):
        immediate_chunk = (pc+i) // CHUNK_SIZE
        if immediate_chunk <= (len(code)+CHUNK_SIZE-1) // CHUNK_SIZE:
          add_read_access_event(contract_address, (immediate_chunk+128) // 256, (immediate_chunk + 128) % 256)

    case OP_CODECOPY | OP_EXTCODECOPY:
      addr = contract_address
      size = 0
      offset = i0
      if opcode == OP_EXTCODECOPY:
        addr = stack.peek(0)
        offset = stack.peek(2)
        size = stack.peek(3)
      else:
        offset = stack.peek(1)
        size = stack.peek(2)

      for i in range(size):
        copied_byte_chunk = (offset+i) // CHUNK_SIZE 
        if copied_byte_chunk <= (len(code)+CHUNK_SIZE-1) // CHUNK_SIZE:
          add_read_access_event(contract_address, (copied_byte_chunk+128) // 256, (copied_byte_chunk + 128) % 256)

    case OP_CODESIZE | OP_EXTCODESIZE | OP_EXTCODEHAS:
      # None of these operations access any chunk      
```

 * At each step of EVM execution, if and only if `PC < len(code)`, chunk `PC // CHUNK_SIZE` (where `PC` is the current program counter) of the callee is accessed. In particular, note the following corner cases:
    # XXX ©a doit changer avec l'atomicité -> voir si c'est le cas
     * The destination of a jump is not considered to be accessed if the execution gets to the jump opcode but does not have enough gas to pay for the gas cost of executing the `JUMP` opcode (including chunk access cost if the `JUMP` is the first opcode in a not-yet-accessed chunk)
     * The destination of a jump is not considered to be accessed if it is beyond the code (`destination >= len(code)`)
     * If code stops execution by walking past the end of the code, `PC = len(code)` is not considered to be accessed
 * If the current step of EVM execution is a `PUSH{n}`, all chunks `(PC // CHUNK_SIZE) <= chunk_index <= ((PC + n) // CHUNK_SIZE)` of the callee are accessed.
 * If a nonzero-read-size `CODECOPY` or `EXTCODECOPY` read bytes `x...y` inclusive, all chunks `(x // CHUNK_SIZE) <= chunk_index <= (min(y, code_size - 1) // CHUNK_SIZE)` of the accessed contract are accessed.
     * Example 1: for a `CODECOPY` with start position 100, read size 50, `code_size = 200`, `x = 100` and `y = 149`
     * Example 2: for a `CODECOPY` with start position 600, read size 0, no chunks are accessed
     * Example 3: for a `CODECOPY` with start position 1500, read size 2000, `code_size = 3100`, `x = 1500` and `y = 3099`
 * `CODESIZE`, `EXTCODESIZE` and `EXTCODEHASH` do NOT access any chunks.

When a contract is created, access chunks `0 ... (len(code)+30)//31`:

```python3
def contract_creation_add_chunks(address: Address, code: bytes):
  for i in range(code):
    code_byte_chunk = (offset+i) // CHUNK_SIZE 
    if code_byte_chunk <= (len(code)+CHUNK_SIZE-1) // CHUNK_SIZE:
      add_write_access_event(contract_address, (code_byte_chunk+128) // 256, (code_byte_chunk + 128) % 256)
```

### Write Events

We define **write events** as follows. Note that when a write takes place, an access event also takes place (so the definition below should be a subset of the definition of access events). A write event is of the form `(address, sub_key, leaf_key)`, determining what data is being written to.

#### Write events for account headers

When a nonzero-balance-sending `CALL`, `CALLCODE` or `SELFDESTRUCT` with a given sender and recipient takes place, process these write events:

```
(caller, 0, BASIC_DATA_LEAF_KEY)
(callee, 0, BASIC_DATA_LEAF_KEY)
```

if no account exists at `callee_address`, also process:

```
(callee, 0, CODEHASH_LEAF_KEY)
```

When a contract creation is initialized, process these write events:

```
(contract_address, 0, BASIC_DATA_LEAF_KEY)
(contract_address, 0, CODEHASH_LEAF_KEY)
```

#### Write events for storage

`SSTORE` opcodes with a given `address` and `key` process a write event of the form

```
(address, tree_key, sub_key)
```

Where `tree_key` and `sub_key` are computed as `tree_key, sub_key = get_storage_slot_tree_keys(address, key)`

#### Write events for code

When a contract is created, process the write events:

```python
(
    address,
    (CODE_OFFSET + i) // VERKLE_NODE_WIDTH,
    (CODE_OFFSET + i) % VERKLE_NODE_WIDTH
)
```

For `i` in `0 ... (len(code)+30)//31`.

Note: since no access list existed for code up until this EIP, note that no warm costs are charged for code accesses.

### Transaction

#### Access events

For a transaction, make these access events:

```
(tx.origin, 0, BASIC_DATA_LEAF_KEY)
(tx.origin, 0, CODEHASH_LEAF_KEY)
(tx.target, 0, BASIC_DATA_LEAF_KEY)
(tx.target, 0, CODEHASH_LEAF_KEY)
```

#### Write events

```
(tx.origin, 0, BASIC_DATA_LEAF_KEY)
```

If `value` is non-zero:

```
(tx.target, 0, BASIC_DATA_LEAF_KEY)
```

### Witness gas costs

Remove the following gas costs:

 * Increased gas cost of `CALL` if it is nonzero-value-sending
 * [EIP-2200](./eip-2200.md) `SSTORE` gas costs except for the `SLOAD_GAS`
 * 200 per byte contract code cost
 * All `CALLCODE` costs related to nonzero-value-sending

Reduce gas cost:

 * `CREATE`/`CREATE2` to 1000

| Constant              | Value |
| --------------------- | ----- |
| `WITNESS_BRANCH_COST` | 1900  |
| `WITNESS_CHUNK_COST`  | 200   |
| `SUBTREE_EDIT_COST`   | 3000  |
| `CHUNK_EDIT_COST`     | 500   |
| `CHUNK_FILL_COST`     | 6200  |

When executing a transaction, maintain four sets:

 * `accessed_subtrees: Set[Tuple[address, int]]`
 * `accessed_leaves: Set[Tuple[address, int, int]]`
 * `edited_subtrees: Set[Tuple[address, int]]`
 * `edited_leaves: Set[Tuple[address, int, int]]`


When an **access** event of `(address, sub_key, leaf_key)` occurs, perform the following checks:

 * Perform the following steps unless event is a _Transaction access event_;
 * If `(address, sub_key)` is not in `accessed_subtrees`, charge `WITNESS_BRANCH_COST` gas and add that tuple to `accessed_subtrees`.
 * If `leaf_key` is not `None` and `(address, sub_key, leaf_key)` is not in `accessed_leaves`, charge `WITNESS_CHUNK_COST` gas and add it to `accessed_leaves`

When a **write** event of `(address, sub_key, leaf_key)` occurs, perform the following checks:

 * If event is _Transaction write event_, skip the following steps.
 * If `(address, sub_key)` is not in `edited_subtrees`, charge `SUBTREE_EDIT_COST` gas and add that tuple to `edited_subtrees`.
 * If `leaf_key` is not `None` and `(address, sub_key, leaf_key)` is not in `edited_leaves`, charge `CHUNK_EDIT_COST` gas and add it to `edited_leaves`
     * Additionally, if there was no value stored at `(address, sub_key, leaf_key)` (ie. the state held `None` at that position), charge `CHUNK_FILL_COST`

Note that tree keys can no longer be emptied: only the values `0...2**256-1` can be written to a tree key, and 0 is distinct from `None`. Once a tree key is changed from `None` to not-`None`, it can never go back to `None`.

Note that values should only be added to the witness if there is sufficient gas to cover their associated event costs. If there is not enough gas to cover the event costs, all the remaining gas should be consumed.

`CREATE*` and `*CALL` reserve 1/64th of the gas before the nested execution. In order to match the behavior of this charge with the pre-fork behavior of access lists: 

 * this minimum 1/64th gas reservation is checked **AFTER** charging the witness costs when performing a `CALL`, `CALLCODE`, `DELEGATECALL` or`STATICCALL`
 * this 1/64th of the gas is subtracted **BEFORE** charging the witness costs when performing a `CREATE` or `CREATE2`

### Block-level operations

None of:

* Precompile accounts, system contract accounts and slots of a system contract that are accessed during a system call,
* The coinbase account
* Withdrawal accounts

are warm at the start of a transaction.

### System contracts

When (and only when) calling a system contract either

 * _via a system call_ or
 * _to resolve a precompile/opcode_,

 the system contract's _code chunks_ and _account headers_ accesses should not appear in the witness as these should be known/cached in the clients. However any other accesses and all writes should appear in the witness.

Also corresponding witness costs need to be charged for _precompile/opcode resolution_ but are not charged in the _system call_.

### Account abstraction

TODO : still waiting on a final decision between 7702 and 3074

## Rationale

### Gas reform

Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. `WITNESS_CHUNK_COST` is set to charge 6.25 gas per byte for chunks, and `WITNESS_BRANCH_COST` is set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.

The main differences from gas costs in Berlin are:

 * 200 gas charged per 31 byte chunk of code. This has been estimated to increase average gas usage by ~6-12% suggesting 10-20% gas usage increases at a 350 gas per chunk level).
 * Cost for accessing adjacent storage slots (`key1 // 256 == key2 // 256`) decreases from 2100 to 200 for all slots after the first in the group,
 * Cost for accessing storage slots 0…63 decreases from 2100 to 200, including the first storage slot. This is likely to significantly improve performance of many existing contracts, which use those storage slots for single persistent variables.

Gains from the latter two properties have not yet been analyzed, but are likely to significantly offset the losses from the first property. It’s likely that once compilers adapt to these rules, efficiency will increase further.

The precise specification of when access events take place, which makes up most of the complexity of the gas repricing, is necessary to clearly specify when data needs to be saved to the period 1 tree.

## Backwards Compatibility

This EIP requires a hard fork, since it modifies consensus rules.

The main backwards-compatibility-breaking changes is the gas costs for code chunk access making some applications less economically viable. It can be mitigated by increasing the gas limit at the same time as implementing this EIP, reducing the risk that applications will no longer work at all due to transaction gas usage rising above the block gas limit. 

## Security Considerations

This EIP will mean that certain operations, mostly reading and writing several elements in the same suffix tree, become cheaper. If clients retain the same database structure as they have now, this would result in a DOS vector.

So some adaptation of the database is required in order to make this work:

 * In all possible futures, it is important to logically separate the commitment scheme from data storage. In particular, no traversal of the commitment scheme tree should be necessary to find any given state element
 * In order to make accesses to the same stem cheap as required for this EIP, the best way is probably to store each stem in the same location in the database. Basically the 256 leaves of 32 bytes each would be stored in an 8kB BLOB. The overhead of reading/writing this BLOB is small because most of the cost of disk access is seeking and not the amount transferred.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
