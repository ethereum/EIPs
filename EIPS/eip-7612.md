---
eip: 7612
title: Verkle state transition via an overlay tree
description: Describes the use of an overlay tree to use the verkle tree structure, while leaving the historical state untouched.
author: Guillaume Ballet (@gballet), Ansgar Dietrichs (@adietrichs), Ignacio Hagopian (@jsign), Gottfried Herold (@GottfriedHerold), Jamie Lokier (@jlokier), Tanishq Jasoria (@tanishqjasoria), Parithosh Jayanthi (@parithosh), Gabriel Rocheleau (@gabrocheleau), Karim Taam (@matkt)
discussions-to: https://ethereum-magicians.org/t/ethereum-state-trie-format-change-using-an-overlay/4165
status: Draft
type: Standards Track
category: Core
created: 2024-01-25
requires: 4762, 6800, 7545
---

## Abstract

This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT “laid over” the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.

## Motivation

The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams to undergo a long process of refactoring their code to handle this conversion.

The bigger the state, the longer any conversion process will take. This has an impact both while the conversion is happening, as well as when full-syncing the chain if the conversion is part of consensus. Fullsync is used extensively by core dev teams to test the performance of new code. A conversion longer than a month will impact the release schedule of client teams who typically release at this rate. Nodes that cannot follow the conversion will need to wait longer to rejoin. The conversion will also make reorgs slower, so reducing its duration is desirable.

This current proposal suggests to stop the MPT state growth in its tracks by activating a new “overlay” VKT, that all new state updates are written to. The "base" MPT is frozen in place, until all execution clients are ready to perform the full transition. Data is read first from the overlay tree, and if not found there, from the MPT.

Whenever the block that freeze the MPT is finalized, internal node data can be deleted, in order to free up disk space.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Constants

| Parameter   | value | Description                                  |
| ----------- | ----- | -------------------------------------------- |
| `FORK_TIME` | `TBD` | Time at which the overlay tree is activated. 

### Helper functions

```python3
# Determine if `block` is the fork activation block
def is_fork_block(block):
    return block.parent.timestamp < FORK_TIME && block.timestamp >= FORK_TIME
    
# Write an account in the verkle tree
def verkle_set_account(tree: VerkleTree, key: Bytes32, account: Optional[Account]):
    if account is not None:
        basicdata = bytes(0) # Version
        basicdata += bytes(4) # Reserved
        basicdata += len(account.code).to_bytes(3, 'big')
        basicdata += account.nonce.to_bytes(8, 'big')
        basicdata += account.balance.to_bytes(16, 'big')
        tree.set(key, basicdata)
        ckkey = key
        ckkey[31] = CODEHASH_LEAF_KEY
        tree.set(ckkey, account.code_hash)

# Reads an account from the verkle tree
def verkle_get_account(tree: VerkleTree, key: Bytes32) -> Optional[Account]:
    basicdata_leaf = tree.get(key)
    if basicdata_leaf is not None:
        cs = int.from_bytes(basicdata_leaf[5:8], 'big')
        nonce = int.from_bytes(basicdata_leaf[8:16], 'big')
        balance = int.from_bytes(basicdata_leaf[16:32], 'big')
        ckkey = key
        ckkey[31] = CODEHASH_LEAF_KEY
        ck = tree.get(ckkey)
        cskey = key
        cskey[31] = CODE_SIZE_LEAF_KEY
        cs = tree.get(cskey)
        account = Account(0, balance, nonce, ck, cs)

    return account
```

### Changes to the execution spec

In the execution spec, modify the `State` class as such:

```python3
@dataclass
class State:
    """
    Contains all information that is preserved between transactions.
    """

    _main_trie: Trie[Address, Optional[Account]] = field(
        default_factory=lambda: Trie(secured=True, default=None)
    )
    _storage_tries: Dict[Address, Trie[Bytes, U256]] = field(
        default_factory=dict
    )
    _snapshots: List[
        Tuple[
            Trie[Address, Optional[Account]], Dict[Address, Trie[Bytes, U256]]
        ]
    ] = field(default_factory=list)
    _created_accounts: Set[Address] = field(default_factory=set)

    # Added in this EIP
    _overlay_tree: VerkleTree[Address, Bytes32]
```

And the state access functions are modified as such:

```python3
def get_account_optional(state: State, address: Address) -> Optional[Account]:
    account = verkle_get_account(state._overlay_tree, get_tree_key_for_version(addr))
    if account is not None:
        return account
    
    return trie_get(state._main_trie, address)

def set_account(state: State, address: Address, account: Optional[Account]) -> None:
    verkle_set_account(state._overlay_tree, get_tree_key_for_nonce(addr), account)

def get_storage(state: State, address: Address, key: Bytes) -> U256:
    value = state._overlay_tree.get(get_tree_key_for_storage_slot(addr, slot))
    if value is not None:
        return value
        
    trie = state._storage_tries.get(address)
    if trie is None:
        return U256(0)

    value = trie_get(trie, key)

    assert isinstance(value, U256)
    return value

def set_storage(
    state: State, address: Address, key: Bytes, value: U256
) -> None:
    state._overlay_tree.set(get_tree_key_for_storage_slot(addr, slot), value)
```

Add the following function which is used when storing a contract in the tree:

```python3
def state_set_codechunk(state: State, addr: Address, chunk_num: int, chunk: Bytes):
    state._overlay_tree.set(get_tree_key_for_code_chunk(addr, chunk_num), chunk)
```

### Changes to the block header

At `FORK_TIME` the block header state root is changed from the MPT root to the VKT root.

## Rationale

This approach doesn't convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same time as other, simpler EIPs. It also requires no change at the consensus layer.

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

The following test cases should be implemented to verify the correct functionality of the overlay tree:

### Test Case 1: Reading from MPT when data is not in VKT

1. Setup: Initialize a state with MPT containing account A with balance 100 ETH
2. Action: Read account A's balance after fork activation
3. Expected: Balance should be 100 ETH, read from MPT

### Test Case 2: Writing to VKT and reading back

1. Setup: Initialize a state with MPT containing account A with balance 100 ETH
2. Action: After fork activation, update account A's balance to 200 ETH
3. Action: Read account A's balance
4. Expected: Balance should be 200 ETH, read from VKT

### Test Case 3: Writing new account to VKT

1. Setup: Initialize a state with no account B in MPT
2. Action: After fork activation, create account B with balance 50 ETH
3. Action: Read account B's balance
4. Expected: Balance should be 50 ETH, read from VKT

### Test Case 4: Storage slot operations

1. Setup: Initialize a state with account C having storage slot 0x1 = 0x5 in MPT
2. Action: After fork activation, update storage slot 0x1 = 0x10
3. Action: Read storage slot 0x1
4. Expected: Value should be 0x10, read from VKT
5. Action: Read storage slot 0x2 (not set in either tree)
6. Expected: Value should be 0x0

### Test Case 5: Code storage and retrieval

1. Setup: Initialize a state with account D having code "0x60806040..." in MPT
2. Action: After fork activation, deploy new contract E with code "0x608060..."
3. Action: Read code from contract E
4. Expected: Code should be correctly chunked and retrievable from VKT

### Test Case 6: Block header state root

1. Setup: Initialize a state before fork activation
2. Action: Create block at timestamp < FORK_TIME
3. Expected: Block header state root should be MPT root
4. Action: Create block at timestamp >= FORK_TIME
5. Expected: Block header state root should be VKT root

### Test Case 7: Reorgs across fork boundary

1. Setup: Initialize a state before fork activation
2. Action: Create blocks A1, A2, A3 with timestamps < FORK_TIME (MPT blocks)
3. Action: Create blocks A4, A5 with timestamps >= FORK_TIME (VKT blocks)
4. Action: Reorg by creating competing blocks B3, B4 where:
   - B3 has timestamp < FORK_TIME (MPT block)
   - B4 has timestamp >= FORK_TIME (VKT block)
5. Expected: After reorg, state should correctly reflect:
   - Blocks A1, A2 remain in the canonical chain
   - Blocks A3, A4, A5 are removed from the canonical chain
   - Blocks B3, B4 are added to the canonical chain
   - All state transitions are correctly applied/reverted
6. Action: Create additional blocks B5, B6 with timestamps >= FORK_TIME (VKT blocks)
7. Expected: State continues to be correctly maintained in the VKT

### Test Case 8: Complex reorgs with multiple tree switches

1. Setup: Initialize a state before fork activation
2. Action: Create blocks A1, A2 with timestamps < FORK_TIME (MPT blocks)
3. Action: Create blocks A3, A4 with timestamps >= FORK_TIME (VKT blocks)
4. Action: Perform a deep reorg with competing chain B:
   - B1, B2 with timestamps < FORK_TIME (MPT blocks)
   - B3 with timestamp >= FORK_TIME (VKT block)
5. Expected: System correctly switches from chain A to chain B, with proper state transitions
6. Action: Perform another reorg back to an extended chain A:
   - Original A1, A2 (MPT blocks)
   - New A3', A4', A5' with timestamps < FORK_TIME (MPT blocks)
   - A6' with timestamp >= FORK_TIME (VKT block)
7. Expected: System correctly:
   - Reverts all changes from chain B
   - Applies all changes from the extended chain A
   - Maintains correct state roots (MPT for blocks before FORK_TIME, VKT after)
8. Action: Create additional blocks A7', A8' with timestamps >= FORK_TIME (VKT blocks)
9. Expected: State continues to be correctly maintained in the VKT

## Reference Implementation

 * `transition-post-genesis` branch in `github.com/gballet/go-ethereum` implements this when setting `--override.overlay-stride=0` on the command line.

## Security Considerations

The overlay tree approach introduces several security considerations that implementers should be aware of:

1. **Data Consistency**: Implementations must ensure that data is read correctly from both trees, with the overlay tree taking precedence. Inconsistencies could lead to incorrect state transitions.

2. **Root Calculation**: The calculation of the VKT root must be deterministic and consistent across all clients. Any discrepancy could lead to consensus failures.

3. **Transition Period**: During the transition period when both trees are active, clients must handle edge cases correctly, such as:
   - Reorgs that cross the fork boundary
   - Syncing nodes that start from pre-fork blocks
   - Handling of historical state queries

4. **Resource Management**: The overlay approach temporarily increases storage requirements as both trees must be maintained. Clients should optimize storage to prevent excessive resource consumption.

5. **Witness Generation**: For stateless clients, witness generation must account for data from both trees, which increases complexity.

6. **Migration Coordination**: The eventual migration of data from MPT to VKT (in a subsequent EIP) must be carefully coordinated to prevent state inconsistencies.

Further security analysis will be conducted as implementation progresses and feedback is gathered from client teams.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
