---
eip: 8131
title: Token Gas Payments for EIP-8130
description: Enable gas payments using fungible tokens for EIP-8130 AA transactions via the extensions field
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 8130
---

## Abstract

This proposal extends [EIP-8130](./eip-8130.md) to enable gas payments using ERC-20 tokens. It defines the token payment extension format for EIP-8130's `extensions` field, a Token Payment Registry for allowlisting tokens, permissionless payer configurations with oracle-based pricing, and an optional native payer system contract for chain-operated gas abstraction.

## Motivation

EIP-8130 provides account abstraction with ETH-based gas sponsorship. However, many users hold tokens (USDC, USDT, etc.) but no ETH, creating friction for onboarding and transaction submission. Token gas payments enable:

- **Gasless UX**: Users transact with tokens they already hold
- **Stablecoin payments**: Predictable transaction costs in USD-denominated tokens
- **Competitive market**: Permissionless payers compete on exchange rates
- **Chain flexibility**: Native payer option for chain-operated gas abstraction (ie. Native AMM)
- **Zero token changes**: Works with existing ERC-20 tokens using standard transfer logic—no upgrades or storage migrations required

This proposal uses EIP-8130's `extensions` field to add token payment capability without modifying the base transaction type.

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `TOKEN_PAYMENT_EXT_TYPE` | `0x01` | Extension type identifier for token payments |
| `TOKEN_PAYMENT_REGISTRY` | TBD | Token Payment Registry system contract address |
| `TOKEN_TRANSFER_COST` | 500 (warm) / 5000 (cold) | Per SSTORE costs for balance slot writes |
| `NATIVE_PAYER` | TBD | (Optional) Native gas AMM payer system contract address |

### Extension Format

Token payments use the EIP-8130 `extensions` field with byte concatenation encoding:

```
extensions = TOKEN_PAYMENT_EXT_TYPE || token_address || max_amount
           = 0x01 || address(20 bytes) || uint256(32 bytes)
           = 53 bytes total
```

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `TOKEN_PAYMENT_EXT_TYPE` | uint8 | 1 byte | Extension type identifier (`0x01`) |
| `token_address` | address | 20 bytes | ERC-20 token contract address |
| `max_amount` | uint256 | 32 bytes | Maximum token amount sender will pay |

When `extensions` contains a valid token payment, the transaction uses token-based gas payment instead of ETH.

### Token Payment Registry

Tokens must be registered in the Token Payment Registry system contract at `TOKEN_PAYMENT_REGISTRY` before use for gas payment. Similar to EIP-8130's account configuration precompile, this is a protocol-level system contract with persistent storage. The registry stores token metadata required for protocol-level balance reads and transfers.

#### Token Configuration Storage

All storage keys use byte concatenation (`||` denotes concatenation of raw bytes, addresses as 20 bytes, strings as UTF-8):

```
Base slot: keccak256(token_address || TOKEN_PAYMENT_REGISTRY || "config")

- base_slot + 0: balance_slot_index (uint256)
- base_slot + 1: packed config (uint256)
    - byte 0: token_decimals (uint8)
    - byte 1: active (bool)
    - byte 2: highBitBlocklist (bool)
    - bytes 3-31: reserved
```

| Field | Description |
|-------|-------------|
| `balance_slot_index` | Storage slot index for token's `balanceOf` mapping. User balance at: `keccak256(user_address || balance_slot_index)` |
| `token_decimals` | Token decimal places (e.g., 6 for USDC, 18 for most tokens) |
| `active` | Whether token is currently accepted for gas payments |
| `highBitBlocklist` | If true, bit 255 of balance = 1 indicates account is blocklisted |

#### Blocklist Storage

When `highBitBlocklist` is false, blocklist status is stored separately:

```
Blocklist slot: keccak256(token_address || account_address || TOKEN_PAYMENT_REGISTRY || "blocklist")
Value: bool
```

When `highBitBlocklist` is true, bit 255 of the token's balance slot indicates blocklist status—no separate storage read required. This optimization supports tokens like USDC that encode blocklist status in the balance.

### Payer Modes with Token Payments

This extension adds token payment capability to EIP-8130's payer modes:

| Mode | `payer_auth` | `extensions` | Gas Payer | Token Recipient |
|------|--------------|--------------|-----------|-----------------|
| Sender pays ETH | Empty | `[]` | sender | N/A |
| Sponsor pays ETH | 65-byte signature | `[]` | Payer (ecrecover) | N/A |
| Sponsor receives token | 65-byte signature | `[0x01, token, max]` | Payer (ecrecover) | Payer |
| Permissionless sponsor | 20-byte address | `[0x01, token, max]` | Payer address | Payer |
| Native AMM | `NATIVE_PAYER` or empty | `[0x01, token, max]` | `NATIVE_PAYER` | `NATIVE_PAYER` |

### Permissionless Payer Configuration

Permissionless payers register onchain to accept token payments without signing each transaction. Each payer specifies their own oracle per token, enabling a competitive gas market.

#### Storage

```
Base slot: keccak256(payer_address || TOKEN_PAYMENT_REGISTRY || "payer")

- base_slot + 0: active (bool)

Per-token config:
Token slot: keccak256(token_address || payer_address || TOKEN_PAYMENT_REGISTRY || "payer_token")

- token_slot + 0: accepted (bool)
- token_slot + 1: oracle_address (address)
- token_slot + 2: oracle_slot (bytes32)
- token_slot + 3: oracle_decimals (uint8)
```

#### Oracle-Based Pricing

Each payer configures an oracle for each token they accept. The oracle value represents **tokens per ETH**, scaled by `10^oracle_decimals`:

```
oracle_value = SLOAD(payer.oracle_address, payer.oracle_slot)
exchange_rate = oracle_value * 10^token_decimals / 10^oracle_decimals
token_cost = ceil(gas_cost_wei * exchange_rate / 10^18)
```

**Example**: USDC payment for 0.001 ETH gas cost (1e15 wei), ETH at $2000:
- `oracle_value` = 2000 × 10^8 (2000 USDC/ETH with 8 decimals, Chainlink standard)
- `exchange_rate` = 2000e8 × 10^6 / 10^8 = 2000e6
- `token_cost` = 1e15 × 2000e6 / 1e18 = 2e6 = 2 USDC 

If oracle returns 0, `token_cost` is 0 (payer assumes this risk).

#### Validation

Protocol verifies permissionless payers by checking:

- Payer config is active
- Payer accepts the specified token with valid oracle config
- Payer has sufficient ETH for gas

Payers can integrate any offchain logic to manage their position—sweeping accumulated tokens to ETH via DeFi protocols periodically.

### Oracle Maintenance

Oracle maintenance is external to this specification. Payers are responsible for maintaining accurate exchange rates. Common approaches:

| Oracle Type | Description |
|-------------|-------------|
| **Chainlink feeds** | Decentralized price updates via established infrastructure |
| **Keeper-updated** | Payer runs offchain updater with top-of-block updates |
| **DeFi-integrated** | Permissionless contract queries configured DEX pool for current price |

The protocol reads `oracle_slot` at validation time. Stale prices are the payer's risk—they may overpay for gas or have transactions rejected via sender's `max_amount`. A recommended pattern is a non-upgradable oracle contract with a permissionless `update(token)` method that queries configured DEX pools.

### Native Payer

The optional `NATIVE_PAYER` system contract provides chain-operated gas abstraction.

#### Behavior

- Uses the Token Payment Registry for token allowlisting and metadata
- Chain operators define pricing mechanism and supported tokens (intentionally unspecified—enables AMMs, fixed rates, or custom curves)
- Can be referenced explicitly (20-byte address in `payer_auth`) or implicitly (empty `payer_auth` with token payment extension)

### Token Transfer Flow

When the token payment extension is present:

1. Read raw balance from token's `balance_slot_index` for sender
2. Verify sender is not blocklisted (via high bit or blocklist storage)
3. Determine `token_cost`:
   - **Permissioned payer** (65-byte signature): `token_cost = max_amount × (gas_used / gas_limit)` — payer signed agreeing to max price, actual cost scales with gas used
   - **Permissionless payer** (20-byte address): read exchange rate from payer's oracle config, compute `token_cost` based on actual `gas_used`, validate `token_cost <= max_amount`
   - **Native payer**: compute from `NATIVE_PAYER` pricing based on actual `gas_used`, validate `token_cost <= max_amount`
4. Validate `balance >= token_cost`
5. Update balances: sender decreases, payer increases
6. Emit `Transfer(from, payer, token_cost)` (implementation-defined)

Token transfers occur outside EVM execution. For permissioned payers, the initial transfer uses `max_amount` at transaction start; any refund based on actual gas usage occurs post-execution.

### Intrinsic Gas

When token payment extension is present, add to EIP-8130 intrinsic gas:

```
intrinsic_gas = EIP8130_intrinsic_gas + TOKEN_TRANSFER_COST
```

### Validation Flow Updates

Extend EIP-8130 mempool acceptance:

1. (EIP-8130 steps 1-3)
2. If `extensions` contains token payment (`0x01` prefix):
   - Verify token is registered and active in Token Payment Registry
   - Verify sender is not blocklisted for this token
   - Verify sender has sufficient token balance
   - Resolve payer:
     - 65-byte `payer_auth`: permissioned, `token_cost = max_amount`
     - 20-byte `payer_auth`: verify permissionless payer accepts token, has valid oracle, sufficient ETH
     - Empty `payer_auth`: use `NATIVE_PAYER`
   - Verify `token_cost <= max_amount`
3. (EIP-8130 steps 4-6)

### Block Execution Updates

Extend EIP-8130 block execution:

1. **Token transfer** (if token payment extension present)
2. ETH gas deduction from payer
3. Process authorization_list (EIP-7702)
4. Account initialization (if applicable)
5. Deliver calldata to sender via self-call

### Transaction Context Extension

Extend EIP-8130's `IAccountConfig` with:

```solidity
// Transaction context (only valid during AA transaction execution)
function getGasPaymentInfo() external view returns (address token, uint256 amount);
```

Returns the token address and amount transferred for gas payment. Returns `(address(0), 0)` for ETH-only payments.

## Rationale

### Why Permissionless Payers?

Permissionless payers create a competitive market for gas payment services:

1. **No gatekeeping**: Anyone can become a payer by registering
2. **Price competition**: Payers compete on exchange rates
3. **Decentralization**: No single entity controls gas payment pricing
4. **Innovation**: Payers can experiment with pricing strategies

### Why Per-Payer Oracles?

Per-payer oracles rather than a global protocol oracle:

1. **Market competition**: Payers compete on pricing—better oracles and tighter margins attract more transactions
2. **No governance**: Avoids protocol-level debates about which oracle is canonical
3. **Risk isolation**: A bad oracle only affects users of that payer
4. **Flexibility**: Payers can use Chainlink, custom feeds, or promotional rates
5. **Wallet-layer curation**: Discovery of reputable payers is handled by wallets, not protocol

The `max_amount` field provides hard user protection—transactions fail if computed cost exceeds the user-specified limit.

### Why Direct Storage Reads?

Reading token balances directly from storage slots rather than calling ERC-20 methods:

1. **No token upgrades**: Existing tokens with standard `mapping(address => uint256)` balance storage work without modification—just register the balance slot index
2. **No storage migrations**: Tokens don't need to move data or conform to new interfaces
3. **Atomic execution**: Balance reads and transfers happen at protocol level, before EVM execution begins
4. **Extensible**: The same approach can support other asset types that use balance-based storage patterns

## Backwards Compatibility

This proposal extends EIP-8130. Nodes not supporting this EIP will reject transactions with non-empty `extensions` as specified in EIP-8130.

## Reference Implementation

### ITokenPaymentRegistry

```solidity
interface ITokenPaymentRegistry {
    event TokenRegistered(address indexed token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist);
    event TokenStatusUpdated(address indexed token, bool active);
    event BlocklistUpdated(address indexed token, address indexed account, bool blocked);
    event BlocklistManagerUpdated(address indexed token, address indexed manager, bool authorized);
    
    // Token registration (token address or configured admin only)
    function registerToken(address token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist) external;
    function setTokenActive(address token, bool active) external;
    
    // Blocklist management
    function setBlocklistManager(address manager, bool authorized) external;
    function setBlocked(address token, address account, bool blocked) external;
    
    // View functions
    function isTokenActive(address token) external view returns (bool);
    function isBlocked(address token, address account) external view returns (bool);
    function isBlocklistManager(address token, address manager) external view returns (bool);
    function getTokenDecimals(address token) external view returns (uint8);
    function getBalanceSlotIndex(address token) external view returns (uint256);
    function hasHighBitBlocklist(address token) external view returns (bool);
}
```

### IPayerConfig

```solidity
interface IPayerConfig {
    struct TokenConfig {
        bool accepted;
        address oracleAddress;
        bytes32 oracleSlot;
        uint8 oracleDecimals;
    }
    
    event PayerUpdated(address indexed payer, bool active);
    event PayerTokenConfigured(address indexed payer, address indexed token, address oracle, bytes32 oracleSlot, uint8 oracleDecimals);
    event PayerTokenRemoved(address indexed payer, address indexed token);
    
    // Payer registration
    function setPayerActive(bool active) external;
    
    // Token configuration
    function configureToken(address token, address oracleAddress, bytes32 oracleSlot, uint8 oracleDecimals) external;
    function removeToken(address token) external;
    
    // View functions
    function isPayerActive(address payer) external view returns (bool);
    function getTokenConfig(address payer, address token) external view returns (TokenConfig memory);
    function getExchangeRate(address payer, address token) external view returns (uint256);
}
```

## Security Considerations

**Token Spend Protection**: Token gas payments occur before wallet code executes, bypassing wallet-level spend limits. Mitigations:

- **`max_amount` cap**: Hard limit on token spend per transaction
- **`requiresSponsor` policy** (EIP-8130): Accounts can enable the `requiresSponsor` flag in their gas payment policy, which disables ALL self-paid gas (ETH and tokens). When enabled, transactions must have a sponsor signature in `payer_auth`. This completely eliminates the gas spend attack vector and is strongly recommended for accounts using EVM-layer multisig.
- **Blocklist checks**: Protocol validates sender is not blocklisted before transfer

**Oracle Risks**: Per-payer oracles mean manipulation affects only that payer's users. Mitigations:

- **Trusted payer lists**: Wallets curate lists of reputable payers
- **`max_amount` field**: User-specified cap protects against price spikes

**Payer Security**: 

- **Permissioned**: Payer signs each transaction, explicitly agreeing to the token amount
- **Permissionless**: Payers explicitly configure accepted tokens and oracles; protocol validates sender balance/blocklist before transfer

**Balance Manipulation**: Protocol reads token balances directly from storage slots. Tokens with non-standard balance storage (rebasing, fee-on-transfer) may behave unexpectedly. Only register well-understood tokens.

**Token Slot Changes**: If a registered token upgrades and changes its balance storage slot, the registry configuration becomes invalid. The token must be deactivated; there is no migration path currently. This is intentional—tokens used for gas payment should have immutable storage layouts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
