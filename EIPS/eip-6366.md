---
eip: 6366
title: Permission Token
description: A new token that held the permission of an address in an ecosystem
author: Chiro (@chiro-hiro), Victor Dusart (@vdusart)
discussions-to: https://ethereum-magicians.org/t/eip-6366-a-standard-for-permission-token/9105
status: Draft
type: Standards Track
category: ERC
created: 2022-01-19
requires: bit_based_permission
---

## Abstract

This EIP offers an alternative to Access Control Lists (ACLs) for granting authorization and enhancing security. An `uint256` is used to store permission of given address in a ecosystem. Each permission is represented by a single bit in `uint256` as described in [eip-bit_based_permission](./bit_based_permission.md). Bitwise operators and bitmasks are used to determine the access right which is much more efficient and flexible than `string` or `keccak256` comparison.

## Motivation

Special roles like `Owner`, `Operator`, `Manager`, `Validator` are common for many smart contracts because permissioned addresses are used to administer and manage them. It is difficult to audit and maintain these system since these permissions are not managed in a single smart contract.

Since permission and role are reflected by the permission token balance of the relevant account in the given ecosystem, cross-interactivity between many ecosystems will be made simpler.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

_Note_ The following specifications use syntax from Solidity `0.8.7` (or above)

### Core Interface

Compliant contracts MUST implement `IEIP6366Core`.

```solidity
interface IEIP6366Core {
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _delegatee, uint256 _permission);

  function transfer(address _to, uint256 _permission) external returns (bool success);
  function approve(address _delegatee, uint256 _permission) external returns (bool success);

  function permissionOf(address _owner) external view returns (uint256 permission);
  function permissionRequire(uint256 _required, uint256 _permission) external view returns (bool isPermissioned);
  function hasPermission(address _owner, address _actor, uint256 _required) external view returns (bool isPermissioned);
  function delegated(address _owner, address _delegatee) external view returns (uint256 permission);
}
```

1. It is RECOMMENDED to define each permission as a power of `2` so that we can check for the relationship between sets of permissions using [eip-bit_based_permission](./bit_based_permission.md).
2. `transfer(address _to, uint256 _permission)` transfers a subset of `_permission` permission to address `_to`, and MUST emit the `Transfer` event. The function SHOULD `revert` if the message caller's account permission does not have the subset of the transferring permission. The function SHOULD `revert` if any of transferring permission is existing on target `_to` address. Transfers of `0` permission MUST be treated as normal transfers and emit the `Transfer` event.
3. `approve(address _delegatee, uint256 _permission)` allows `_delegatee` to act for the permission owner's behalf, up to the `_permission` permission, and MUST emit the `Approval` event. If this function is called again it overwrites the current granted with `_permission`. `_permission` MUST be a subset of all available permission of permission owner. `approve()` method SHOULD `revert` if granting `_permission` permission is not a subset of all available permission of permission owner.
4. `permissionOf(address _owner)` returns the account permission of the given `_owner` address.
5. `permissionRequire(uint256 _required, uint256 _permission)` returns `true` if `_required` permission is a subset of `_permission` permission otherwise return `false`.
6. `hasPermission(address _owner, address _actor, uint256 _required)` returns `true` if `_required` permission is a subset of `_actor`'s permissions or a subset of his delegated permissions granted by the `_owner`.
7. `delegated(address _owner, address _delegatee)` returns the subset permission of the `_owner` address were granted to `_delegatee` address.
8. A token contract which creates new tokens SHOULD emit a `Transfer` event with the `_from` address set to `address(0x00)` when tokens are created.

### Metadata Interface

It is RECOMMENDED for compliant contracts to implement the optional extension `IEIP6366Meta`.

```solidity
interface IEIP6366Meta {
  struct PermissionDescription {
    uint256 permission;
    string name;
    string description;
  }

  event UpdatePermissionDescription(uint256 indexed _permission, string indexed _name, string indexed _description);

  function name() external view returns (string memory);
  function symbol() external view returns (string memory);
  function getDescription(uint256 _permission) external view returns (PermissionDescription memory description);

  function setDescription(uint256 _permission, string memory _name, string memory _description) external returns (bool success);
}
```

1. `name()` returns the name of the token - e.g. `"OpenPermissionToken"`.
2. `symbol()` returns the symbol of the token. E.g. `"OPT"`.
3. `getDescription(uint256 _permission)` return the description of a permission.
4. `setDescription(uint256 _permission, string memory _name, string memory _description)` return `true` if the description was set otherwise return `false`. It MUST emit `UpdatePermissionDescription` event.
5. SHOULD define a description for the base permissions and main combinaison.
6. SHOULD NOT define a description for every subcombinaison of permissions possible.

### Error Interface

SHOULD NOT expected `IEIP6366Error` interface was implemented.

```solidity
interface IEIP6366Error {
  error AccessDenied(address _owner, address _actor, uint256 _permission);
  error DuplicatedPermission(uint256 _permission);
  error OutOfRange();
}
```

## Rationale

Needs discussion.

## Reference Implementation

First implementation could be found here:

- [ERC-6366 Core implementation](../assets/eip-6366/contracts/EIP6366Core.sol)
- [ERC-6366 Meta implementation](../assets/eip-6366/contracts/EIP6366Meta.sol)

## Security Considerations

Need more discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
