---
eip: 8030
title: P256 algorithm support
description: Adds an EIP-7932 algorithm type for P256 support of type `0x0`
author: James Kempton (@SirSpudlington)
discussions-to: https://ethereum-magicians.org/t/discussion-topic-for-eip-8030/25557
status: Draft
type: Standards Track
category: Core
created: 2025-09-20
requires: 7932, 7951
---

## Abstract

This EIP adds a new [EIP-7932](./eip-7932.md) algorithm of type `0x0` for supporting P256 signatures.

## Motivation

P256 (a.k.a secp256r1) is a widely-used NIST standardized algorithm that already has a presence within the Ethereum codebase. This makes it a great algorithm to write test
cases against implementations of [EIP-7932](./eip-7932.md).

## Specification

This EIP defines a new [EIP-7932](./eip-7932.md) algorithmic type with the following parameters:

| Constant | Value |
| - | - |
| `ALG_TYPE` | `Bytes1(0x0)` |
| `SIZE`| `129` |

```python
N = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551

def gas_cost(signing_data: Bytes) -> Uint64:
    # This is the precompile cost from [EIP-7951](./eip-7951.md) with 3000 gas
    # subtracted (the cost of the secp256k1 precompile)
    BASE_GAS = Uint64(3900)

    # Calculate extra overhead for keccak256 hashing
    if len(signing_data) == 32:
        return BASE_GAS
    else:
        minimum_word_size = (len(signing_data) + 31) // 32
        return BASE_GAS + Uint64(30 + (6 * minimum_word_size))

def validate(signature: Bytes) -> None | Error:
    # This function is a noop as there is no
    # exposed function defined in [EIP-7951](./eip-7951.md)

def verify(signature: Bytes, signing_data: Bytes) -> Bytes | Error:
    if len(signing_data) != 32:
        # Hash if non-standard size
        signing_data = keccak256(signing_data)

    # Ignore initial alg_type byte
    signature = signature[1:]

    (r, s, x, y) = (signature[0:32], signature[32:64], signature[64:96], signature[96:128])

    # This is similar to [EIP-2](./eip-2.md)'s malleability verification.
    assert(s <= N/2)

    # This is defined in [P256Verify Function](#p256verify-function)
    assert(P256Verify(signing_data, r, s, x, y) == Bytes("0x0000000000000000000000000000000000000000000000000000000000000001"))
        
    return x.to_bytes(32, "big") + y.to_bytes(32, "big")
```


### `P256Verify` Function

The `P256Verify` function is the logic of the precompile defined in [EIP-7951](./eip-7951.md), the only exception is that this function MUST NOT charge any gas.

## Rationale

### Why P256?

P256 or secp256r1, is used globally but (more importantly) has an existing implementation in all execution clients. This allows easy implementation of a known-safe algorithm, which is perfect for a test algorithm.

## Backwards Compatibility

No backward compatibility issues found.

## Security Considerations

### Malleability protection

This EIP includes malleability protection by requiring `s <= N/2`, similar to [EIP-2](./eip-2.md). This prevents signature malleability attacks where an attacker could create a second valid signature for the same message by negating the `s` value. Without this check, contracts relying on signature uniqueness could be vulnerable to replay attacks or double-spending scenarios.

### Signature validation

The signature validation relies on the P256 precompile defined in [EIP-7951](./eip-7951.md). The security of this EIP depends on the correct implementation of that precompile. Any vulnerabilities in the P256 verification logic would directly impact the security of signatures validated through this algorithm type.

### Hash function choice

When `signing_data` is not exactly 32 bytes, this EIP applies `keccak256` hashing before verification. This design choice ensures compatibility with Ethereum's standard hash function and prevents issues with variable-length inputs. However, users should be aware that the actual data being signed is the hash, not the original message, which has implications for signature verification in cross-chain or off-chain contexts.

### Gas cost considerations

The gas cost formula includes a base cost plus additional charges for hashing non-standard sized data. The base cost is derived from [EIP-7951](./eip-7951.md) with adjustments. Incorrect gas pricing could lead to DoS vulnerabilities if verification is underpriced, or could make the feature economically unviable if overpriced. The gas costs should be validated through benchmarking on production hardware.

### Algorithm type collision

This EIP assigns algorithm type `0x0` to P256. As the first algorithm type defined under [EIP-7932](./eip-7932.md), there is no collision risk. However, future EIPs defining additional algorithm types must ensure they do not reuse `0x0`.

### Reuse of existing implementations

The reliance on existing P256 implementations in execution clients reduces the risk of introducing new cryptographic vulnerabilities. However, implementations must ensure that the `P256Verify` function used by this EIP is identical to the precompile logic, except for gas charging, to maintain consistency.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
