---
eip: 8130
title: Account Abstraction by Account Configuration
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 2718, 2930, 7702
---

## Abstract

This proposal introduces a standardized validation mechanism for account abstraction using onchain account configurations to define accepted keys and key types. Unlike EIP-7701/RIP-7560 which permit arbitrary validation code, this approach restricts validation to predefined key types, ensuring protocol simplicity and secure account abstraction without EVM execution during validation. A new transaction type leverages this mechanism with native gas abstraction support.

## Motivation

Enable account abstraction benefits—batching, gas sponsorship, custom authentication, programmable logic—while allowing nodes to validate transactions via simple state checks without EVM execution. This enables highly optimizable and performant transaction validation and mempool implementations and removes the need for additional reputation systems to ensure DoS prevention.

Having the account auth configurations accessible and managable via the EVM enables accounts to build out any additional recovery mechanisms they desire. Calldata delivery to the account address only means the wallet can built out any additional checks for validation they desire.

### Existing Solutions

| Solution | Approach | Limitations |
|----------|----------|-------------|
| ERC-4337 | Application-layer abstraction | Complex mempool rules (ERC-7562), high gas overhead, entrypoint costs |
| [EIP-7701](./eip-7701.md) | Protocol-level with arbitrary validation | Complex mempool rules, major protocol changes |

This proposal addresses these by:

- **Simplifying Validation**: Predefined key types eliminate EVM execution during validation
- **Optimizable Mempool and Validation Logic**: Validators use only state lookups, mempools can invalidate transactions quickly via (flash)block access lists.
- **Reducing Gas Costs**: No entrypoint contracts or associated overhead
- **Ensuring Extensibility**: Supports future quantum-safe algorithms via new key types, and an `extensions` field for future protocol enhancements (e.g., token payments)
- **Maintaining Compatibility**: Coexists with EIP-7702 and ERC-4337

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD | [EIP-2718](./eip-2718.md) transaction type |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_PRECOMPILE` | TBD | Account Configuration precompile address |
| `MAX_KEYS` | 127 | Maximum configured keys per account (single-byte RLP encoding) |

### Account Configuration

Each account can configure an ordered array of authorized keys through the Account Configuration Precompile at `ACCOUNT_CONFIG_PRECOMPILE`. Only `msg.sender` can modify their own configuration. This enables existing ERC-4337 smart accounts to register keys and migrate to native AA without redeployment.

**Default behavior**: An empty configuration `[]` means only the account's EOA key can authorize transactions. The EOA key always retains authorization regardless of configured keys, ensuring recovery capability.

#### Storage Layout

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE)

Slot layout:
- base_slot + 0: key_count (uint8, max 127)
- base_slot + 1 + (index * 2): key_type[index] (uint8)
- base_slot + 1 + (index * 2) + 1: key_data[index] (bytes)
```

The protocol validates signatures by reading these slots directly - no EVM execution required.

**Key limit**: Accounts may configure up to `MAX_KEYS` (127) keys. This limit ensures `key_index` values encode in a single byte in RLP (values 0-127 are single-byte; 128+ require two bytes).

#### 2D Nonce Storage

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE || "nonce")
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

### Key Types

| Key Type | ID | Algorithm | Public Key Size | Signature Size | Intrinsic Gas |
|----------|-----|-----------|-----------------|----------------|---------------|
| `K1` | `0x01` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | 6000 |
| `R1` | `0x02` | secp256r1 / P-256 | 33/65 bytes | 64 bytes | 7000 |
| `WEBAUTHN` | `0x03` | WebAuthn / Passkey | 65 bytes | Variable | 12000 |
| `BLS` | `0x04` | BLS12-381 | 48 bytes | 96 bytes | 8000 |
| `DELEGATE` | `0x05` | Delegated validation | 20 bytes (address) | Nested signature | 1000 + delegated |

**DELEGATE**: Delegates validation to another account's configuration. The `key_data` stores the delegated account's address (20 bytes). Only 1 hop is permitted—if the delegated account also has a `DELEGATE` key at the signing index, validation fails. See [DELEGATE Signature Format](#delegate-signature-format) for signature structure.

**BLS**: Enables signature aggregation across multiple transactions can be used to reduce data availability costs for rollups and L2s. (implementation outside of this scope.)

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,               // Sender address (20 bytes) | empty for EOA signature
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp or block number 
  gas_price,
  gas_limit,
  access_list,
  authorization_list, 
  calldata,
  sender_signature,
  payer_auth,         // K1 signature (65 bytes) | empty
  extensions          // Reserved for future EIPs (e.g., token payments)
])
```

#### Extensions Field

The `extensions` field is reserved for future protocol enhancements. In this specification, it MUST be an empty list `[]`. Future EIPs may define extension formats such as:

- **Token payments**: TBD 
- **Other features**: Each extension type identified by a unique prefix byte

Nodes MUST reject transactions where `extensions` is non-empty until a future EIP defines valid extension formats.

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + sender_key_cost + calldata_cost + nonce_key_cost
```

| Component | Value |
|-----------|-------|
| `nonce_key_cost` | `SSTORE_SET_GAS` (20,000) for first use of a `nonce_key`, 0 for existing keys |

The `nonce_key_cost` ensures new 2D nonce channels incur appropriate storage costs. Consider bounding `nonce_key` to a smaller range (e.g., `uint16` for 65,536 channels) to limit per-account state growth.

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address. **Required** for configured key signatures (`0xFF` prefix). **Optional** (empty) for EOA signatures—address recovered via ecrecover. |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Transaction invalid after this Unix timestamp |
| `gas_price` | Price per gas unit |
| `gas_limit` | Maximum gas |
| `access_list` | [EIP-2930](./eip-2930.md) access list |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list |
| `calldata` | Data delivered to `from` account |
| `sender_signature` | See [Signature Format](#signature-format) |
| `payer_auth` | **65 bytes**: K1 signature, payer recovered via ecrecover. **Empty**: `from` pays ETH |
| `extensions` | Reserved for future EIPs. MUST be `[]` in this specification |

#### Signature Format

**EOA key**: Raw 65-byte ECDSA signature `(r || s || v)`. When using an EOA signature, the `from` field may be empty—the sender address is recovered via ecrecover.

**Configured key**: `0xFF || key_index || signature_data`. Requires `from` to be set (non-empty) so the protocol knows which account's configuration to validate against. The `key_index` must be in range `[0, 126]` (max `MAX_KEYS - 1`).

The `0xFF` prefix distinguishes configured key signatures from EOA signatures (since valid `v` values are 27 or 28).

##### DELEGATE Signature Format

For `DELEGATE` keys, `signature_data` contains a nested signature for the delegated account:

```
0xFF || key_index || nested_signature
```

Where `nested_signature` is a valid signature for the delegated account's configuration.

**Example**:

- Account A has K1 pubkey at `key_index=2`
- Account B has DELEGATE at `key_index=3` pointing to Account A
- Valid signature for Account B: `0xFF || 0x03 || 0xFF || 0x02 || ecdsa_sig`

The protocol validates `0xFF || 0x02 || ecdsa_sig` against Account A's config at index 2. Note this could also be its standard EOA signature (not required to be in precompile).

#### Signature Payload

Both sender and payer sign the same payload:

```
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  gas_price, gas_limit, access_list, authorization_list,
  calldata, extensions
]))
```

**Sender signature**: Authorizes the transaction—calldata execution and gas parameters.

**Payer signature** (when present): Authorizes gas payment for this specific transaction. The payer agrees to pay ETH for gas. The payer does NOT control any execution.

### Payer Modes

Gas payment supports two modes based on the `payer_auth` field:

| Mode | `payer_auth` | Gas Payer |
|------|--------------|-----------|
| Self-pay | Empty | `from` |
| Sponsored | 65-byte K1 signature | Payer (ecrecover) |

**Mode details**:

| Mode | `payer_auth` | Description |
|------|--------------|-------------|
| **Self-pay** | Empty | Sender pays gas in ETH from their own balance |
| **Sponsored** | 65-byte K1 signature | Payer signs each transaction, authorizing gas payment for this specific transaction. Suitable for paymasters and trusted sponsors. |

### Execution

#### Calldata Delivery

The `calldata` is delivered to `from` via self-call:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `from` |
| `msg.value` | 0 |
| `data` | `calldata` |

For EOAs without code, the call succeeds with no effect. For smart accounts, execution begins at the contract's entry point.

#### Validation vs Execution

This proposal constrains **validation** to enshrined key types but does not constrain **execution**. Once a transaction passes validation, the account's code can implement any logic: multisig, timelocks, spending limits, session keys, or arbitrary business rules. The `calldata` is always delivered to `from` as a self-call, ensuring wallet code controls interpretation.

**Multisig at EVM layer**: Native multisig is intentionally not included in this specification. Accounts requiring multisig validation can implement it in their smart contract code by verifying additional signatures within the `calldata`. The wallet can use `getCurrentSigner()` from the precompile to identify which key authorized the transaction, then require additional co-signers to have signed the `calldata` before executing operations.

#### Transaction Context

During execution, accounts can query the precompile for:

- **Payer**: `getCurrentPayer()` returns the gas payer address
- **Signer**: `getCurrentSigner()` returns `(keyIndex, keyType, publicKey)` used for authorization

**Optional opcodes** (`AAPAYER`, `AASIGNER`) may be added for gas-efficient access.

### Account Initialization

New accounts can be created with pre-configured keys in a single transaction:

```
account_init_auth = rlp([
  chain_id,
  salt,
  initial_keys,       // Array of AuthKey structs
  code_hash,          // Wallet bytecode hash
  key_index,          // Index into initial_keys for signature
  signature
])
```

**Address derivation**:

```
address = keccak256(0xff || ACCOUNT_CONFIG_PRECOMPILE || salt || keccak256(abi.encode(initial_keys, code_hash)))[12:]
```

Users can receive funds at counterfactual addresses before deployment.

#### Default Account (Chain Operator Option)

For EOA accounts, chain operators may configure a **default account**—a wallet implementation automatically used for addresses without deployed code. This enables EOAs to submit AA transactions and use AA features (batching, gas sponsorship) without explicitly deploying code via EIP-7702.

**Behavior**:

- EOA submits AA transaction with valid signature
- During execution, if `from` has no code, use the configured default account bytecode
- The default account interprets `calldata` (e.g., as batched calls)
- Code injection occurs at transaction time; no permanent deployment required

**Benefits**:

- Seamless AA onboarding for existing EOAs
- Users gain smart account capabilities without understanding code delegation
- Chain can standardize on a secure, audited default implementation

**Configuration**: Chain operators specify the default account bytecode hash. This is an optional feature—chains may require explicit 7702 delegation instead.

### Validation Flow

#### Mempool Acceptance

1. Resolve sender address:
   - If `from` is non-empty: use provided address
   - If `from` is empty: recover address from `sender_signature` via ecrecover (EOA signature required)
2. Validate `sender_signature` against sender's keys:
   - EOA signature: verify via ecrecover
   - Configured key (`0xFF` prefix): validate against sender's account configuration
3. Resolve payer from `payer_auth`:
   - 65 bytes: recover address via ecrecover
   - Empty: sender pays ETH
4. Verify `extensions` is empty (reject if non-empty until future EIPs define valid extensions)
5. Verify nonce, payer ETH balance, expiry
6. Mempool threshold: payer's pending sponsored transaction count must be below node-configured limits

#### Block Execution

1. ETH gas deduction from payer
2. Process authorization_list (EIP-7702)
3. Account initialization (if applicable)
4. Deliver calldata to `from` via self-call

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels.

**`eth_getTransactionReceipt`**: Should include `payer` field.

## Rationale

### Why a Precompile?

The Account Configuration Precompile serves two roles:

1. **Protocol-level validation**: The chain reads precompile storage directly to validate AA transaction signatures—no EVM execution required during validation. The protocol can keep these storage slots warm for efficient access. 
2. **Onchain interface**: Smart contracts call the precompile during execution to:
   - Modify keys (`addKey()`, `removeKey()`)
   - Query transaction context (`getCurrentSigner()`, `getCurrentPayer()`)
   - Validate signatures for 4337 compatibility (`validateSignature()`)

Having the precompile accessible onchain means that accounts can build any additional recovery logic into their code.

### Why No Native Multisig?

Native multisig is intentionally excluded to keep the protocol layer simple. Benefits of EVM-layer multisig:

1. **Flexibility**: Wallets can implement any multisig scheme (m-of-n, weighted, time-delayed, etc.)
2. **Upgradability**: Multisig logic can be updated without protocol changes
3. **Simplicity**: Protocol validation handles single signatures; complex policies live in wallet code
4. **Gas efficiency**: Avoid paying for multisig parsing in every transaction

Accounts can still achieve multisig by having the wallet contract use `getCurrentSigner()` to identify the authorizing key, then verify additional co-signer signatures from the `calldata` before executing operations.

### Why Extensions Field?

The `extensions` field enables future protocol enhancements without defining a new transaction type:

1. **Token payments**: A future extension defines `[0x01]` for gas abstraction with ERC-20 tokens.


This approach provides upgrade flexibility while keeping the initial specification minimal and focused.

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `addKey()` on the precompile to add existing signing keys (K1, R1, WebAuthn, etc.) to auth config
2. **Upgrade wallet logic**: Update contract to use precompile as source of truth:
   - Call `getKey()` / `validateSignature()` for signature verification
   - Call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

**Key principle**: Wallet contracts should avoid duplicating key storage. The precompile is ideally the single source of truth for authentication (for these key types). Wallets implement authorization logic (spending limits, timelocks, multisig) in their execution code using `getCurrentSigner()` context. Wallets are free to add any additional recovery mechanisms or other logic into their code.


## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys or using the new transaction type, note that code needs to be deployed to do anything useful as calldata is sent to the address and must be interpreted. Chains can opt in for default accounts to not require deploment via 7702 for EOA keys. 

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        uint8 keyType;
        bytes publicKey;
    }
    
    event KeyAdded(address indexed account, uint8 keyIndex, uint8 keyType, bytes publicKey);
    event KeyRemoved(address indexed account, uint8 keyIndex);
    
    // Key management (max 127 keys per account)
    function addKey(uint8 keyType, bytes calldata publicKey) external returns (uint8 keyIndex);
    function removeKey(uint8 keyIndex) external;
    function getKeyCount(address account) external view returns (uint8);
    function getKey(address account, uint8 keyIndex) external view returns (uint8 keyType, bytes memory publicKey);
    function validateSignature(address account, uint8 keyIndex, bytes32 messageHash, bytes calldata signature) external view returns (bool);
    
    // Nonce management
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
    
    // Transaction context (only valid during AA transaction execution)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (uint8 keyIndex, uint8 keyType, bytes memory publicKey);
}
```

## Security Considerations

**Enshrined Validation**: Signature verification uses well-established algorithms before any EVM execution. Failed validation rejects transactions before mempool entry.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify account configuration. EOA key always retains authorization for recovery (if created with an EOA via 7702). Maximum 127 keys per account enforced by `MAX_KEYS` constant.

**Delegation**: `DELEGATE` key type limited to 1 hop to prevent loops.

**Extensions Safety**: The `extensions` field MUST be empty until future EIPs define valid formats. Nodes reject transactions with non-empty extensions, preventing undefined behavior.

**Payer Security**: Sponsors must sign each transaction they pay for, ensuring explicit authorization of gas costs.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
