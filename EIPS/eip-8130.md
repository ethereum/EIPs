---
eip: 8130
title: Account Abstraction by Account Configuration
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 1153, 2718, 7702
---

## Abstract

This proposal defines a new [EIP-2718](./eip-2718.md) transaction type and an onchain system contract that together provide account abstraction — batching, gas sponsorship, and authentication using any cryptographic system. Accounts configure signing keys with account-specified verifiers in the system contract; the protocol validates transactions natively for well-known algorithms, and via sandboxed pure-function contracts for any other scheme.

## Motivation

Requiring code execution to validate transactions leads to wasted compute, denial-of-service vectors, and compensatory systems (tracing, staking, reputation). This proposal uses pure-function verifiers with known state inputs — a node can determine validity from state alone, and new signature schemes are deployed as EVM contracts without protocol changes.

This provides a native path to post-quantum secure authentication.

The system contract is accessible via the EVM, so wallet code can layer additional logic — recovery, multisig, spending limits, session keys — on top. The protocol handles authentication, gas payment, and calldata delivery to be interpreted by the account. 

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD <!-- TODO --> | [EIP-2718](./eip-2718.md) transaction type |
| `AA_PAYER_TYPE` | TBD <!-- TODO --> | Magic byte for payer signature domain separation |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_ADDRESS` | TBD <!-- TODO --> | Account Configuration system contract address |
| `KNOWN_VERIFIER_ADDRESSES` | TBD <!-- TODO --> | Well-known verifier addresses (K1, P256_RAW, P256_WEBAUTHN, DELEGATE) |
| `NONCE_MANAGER_ADDRESS` | TBD <!-- TODO --> | Nonce Manager precompile address |
| `KEY_CHANGE_TYPE` | TBD <!-- TODO --> | Magic byte for key change signature domain separation |
| `MAX_KEY_CHANGES` | 10 | Maximum key change entries per transaction |
| `MAX_SIGNATURE_SIZE` | 2048 | Maximum signature size in bytes (DoS prevention) |
| `ENTRY_POINT_ADDRESS` | TBD <!-- TODO --> | Protocol caller address for call execution |
| `DEFAULT_ACCOUNT_ADDRESS` | TBD <!-- TODO --> | Default account predeploy for EOAs without code |
| `DEPLOYMENT_HEADER_SIZE` | 14 | Size of the deployment header in bytes |

### Account Types

This proposal supports three paths for accounts to use AA transactions:

| Account Type | How It Works | Key Recovery |
|--------------|--------------|--------------|
| **Existing Smart Contracts** | Already-deployed accounts (e.g., ERC-4337 wallets) register keys via `authorizeKey()` on the system contract | Wallet-defined |
| **EOAs** | If no code is set, the protocol delegates to `DEFAULT_ACCOUNT_ADDRESS` on the first AA transaction ([EIP-7702](./eip-7702.md) delegation write). EOAs can set a custom delegation via `authorization_list` instead | EOA key authorized by default; revocable |
| **New Accounts (No EOA)** | Created via `account_initialization` with CREATE2 address derivation; runtime bytecode placed at address, keys + verifiers configured, call execution handles initialization | Wallet-defined |


### Verifiers

Each key is associated with a verifier — a contract at a known address that performs signature verification. The verifier address is stored in `key_config` and identifies the signature algorithm. On 8130 chains, the protocol recognizes well-known verifier addresses and uses native implementations; unknown verifiers are executed in a sandboxed environment (see [Sandbox Verifiers](#sandbox-verifiers)).

#### Well-Known Verifiers

| Verifier | Address | Algorithm | Public Key Size | Signature Size | keyId Derivation |
|----------|---------|-----------|-----------------|----------------|------------------|
| K1 | `K1_VERIFIER` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | `keccak256(x \|\| y)[12:]` |
| P256_RAW | `P256_RAW_VERIFIER` | secp256r1 / P-256 (raw ECDSA) | 33/65 bytes | 64 bytes | `keccak256(x \|\| y)[12:]` |
| P256_WEBAUTHN | `P256_WEBAUTHN_VERIFIER` | secp256r1 / P-256 (WebAuthn) | 33/65 bytes | Variable | `keccak256(x \|\| y)[12:]` |
| DELEGATE | `DELEGATE_VERIFIER` | Delegated validation | 20 bytes (address) | Nested signature | `address` (direct) |

All verifiers implement the same `IAuthVerifier.verify()` interface (see [Verifier Contracts](#verifier-contracts)).

**DELEGATE**: Delegates validation to another account's configuration. The `keyId` is the delegated account's address directly — a transparent pointer. Only 1 hop is permitted (see [DELEGATE](#delegate)).

> **K1 / DELEGATE mutual exclusion**: Because K1 keyId is an Ethereum address, a K1 key and a DELEGATE entry resolve to the same keyId when they reference the same address. They occupy the same storage slot and are therefore mutually exclusive — an account can register a K1 key for address *or* a DELEGATE to account, but not both. K1 pins trust to a *specific private key*; DELEGATE trusts *any key currently authorized on the target account*.

#### Sandbox Verifiers

Any contract can serve as a verifier if its bytecode passes a sandbox validation scan — enabling permissionless addition of new signature algorithms without protocol changes. Sandbox verifiers must be pure functions: no state access, no external calls except allowlisted precompiles. Their bytecode includes a standardized header declaring a `gas_limit`, which is charged as intrinsic gas. See [Appendix: Sandbox Verifier Bytecode](#appendix-sandbox-verifier-bytecode) for the header format and opcode rules.

### Account Configuration

Each account can authorize a set of keys through the Account Configuration Contract at `ACCOUNT_CONFIG_ADDRESS`. This contract handles key storage, account creation, key change sequencing, and delegates signature verification to onchain [Verifier Contracts](#verifier-contracts).

Keys are identified by their `keyId`, a 20-byte content-derived identifier (see [Verifiers](#verifiers) for per-type derivation). Only `msg.sender` can modify their own key configuration within EVM execution. Keys can also be modified via portable key changes (see [Cross-Chain Key Changes](#cross-chain-key-changes)).

**Default behavior**: The EOA key is implicitly authorized by default but can be revoked on the contract.

#### Storage Layout

Each key occupies a `key_config` slot (packed: verifier, policy, expiration, gasSpendLimit, verifierData) plus additional slots for the public key. A per-chain key change sequence counter supports [Cross-Chain Key Changes](#cross-chain-key-changes). See [Appendix: Storage Layout](#appendix-storage-layout) for the full slot derivation.

The protocol validates signatures by reading `key_config` and public key slots directly — see [Validation](#validation) for the full flow. Key enumeration is performed off-chain via `KeyAuthorized` / `KeyRevoked` event logs. No key count is enforced on-chain — gas costs naturally bound key creation.

#### 2D Nonce Storage

Nonce state is managed by a precompile at `NONCE_MANAGER_ADDRESS`, isolating high-frequency nonce writes from the Account Configuration Contract's key storage (see [Why a Nonce Precompile?](#why-a-nonce-precompile)). The protocol reads and increments nonce slots directly during AA transaction processing; the precompile exposes a read-only `getNonce()` interface to the EVM. See [Appendix: Storage Layout](#appendix-storage-layout) for slot derivation.

#### Verifier Contracts

Each key's `verifier` address in `key_config` determines which contract performs verification. All verifiers implement `IAuthVerifier.verify()` (see [Reference Implementation](#iauthverifier)). The Account Configuration Contract calls verifiers directly via `staticcall` for `applyKeyChange()` authorizer verification and EVM-initiated signature checks.

On 8130 chains, the protocol does **not** call verifier contracts for AA transaction validation — it reads key storage directly and uses native implementations for well-known verifiers or sandbox execution for unknown ones. Verifier contracts serve EVM callers only.

The `DELEGATE_VERIFIER` is an exception to the pure function model — it reads the delegated account's key data from the Account Configuration Contract and chains to the nested verifier, enforcing a 1-hop limit.

#### Account Policy

Account-level policy is stored in a single packed 32-byte slot at `keccak256(base_slot || "account_policy")` (see [Appendix: Storage Layout](#appendix-storage-layout)). Reserved bytes provide an extension path for future account-level flags.

##### Account Lock

An account can lock itself to freeze its key configuration. When locked:

- Local key modifications (`authorizeKey()`, `revokeKey()`, `setPolicy()`, `setExpiration()`, `setVerifierData()`) revert
- Portable key changes (`key_changes` in transactions, `applyKeyChange()` via EVM) are rejected
- The lock cannot be removed without a timelock delay

**Lifecycle**:

1. `lock(unlockDelay)` — sets `locked = true` with a minimum delay (seconds) between unlock request and removal. `msg.sender` only.
2. `requestUnlock()` — records `unlock_requested_at = block.timestamp`. `msg.sender` only.
3. `unlock()` — requires `block.timestamp >= unlock_requested_at + unlock_delay`. Clears the lock and resets `unlock_requested_at`. `msg.sender` only.

Wallet bytecode SHOULD enforce ETH movement restrictions when locked — refusing outbound value transfers while allowing zero-value external calls. This enables locked accounts to interact with contracts (token transfers, DeFi, etc.) while ensuring ETH balance only decreases via gas payment. Accounts using an [ERC-1167](./eip-1167.md) minimal proxy to `DEFAULT_ACCOUNT_ADDRESS` inherit this behavior and are trivially recognizable by nodes (45 bytes, deterministic pattern). See [High-Rate Mempool Acceptance](#high-rate-mempool-acceptance) for how nodes use this guarantee.

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,               // Sender address (20 bytes) | empty for EOA signature
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp (seconds)
  max_priority_fee_per_gas,
  max_fee_per_gas,
  gas_limit,
  authorization_list, 
  account_initialization,  // For creating new accounts if not using 7702 | empty
  key_changes,        // Replayable cross-chain key change operations | empty
  committed_calldata, // Calldata committed first (ie. payer required action)  | empty
  calldata,           // Calldata executed atomically | empty
  payer_commitment,   // empty = self-pay, 0x00 = open, payer_address = committed
  sender_auth,
  payer_auth          // empty = self-pay, type_byte || auth_data = sponsored
])
```

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address. **Required** (non-empty) for configured key signatures. **Empty** for EOA signatures—address recovered via ecrecover. The presence or absence of `from` is the sole distinguisher between EOA and configured key signatures. |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Unix timestamp (seconds since epoch). Transaction invalid when `block.timestamp > expiry`. A value of `0` means no expiry |
| `max_priority_fee_per_gas` | Priority fee per gas unit ([EIP-1559](./eip-1559.md)) |
| `max_fee_per_gas` | Maximum fee per gas unit ([EIP-1559](./eip-1559.md)) |
| `gas_limit` | Maximum gas |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list. Overrides default account delegation when present |
| `account_initialization` | **Empty**: No account creation. **Non-empty**: See [Account Initialization](#account-initialization) |
| `key_changes` | **Empty**: No key changes. **Non-empty**: Array of signed key change operations. See [Cross-Chain Key Changes](#cross-chain-key-changes) |
| `committed_calldata` | **Empty**: No committed call. **Non-empty**: Calldata (bytes) delivered to `from`. See [Call Execution](#call-execution) |
| `calldata` | **Empty**: No call. **Non-empty**: Calldata (bytes) delivered to `from`. See [Call Execution](#call-execution) |
| `payer_commitment` | Sender's commitment to a gas payer. **Empty**: self-pay. **`0x00`**: open sponsorship (any payer). **20-byte address**: committed to specific payer. See [Payer Modes](#payer-modes) |
| `sender_auth` | See [Signature Format](#signature-format) |
| `payer_auth` | Payer authorization. **Empty**: self-pay. **Non-empty**: type byte (`0x00` = raw ecdsa, `0x01` = standard verifier based) followed by auth data. See [Payer Modes](#payer-modes) |

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + tx_payload_cost + sender_key_cost + payer_cost + nonce_key_cost + bytecode_cost + key_changes_cost
```

**`sender_key_cost`**: Determined by the verifier address read from the sender's `key_config`:

| Verifier | Gas | Rationale |
|----------|-----|-----------|
| EOA (no key_config) | 6000 | ecrecover (3000) + 1 SLOAD (key_config) + overhead |
| `K1_VERIFIER` | 6000 | ecrecover (3000) + 1 SLOAD (key_config) + overhead |
| `P256_RAW_VERIFIER` | 7000 | P256 verify + reads public key |
| `P256_WEBAUTHN_VERIFIER` | 12000 + calldata_gas | P256 verify + WebAuthn parsing + reads public key |
| `DELEGATE_VERIFIER` | 3000 + nested | 1 SLOAD + nested sig cost |
| Sandbox verifier | declared `gas_limit` + reads public key | Gas from bytecode header, charged in full |

All types read `key_config` (1 SLOAD) for authorization, policy checks, and verifier address. Non-K1 types require additional SLOADs to read the public key.

**`payer_cost`**: Determined by the payer mode (see [Payer Modes](#payer-modes)):

| Payer Mode | Gas | Rationale |
|------------|-----|-----------|
| Self-pay | 0 | `spendMode` checked from sender validation SLOAD (no additional read) |
| K1 sponsor | 3,000 | ecrecover (no storage read) |
| Verified sponsor | sender_key_cost for payer's verifier | Reads payer's key_config + public key, runs verification |

| Component | Value |
|-----------|-------|
| `tx_payload_cost` | Standard per-byte cost over the entire RLP-serialized transaction: 16 gas per non-zero byte, 4 gas per zero byte, consistent with [EIP-2028](./eip-2028.md). Ensures all transaction fields (`account_initialization`, `key_changes`, `authorization_list`, `sender_auth`, `committed_calldata`, `calldata`, etc.) are charged for data availability |
| `nonce_key_cost` | 22,100 gas for first use of a `nonce_key` (cold SLOAD + SSTORE set), 5,000 gas for existing keys (cold SLOAD + warm SSTORE reset) |
| `bytecode_cost` | 0 if `account_initialization` empty. Otherwise: 32,000 (deployment base) + code deposit cost (200 gas per deployed byte). Byte costs for `bytecode` are covered by `tx_payload_cost` |
| `key_changes_cost` | Per applied entry: authorizer signature verification cost (based on authorizer's `verifier`, using the `sender_key_cost` table above) + `num_operations` × 20,000 per SSTORE for key struct slots. Per skipped entry (already applied): 2,100 (SLOAD to check sequence). 0 if `key_changes` empty |

#### Signature Format

Signature format is determined by the `from` field:

**EOA signature** (`from` empty): Raw 65-byte ECDSA signature `(r || s || v)`. The sender address is recovered via ecrecover. This is the only format that uses key recovery.

**Configured key signature** (`from` set):

```
keyId (20 bytes) || signature_data
```

| Verifier | Signature Format | Total Size | Protocol Reads |
|----------|------------------|------------|----------------|
| K1 | `keyId (20) \|\| r,s,v (65)` | 85 bytes | 1 SLOAD |
| P256_RAW | `keyId (20) \|\| r,s (64)` | 84 bytes | reads key_config + public key |
| P256_WEBAUTHN | `keyId (20) \|\| authenticatorData \|\| cDJ_len (2) \|\| clientDataJSON \|\| r,s (64)` | Variable | reads key_config + public key |
| DELEGATE | `delegate_address (20) \|\| nested_signature` | Variable | 1 SLOAD + nested |
| Sandbox | `keyId (20) \|\| verifier-specific data` | Variable | reads key_config + public key + sandbox gas |

All configured key signatures begin with `keyId` (20 bytes). The protocol reads `key_config` for the keyId, which yields the `verifier` address and determines how to parse the remaining `signature_data`.

##### Validation

1. **Parse keyId**: First 20 bytes of configured key signature. For EOA (`from` empty): ecrecover derives the sender address directly — skip remaining steps.
2. **Read key_config** for `(from, keyId)` (1 SLOAD): yields `verifier`, `policy`, `expiration`, and `gasSpendLimit`. Verify authorized — non-zero verifier + not expired (`expiration == 0 || block.timestamp <= expiration`). For `keyId == from` with empty slot: EOA default (valid with `K1_VERIFIER`).
3. **Read public key** from storage. Verify signature: for well-known verifiers, use native implementation; for unknown verifiers, sandbox execution with declared gas limit. Reject if verification fails.

##### DELEGATE

For `DELEGATE_VERIFIER`, the protocol reads the delegated account's address from the `publicKey` field (stored as 20 bytes), then parses `nested_signature` as `nested_keyId (20) || nested_sig_data`. It reads the nested key's `key_config` from the delegated account and validates using the nested verifier. Only 1 hop is permitted; nested `DELEGATE_VERIFIER` results in an immediate mempool drop.

**Example** (Account B delegates to Account A, which has a P256 key):

```
Account_A_address (20) || A_P256_keyId (20) || r,s (64)
```

#### Signature Payload

Sender and payer use different type bytes for domain separation, preventing signature reuse attacks:

**Sender signature hash** — all tx fields through `payer_commitment`, excluding `sender_auth` and `payer_auth`:

```
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata,
  payer_commitment
]))
```

**Payer signature hash** — all tx fields through `calldata`, excluding `payer_commitment`, `sender_auth`, and `payer_auth`:

```
keccak256(AA_PAYER_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata
]))
```

#### Payer Modes

Gas payment and sponsorship are controlled by two independent fields:

**`payer_commitment`** — the sender's commitment regarding the gas payer, included in the sender's signed hash:

| Value | Mode |
|-------|------|
| empty | Self-pay — sender pays their own gas |
| `0x00` | Open — sender accepts any sponsor |
| `payer_address` (20 bytes) | Committed — sender bound to a specific sponsor |

**`payer_auth`** — the payer's authentication, independent of commitment mode:

| Type | Format | Resolution |
|------|--------|------------|
| — | empty | Self-pay (no sponsor) |
| `0x00` | `0x00 \|\| ecdsa_sig (65)` | K1 — payer address recovered via ecrecover, no storage read |
| `0x01` | `0x01 \|\| payer_address (20) \|\| keyId (20) \|\| sig_data` | Verified — reads payer's `key_config`, verifies via stored verifier |

The two fields are fully independent. `payer_commitment` is part of the sender's signed hash — the sender's signature is valid regardless of the payer's auth mechanism. `payer_auth` is the payer's proof of authorization — the payer signs the same hash regardless of commitment mode. For committed sponsorship, the recovered/parsed payer address must match `payer_commitment`.

**Deferred gas deduction**: For self-pay, gas is normally deducted upfront. If the sender has insufficient balance and `committed_calldata` is present, gas deduction is deferred until after `committed_calldata` executes — allowing the sender to acquire ETH during that frame (e.g., via a token swap). The sender must hold sufficient ETH after `committed_calldata` completes or the transaction is invalid.

Self-pay is rejected if the signing key's `spendMode == off`. When `spendMode == limit`, `gas_limit × gas_price` is checked against `gasSpendLimit`. Cumulative spend tracking is the wallet's responsibility.

### Account Initialization

New smart contract accounts can be created with pre-configured keys in a single transaction using the `account_initialization` field. The `bytecode` is the runtime code placed directly at the account address — it is not executed during deployment. The account's initialization logic runs when `calldata` is delivered to the account via the execution phase that follows:

```
account_initialization = rlp([
  user_salt,          // bytes32: User-chosen uniqueness factor
  bytecode,           // bytes: Runtime bytecode placed directly at the account address
  initial_keys        // Array of [verifier, public_key, verifier_data] tuples
])
```

#### Address Derivation

Addresses are derived using the CREATE2 address formula with the Account Configuration Contract (`ACCOUNT_CONFIG_ADDRESS`) as the deployer. The `initial_keys` are sorted by `keyId` before hashing to ensure address derivation is order-independent (the same set of keys always produces the same address regardless of the order specified):

```
sorted_keys = sort(initial_keys, by: keyId)

keys_commitment = keccak256(keyId_0 || verifier_0 || keyId_1 || verifier_1 || ... || keyId_n || verifier_n)

effective_salt = keccak256(user_salt || keys_commitment)
deployment_code = DEPLOYMENT_HEADER(len(bytecode)) || bytecode
address = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(deployment_code))[12:]
```

The `keys_commitment` uses `keyId || verifier` (40 bytes) per key — consistent with how the Account Configuration Contract identifies keys.

`DEPLOYMENT_HEADER(n)` is a fixed 14-byte EVM loader that returns the trailing bytecode (see [Appendix: Deployment Header](#appendix-deployment-header) for the full opcode sequence). On non-8130 chains, `createAccount()` constructs `deployment_code` and passes it as init_code to CREATE2. On 8130 chains, the protocol constructs the same `deployment_code` for address derivation but places `bytecode` directly (no execution). Both paths produce the same address — callers only provide `bytecode`; the header is never user-facing.

Users can receive funds at counterfactual addresses before account creation.

#### Validation (Account Initialization)

When `account_initialization` is non-empty:

1. Parse `[user_salt, bytecode, initial_keys]`
2. For each key in `initial_keys`, derive `keyId`. For compressed public keys, decompress to the uncompressed point before derivation.
3. Reject if any duplicate `keyId` values exist
4. Sort by keyId: `sorted_keys = sort(initial_keys, by: keyId)`
5. Compute `keys_commitment = keccak256(keyId_0 || verifier_0 || ... || keyId_n || verifier_n)`
6. Compute `effective_salt = keccak256(user_salt || keys_commitment)`
7. Compute `deployment_code = DEPLOYMENT_HEADER(len(bytecode)) || bytecode`
8. Compute `expected = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(deployment_code))[12:]`
9. Require `from == expected`
10. Require `code_size(from) == 0` (account not yet deployed)
11. Validate `sender_auth` against one of `initial_keys` (keyId extracted from signature must match an entry's computed keyId)

#### Execution (Account Initialization)

1. Register `initial_keys` in Account Config storage for `from`: for each key, compute `keyId`, write verifier and public_key to the key struct slots
2. Apply `key_changes` (if non-empty) — see [Cross-Chain Key Changes](#cross-chain-key-changes)
3. Place `bytecode` at `from`
4. Proceed with call execution

Key registration and key changes are applied before code placement so that the account's initialization logic (executed via call execution) can read its own key configuration from the Account Config contract.

### Cross-Chain Key Changes

The `key_changes` field enables cross-chain portable key management. Key change operations include a `chain_id` field where `0` means valid on any chain, allowing them to be replayed across chains to synchronize key state.

#### Key Change Format

```
key_changes = [
  rlp([
    chain_id,           // uint64: 0 = valid on any chain
    sequence,           // uint64: monotonic ordering
    operations,         // Array of key operations
    authorizer_auth     // Signature from a key valid at this sequence
  ]),
  ...  // max MAX_KEY_CHANGES entries per transaction
]

operation = rlp([
  op_type,              // 0x01 = authorizeKey, 0x02 = revokeKey
  verifier,             // address: verifier contract address
  public_key,           // bytes: public key material
  policy,               // uint8: bits 0-1 spendMode, bits 2-7 reserved
  expiration,           // uint32: 0 = no expiry, 1 = revoked
  gas_spend_limit,      // uint48: gwei, per-tx gas cap (when spendMode=limit)
  verifier_data         // uint8: verifier-specific configuration
])
```

Each entry represents a set of key operations authorized at a specific sequence number. The `authorizer_auth` must be valid against the account's key configuration *at the point after all previous entries in the list have been applied*.

The sequence number is scoped to a 2D channel defined by the `chain_id`: `0` uses the multichain sequence channel (valid on any chain), while a specific `chain_id` uses that chain's local channel.

#### Key Change Signature Payload

Key change signatures use domain separation via `KEY_CHANGE_TYPE`:

```
keccak256(KEY_CHANGE_TYPE || rlp([
  from,
  chain_id,
  sequence,
  operations
]))
```

The `authorizer_auth` follows the same [Signature Format](#signature-format) as `sender_auth` (EOA or configured key), validated against the account's key state at that point in the sequence.

#### Key Change Paths

Keys can be modified through three paths:

| | Portable: `key_changes` (tx field) | Portable: `applyKeyChange()` (EVM) | Local: `authorizeKey()` / `revokeKey()` / `setPolicy()` / `setExpiration()` / `setVerifierData()` (EVM) |
|--|---|---|---|
| Authorization | Signed operation (any verifier) | Signed operation (any verifier) | `msg.sender` during execution |
| Portability | Cross-chain (chain_id 0) or chain-specific | Cross-chain (chain_id 0) or chain-specific | Chain-local only |
| Sequence | Increments channel's `key_change_sequence` | Increments channel's `key_change_sequence` | Does NOT affect `key_change_sequence` |
| When processed | Before code deployment (8130 only) | During EVM execution (any chain) | During EVM execution |

Both portable paths share the same signed operations and `key_change_sequence` counters. `applyKeyChange()` verifies the authorizer via `IAuthVerifier(verifier).verify(...)` — anyone (including relayers) can call it; authorization comes from the cryptographic signature, not the caller.

**Local key changes** (`authorizeKey()` / `revokeKey()` / `setPolicy()` / `setExpiration()` / `setVerifierData()`) require `msg.sender` and do **not** increment `key_change_sequence`. Portable key changes may overwrite local changes at the same keyIds. All key modification paths are blocked when the account is locked (see [Account Lock](#account-lock)).

### Execution

#### Call Execution

Both `committed_calldata` and `calldata` are delivered to `from` as individual calls:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `ENTRY_POINT_ADDRESS` |
| `msg.value` | 0 |
| `data` | `committed_calldata` or `calldata` |

Both phases share a single gas pool from `gas_limit`. `committed_calldata` executes first; `calldata` receives the remainder. For accounts without code, calls succeed with no effect. See [Block Execution](#block-execution) steps 9–10 for ordering and commit/revert semantics.

The wallet fully interprets both payloads — batching, multicall, or any other execution pattern is handled by the wallet's code, not the protocol.

#### Transaction Context

During AA transaction execution, accounts can query the Account Configuration Contract for the current transaction's authorization context:

- **Payer**: `getCurrentPayer()` returns the gas payer address (`from` for self-pay, recovered payer for sponsored)
- **Signer**: `getCurrentSigner()` returns the full key configuration of the key that authorized the transaction (see [IAccountConfig](#iaccountconfig))

The protocol injects this context using [EIP-1153](./eip-1153.md) transient storage (TSTORE) on the Account Configuration Contract before call execution. Only two values are written:

| Slot | Value | Size |
|------|-------|------|
| `keccak256("context.payer")`  | Payer address | 20 bytes |
| `keccak256("context.signer")` | Signer keyId | 20 bytes |

`getCurrentPayer()` reads payer via TLOAD. `getCurrentSigner()` reads keyId via TLOAD, then looks up key data from persistent key storage. Transient storage is automatically cleared at transaction end.

**Non-8130 chains**: These functions return zero/default values since no protocol writes to transient storage.

### Portability

The system is split into storage and verification layers with different portability characteristics:

| Component | 8130 chains | Non-8130 chains |
|-----------|-------------|-----------------|
| **Account Configuration Contract** | Protocol reads storage directly for validation; EVM interface available | Standard contract (ERC-4337 compatible factory) |
| **Verifier Contracts** | Protocol uses native implementations for well-known verifiers; sandbox for unknown | Same onchain contracts callable by account config contract and wallets |
| **Nonce Manager** | Precompile at `NONCE_MANAGER_ADDRESS` | Not applicable; nonce management by existing systems (e.g., ERC-4337 EntryPoint) |

The Account Configuration Contract is identical Solidity bytecode on every chain (deployed via CREATE2). Verifier contracts are also deployed at deterministic addresses. See [Why Verifier Contracts?](#why-verifier-contracts) for the design rationale.

### Validation Flow

#### Mempool Acceptance

1. Verify `sender_auth` size ≤ `MAX_SIGNATURE_SIZE`, `key_changes` length ≤ `MAX_KEY_CHANGES`
2. Resolve sender: if `from` set, use it; if empty, ecrecover from `sender_auth`
3. Determine effective key state:
   a. If `account_initialization` non-empty: verify address derivation, `code_size(from) == 0`, use `initial_keys`
   b. Else: read from Account Config storage
4. If `key_changes` non-empty: reject if account is locked (see [Account Lock](#account-lock)). Otherwise, simulate applying operations in sequence, skip already-applied entries.
5. Validate `sender_auth` against resulting key state (see [Validation](#validation))
6. Resolve payer from `payer_commitment` and `payer_auth`:
   - Both empty: self-pay. Reject if `spendMode == off`. Check `gas_limit × gas_price` against `gasSpendLimit` (if `spendMode == limit`). Payer is `from`. If balance insufficient and `committed_calldata` non-empty: deferred — nodes MAY reject, or SHOULD simulate `committed_calldata` to verify resulting balance covers gas. If balance insufficient and `committed_calldata` empty: reject.
   - `payer_auth` non-empty: read type byte:
     - `0x00` (K1): Recover payer via ecrecover over the payer signature hash.
     - `0x01` (Verified): Parse `payer_address (20) || keyId (20) || sig_data`. Read payer's `key_config`, verify via stored verifier.
   - If `payer_commitment` is a 20-byte address (committed): verify recovered/parsed payer address matches `payer_commitment`.
7. Verify nonce, payer ETH balance, expiry
8. Mempool threshold: gas payer's pending count below node-configured limits. See [High-Rate Mempool Acceptance](#high-rate-mempool-acceptance) for elevated limits on locked accounts.

##### High-Rate Mempool Acceptance

When a gas payer (sender for self-pay, or sponsor) exceeds the standard per-account pending threshold, nodes MAY grant elevated limits if all of the following hold:

1. **Account is locked**: Read `account_policy` — `locked == true` and `unlock_requested_at == 0` (no pending unlock)
2. **Bytecode is compatible**: Account code is an [ERC-1167](./eip-1167.md) minimal proxy to a recognized implementation that enforces ETH movement restrictions when locked, or other bytecode the node recognizes as compatible
3. **Balance covers commitments**: Total `gas_limit × max_fee_per_gas` across all pending transactions charged to this payer does not exceed the payer's ETH balance

When these conditions hold, ETH balance can only decrease via gas payments — nodes can track committed gas precisely and accept transactions up to the balance limit rather than applying a fixed pending count.

If a node observes `unlock_requested_at` become non-zero for a locked account, it SHOULD stop accepting new high-rate transactions for that account and allow existing pending transactions to drain during the `unlock_delay` period.

#### Block Execution

1. ETH gas deduction from payer (sponsor for sponsored, `from` for self-pay). If self-pay balance is insufficient: defer to step 9 if `committed_calldata` present, otherwise transaction is invalid.
2. Increment nonce in Nonce Manager storage.
3. Process authorization_list ([EIP-7702](./eip-7702.md))
4. **Default account delegation**: If `code_size(from) == 0` and `account_initialization` is empty, set the code of `from` to `0xef0100 || DEFAULT_ACCOUNT_ADDRESS`.
5. Register `initial_keys` in Account Config storage (if `account_initialization` non-empty)
6. Apply `key_changes` to Account Config storage (if non-empty). Reject transaction if account is locked (see [Account Lock](#account-lock)).
7. Place `bytecode` at `from` (if `account_initialization` non-empty; code is placed directly, not executed)
8. Write transaction context to Account Config transient storage via TSTORE (payer address, signer keyId)
9. Execute `committed_calldata` via `ENTRY_POINT_ADDRESS` if non-empty (committed independently). If `committed_calldata` reverts, its state changes are discarded and step 10 is skipped. **Deferred gas deduction**: if gas was not deducted in step 1, deduct from `from` after this step; clients SHOULD emit a trace entry for this protocol-level balance change. Transaction is invalid and cannot be included if `from` has insufficient ETH at this point.
10. Execute `calldata` via `ENTRY_POINT_ADDRESS` if non-empty (skipped if step 9 reverted)

Unused gas is refunded to the payer. For steps 5–7, the protocol SHOULD inject log entries into the transaction receipt (e.g., `KeyAuthorized`, `AccountCreated`) matching the events defined in the [IAccountConfig](#iaccountconfig) interface, following the protocol-injected log pattern established by [EIP-7708](./eip-7708.md).

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels. Reads from the Nonce Manager precompile at `NONCE_MANAGER_ADDRESS`.

**`eth_getTransactionReceipt`**: AA transaction receipts include:

- `payer` (address): Gas payer address (`from` for self-pay, recovered/specified payer for sponsored).
- `status` (uint8): `0x00` = reverted (`committed_calldata` reverted, `calldata` skipped), `0x01` = success (both frames succeeded or were empty), `0x02` = partial (`committed_calldata` succeeded, `calldata` reverted). Existing tools checking `status == 1` remain correct for the success path.

### Appendix: Storage Layout

**Account Configuration Contract** (`ACCOUNT_CONFIG_ADDRESS`):

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_ADDRESS)

Key struct (per keyId):
  keccak256(keyId || base_slot) + 0: key_config (uint256, packed)
    bytes 0-19: verifier (address) — non-zero + not expired = authorized
    byte 20:    policy (uint8) — bits 0-1: spendMode (00=unlimited, 01=off, 10=limit, 11=reserved); bits 2-7: reserved
    bytes 21-24: expiration (uint32) — 0 = no expiry, 1 = revoked, else Unix timestamp
    bytes 25-30: gasSpendLimit (uint48, gwei) — per-tx gas cap (when spendMode=10)
    byte 31:    verifierData (uint8) — verifier-specific configuration, set by account owner
  keccak256(keyId || base_slot) + 1: public_key_length (uint32)
  keccak256(keyId || base_slot) + 2: public_key bytes [0:32]
  keccak256(keyId || base_slot) + 3: public_key bytes [32:64] (if needed)
  ...additional slots as needed: ceil(len(public_key) / 32) slots total

Key change sequence:
  keccak256(base_slot || "key_sequence" || chain_id): latest applied sequence (uint64)
    chain_id 0 = multichain channel, specific chain_id = chain-local channel

Account policy:
  keccak256(base_slot || "account_policy"): account_policy (uint256, packed)
    byte 0:     flags (uint8) — bit 0: locked; bits 1-7: reserved
    bytes 1-4:  unlockDelay (uint32) — seconds between unlock request and effect
    bytes 5-8:  unlockRequestedAt (uint32) — timestamp of unlock request, 0 = not requested
    bytes 9-31: reserved (23 bytes for future account-level policy)
```

**Nonce Manager Precompile** (`NONCE_MANAGER_ADDRESS`):

```
Base slot: keccak256(account_address || NONCE_MANAGER_ADDRESS)
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

### Appendix: Sandbox Verifier Bytecode

Sandbox verifier bytecode must include a standardized header and contain no forbidden opcodes:

```
Bytecode header:
  Byte 0:    0x60         PUSH1
  Byte 1:    0x09         (jump offset)
  Byte 2:    0x56         JUMP
  Byte 3-4:  0x81 0x30    magic ("8130")
  Byte 5-7:  gas_limit    uint24, units of 1k gas
  Byte 8:    version      uint8 (interface version)
  Byte 9:    0x5B         JUMPDEST
  Byte 10+:  verification code
```

**Allowed opcodes**: Stack operations, arithmetic, bitwise, KECCAK256, memory operations, CALLDATALOAD/SIZE/COPY, RETURN, REVERT, jumps, and STATICCALL to allowlisted precompile addresses only.

**Forbidden opcodes**: CALL, DELEGATECALL, CALLCODE, SLOAD, SSTORE, TLOAD, TSTORE, all external state reads (BALANCE, EXTCODESIZE, etc.), CREATE, CREATE2, SELFDESTRUCT, LOG0–LOG4.

STATICCALL is allowed in bytecode but runtime-filtered: the target address must be an allowlisted precompile. This enables verifiers to use existing precompiles (modexp, SHA-256, ecrecover, etc.) as building blocks while maintaining the pure function guarantee.

**Interface version 0** (current): The protocol passes `(account, keyId, publicKey, verifierData, hash, signature)` as calldata to the sandbox. The `verifierData` byte from `key_config` is included at zero additional cost (already read in the same SLOAD) and gives verifiers 1 byte of mutable configuration (e.g., multisig threshold), updatable via `setVerifierData()` without changing the key. This is pure authentication — the verifier checks cryptographic validity and nothing else.

The version byte is an **8130 sandbox mechanism only**. Because sandbox verifiers cannot access state or make external calls (beyond allowlisted precompiles), any additional data they need must be pre-read by the protocol and passed as calldata. The version byte tells the protocol what inputs the sandbox requires. On non-8130 chains, verifier contracts are called via normal STATICCALL and can fetch any additional data themselves — the version byte in their bytecode header is not inspected. Future versions would be defined in a subsequent EIP.

### Appendix: Deployment Header

The `DEPLOYMENT_HEADER(n)` is a 14-byte EVM loader that copies trailing bytecode into memory and returns it. The header encodes bytecode length `n` into its `PUSH2` instructions:

```
DEPLOYMENT_HEADER(n) = [
  0x61, (n >> 8) & 0xFF, n & 0xFF,    // PUSH2 n        (bytecode length)
  0x60, 0x0E,                          // PUSH1 14       (offset: bytecode starts after 14-byte header)
  0x60, 0x00,                          // PUSH1 0        (memory destination)
  0x39,                                // CODECOPY       (copy bytecode from code[14..] to memory[0..])
  0x61, (n >> 8) & 0xFF, n & 0xFF,    // PUSH2 n        (bytecode length)
  0x60, 0x00,                          // PUSH1 0        (memory offset)
  0xF3                                 // RETURN         (return bytecode from memory)
]
```

## Rationale

### Why Verifier Contracts?

Key storage and signature verification have fundamentally different upgrade characteristics. Storage is mechanical — `(verifier, public_key)` in deterministic slots works on any EVM chain. But if verification logic were bundled into the storage contract, it would freeze at deploy time with no permissionless upgrade path.

Separating them means new algorithms are deployed as new verifier contracts without touching the storage layer. The uniform `IAuthVerifier.verify()` interface eliminates registration, wallet callbacks, and special casing — the verifier address in `key_config` is the sole identifier for authentication logic. The storage contract is pure Solidity (SLOAD/SSTORE-dominated, no gas benefit from a precompile).

**Storage layout is consensus-critical**: Because the protocol reads storage slots directly on 8130 chains, the keccak-derived slot layout becomes a consensus rule. The layout is intentionally simple (keccak-derived, fixed-size slots per key) to minimize the likelihood of future changes — the same commitment that [EIP-7702](./eip-7702.md) makes with its delegation designator format.

### Why a Nonce Precompile?

Nonce state is isolated in a dedicated precompile (`NONCE_MANAGER_ADDRESS`) rather than stored alongside key configurations in the Account Configuration Contract. This separation is motivated by their fundamentally different access patterns and portability requirements:

| Property | Key Config | Nonces |
|----------|-----------|--------|
| Write frequency | Rare (key rotation) | Every AA transaction |
| Read frequency | Every validation | Every validation |
| Growth | Rare (gas-bounded) | Unbounded (nonce channels) |
| EVM writes | Yes (`authorizeKey`, `revokeKey`, etc.) | No (protocol-only increments) |
| Portability | Required (for non 8130 chains) | Not required (8130-only) |

**Why a precompile instead of a system contract?** Unlike the Account Configuration Contract — which must be a full Solidity contract for cross-chain portability and EVM-writable key management — the Nonce Manager has no EVM-writable state and no portability requirement. Nonce increments are exclusively protocol-level operations.

**Modularity**: The precompile is minimal — a single read function backed by protocol-managed storage. This clean separation means nonce logic can evolve independently, and the precompile could potentially be reused by other transaction types or systems.

### Why CREATE2 for Account Initialization?

Account initialization uses the CREATE2 address formula with `ACCOUNT_CONFIG_ADDRESS` as the deployer address for cross-chain portability:

1. **Deterministic addresses**: Same `user_salt + bytecode + initial_keys` produces the same address on any chain
2. **Pre-deployment funding**: Users can receive funds at counterfactual addresses before account creation
3. **Portability**: Same `deployment_code` produces the same address on both 8130 and non-8130 chains (see [Address Derivation](#address-derivation))
4. **Front-running prevention**: `initial_keys` in the salt prevents attackers from deploying with different keys (see [Account Initialization](#account-initialization))

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `authorizeKey()` on the Account Configuration Contract to authorize existing signing keys (K1, P256, etc.)
2. **Upgrade wallet logic**: Update contract to delegate `isValidSignature` to the appropriate verifier contract, and call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

### Why Verifier Addresses Instead of Auth Type Bytes?

Earlier designs used a 1-byte `auth_type` to identify signature algorithms. This created a protocol-managed registry of algorithms that required hard forks to extend. The verifier address model replaces this with a permissionless system:

- **Extensibility**: New algorithms are deployed as verifier contracts — permissionless, no protocol change needed.
- **Uniformity**: All configured key signatures use the same `keyId || signature_data` format. The verifier address in storage determines parsing.
- **Consistency**: The Account Configuration Contract calls all verifiers through `IAuthVerifier.verify()`, whether ecrecover, P256, BLS, or a post-quantum scheme.

### Why Two-Phase Execution (`committed_calldata` + `calldata`)?

The `committed_calldata` frame persists regardless of what happens in `calldata`, enabling three patterns:

- **Sponsor payment**: A sponsor's required action (e.g., token transfer) survives even if the user's `calldata` reverts — robust permissioned sponsorship without protocol-level token awareness.
- **Deferred gas deduction**: A self-paying sender with insufficient balance can acquire ETH during `committed_calldata` (e.g., via a token swap) — gas deduction defers to after this frame.
- **Account initialization**: Setup logic in `committed_calldata` persists even if `calldata` reverts, ensuring account state is never left partially initialized.

### Why a Default Account?

EOAs sending AA transactions need code to interpret calldata. Without a default, every EOA must explicitly include an `authorization_list` entry on their first AA transaction to delegate to a wallet implementation — an extra step that adds friction and requires wallet-level decisions before the first transaction.

The default account predeploy at `DEFAULT_ACCOUNT_ADDRESS` eliminates this: if an EOA sends an AA transaction with no code set, the protocol writes a standard [EIP-7702](./eip-7702.md) delegation (`0xef0100 || DEFAULT_ACCOUNT_ADDRESS`). The account immediately functions as a smart wallet that defers authentication to the Account Configuration key infrastructure and interprets calldata for execution. The expected interface is minimal: `executeBatch` for call interpretation, `isValidSignature` for ERC-1271 compatibility, and receive/fallback handlers for ETH and token transfers.

EOAs that prefer a custom wallet implementation can override the default at any time via `authorization_list` or a standard [EIP-7702](./eip-7702.md) transaction. Because the delegation is a standard 7702 designator, all existing tooling (block explorers, `EXTCODESIZE`, delegation resolution) works without modification.

### Why an Account Policy Slot?

Single read for account level policies. Currently only used so the node can have garantees to grant high throughput to certain accounts. 

### Why Pack Policy Fields in key_config?

All key policy fields — verifier, expiration, spend mode, gas limit, and verifier data — fit in a single 32-byte storage slot (see [Appendix: Storage Layout](#appendix-storage-layout)). This means the protocol reads everything it needs for authorization, expiration, and gas policy checks in one SLOAD — zero additional storage cost for policy enforcement. The `verifierData` byte gives verifiers 1 byte of mutable configuration at no extra read cost, while the reserved bits in the `policy` byte provide an extension path for future protocol flags.

### Why These Initial Well-Known Verifiers?

The well-known verifier set is intentionally minimal: K1, P256_RAW, P256_WEBAUTHN, and DELEGATE. Other algorithms (BLS, post-quantum, etc.) start as sandbox verifiers.

- **K1**: Already built into the protocol for EOA signature recovery. Zero marginal implementation cost.
- **P256_RAW / P256_WEBAUTHN**: The high-volume path for P-256 accounts (raw ECDSA) and passkey-based accounts (WebAuthn). The ~200-600 gas savings per transaction over a sandbox verifier wrapping the P256VERIFY precompile (RIP-7212) compounds at at scale.
- **DELEGATE**: Reads another account's key configuration from storage — fundamentally incompatible with the sandbox pure-function model.

Algorithms like BLS12-381 can be deployed as sandbox verifiers wrapping EIP-2537 precompiles. Because verifiers are deployed as deterministic CREATE2 contracts (not precompiles), promotion to well-known status is seamless for accounts: the protocol recognizes the existing contract address and switches to native execution. No key re-registration or migration is required. Post-quantum schemes, ZK-proof-based auth, and exotic curves follow the same path.

### Why a Versioned Sandbox Interface?

The sandbox interface (v0) is intentionally minimal: pure authentication with no transaction context or state access. The version byte in the sandbox header reserves a forward-compatible extension path without committing to a specific design.

## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys. EOAs are automatically delegated to `DEFAULT_ACCOUNT_ADDRESS` on their first AA transaction if no code is set; explicit [EIP-7702](./eip-7702.md) delegation or `account_initialization` can be used for custom wallet implementations

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        address verifier;
        bytes publicKey;
        uint8 policy;
        uint32 expiration;
        uint48 gasSpendLimit;
        uint8 verifierData;
    }
    
    struct KeyOperation {
        uint8 opType;       // 0x01 = authorizeKey, 0x02 = revokeKey
        address verifier;
        bytes publicKey;
        uint8 policy;
        uint32 expiration;
        uint48 gasSpendLimit;
        uint8 verifierData;
    }

    event KeyAuthorized(address indexed account, bytes20 indexed keyId, address verifier, uint8 policy, uint32 expiration, uint48 gasSpendLimit, uint8 verifierData, bytes publicKey);
    event KeyRevoked(address indexed account, bytes20 indexed keyId);
    event AccountCreated(address indexed account, bytes32 userSalt, bytes32 codeHash);
    event KeyChangeApplied(address indexed account, uint64 sequence);
    event AccountLocked(address indexed account, uint32 unlockDelay);
    event UnlockRequested(address indexed account, uint32 effectiveAt);
    event AccountUnlocked(address indexed account);
    
    // Account creation (factory)
    function createAccount(bytes32 userSalt, bytes calldata bytecode, AuthKey[] calldata initialKeys) external returns (address);
    function getAddress(bytes32 userSalt, bytes calldata bytecode, AuthKey[] calldata initialKeys) external view returns (address);
    
    // Key management (msg.sender only)
    function authorizeKey(address verifier, bytes calldata publicKey, uint8 policy, uint32 expiration, uint48 gasSpendLimit, uint8 verifierData) external returns (bytes20 keyId);
    function revokeKey(bytes20 keyId) external;
    function setPolicy(bytes20 keyId, uint8 policy, uint48 gasSpendLimit) external;
    function setExpiration(bytes20 keyId, uint32 expiration) external;
    function setVerifierData(bytes20 keyId, uint8 data) external;
    
    // Portable key changes (calls IAuthVerifier(verifier).verify() for authorizer)
    function applyKeyChange(address account, uint64 chainId, uint64 sequence, KeyOperation[] calldata operations, bytes calldata authorizerAuth) external;
    function getKeyChangeSequence(address account, uint64 chainId) external view returns (uint64);
    
    // Account policy (msg.sender only)
    function lock(uint32 unlockDelay) external;
    function requestUnlock() external;
    function unlock() external;
    
    // Read functions
    function isAuthorized(address account, bytes20 keyId) external view returns (bool);
    function getKeyData(address account, bytes20 keyId) external view returns (address verifier, uint8 policy, uint32 expiration, uint48 gasSpendLimit, uint8 verifierData, bytes memory publicKey);
    function getAccountPolicy(address account) external view returns (bool locked, uint32 unlockDelay, uint32 unlockRequestedAt);
    
    // Transaction context (8130 only — reads from transient storage)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (bytes20 keyId, address verifier, uint8 policy, uint32 expiration, uint48 gasSpendLimit, uint8 verifierData, bytes memory publicKey);
}
```

### IAuthVerifier

```solidity
interface IAuthVerifier {
    function verify(
        address account,
        bytes20 keyId,
        bytes calldata publicKey,
        uint8 verifierData,
        bytes32 hash,
        bytes calldata signature
    ) external view returns (bool);
}
```

### INonceManager (Precompile)

```solidity
interface INonceManager {
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
}
```

Read-only. The protocol manages nonce storage directly; there are no state-modifying functions.

## Security Considerations

**Enshrined Validation**: Well-known verifiers use native implementations; sandbox verifiers are pure functions with declared gas limits (see [Sandbox Verifiers](#sandbox-verifiers)). Deterministic results eliminate invalidation-based DoS without requiring a reputation system.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify keys via local EVM calls; portable key changes require signature authorization. EOA key is implicitly authorized by default; revocable via `revokeKey` (cross-chain portable). Accounts SHOULD have at least one configured key before revoking the EOA key. Per-key `expiration` and `spendMode` provide protocol-enforced time limits and gas spending controls (see [Appendix: Storage Layout](#appendix-storage-layout)); cumulative spend tracking is handled by wallet code. `MAX_KEY_CHANGES` bounds per-transaction processing cost; `KEY_CHANGE_TYPE` domain separation prevents authorizer signatures from being reused as transaction signatures.

**Delegation**: See [DELEGATE](#delegate) for hop limits and nested signature rules. The DELEGATE verifier enforces a 1-hop limit at both protocol and contract level.

**Payer Security**: `AA_TX_TYPE` vs `AA_PAYER_TYPE` domain separation prevents signature reuse between sender and payer roles. The `payer_commitment` field in the sender's signed hash binds to a specific payer (committed) or permits any sponsor (open). The payer's auth mechanism (`payer_auth` type byte) is independent of the commitment mode.

**Deferred Gas Deduction**: When self-pay defers gas deduction to after `committed_calldata`, block builders bear the risk of unpaid computation. Builders/mempools can mitigate via simulation, gas limits on the `committed_calldata` frame, or allowlists.

**Signature Size Limits**: Signatures exceeding `MAX_SIGNATURE_SIZE` MUST be rejected to prevent DoS via oversized signatures.

**Account Lock**: The lock mechanism (see [Account Lock](#account-lock)) provides a protocol-enforced guarantee that keys cannot change. ETH movement restrictions are enforced by wallet bytecode and key restrictions. The `unlockDelay` timelock gives nodes a window to observe `unlock_requested_at` becoming non-zero and stop accepting high-rate transactions before the lock is removed. Nodes SHOULD treat any non-zero `unlock_requested_at` as equivalent to unlocked for mempool acceptance purposes.
**Account Initialization Security**: `initial_keys` are salt-committed, preventing front-running. Permissionless deployment via `createAccount()` is safe — even if front-run, the account is created with the owner's keys. Wallet bytecode should be inert when uninitialized.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
