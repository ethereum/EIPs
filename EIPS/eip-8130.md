---
eip: 8130
title: Account Abstraction by Account Configuration
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 2718
---

## Abstract

This proposal introduces a standardized validation mechanism for account abstraction using onchain account configurations to define accepted authorizations for an account. Unlike EIP-7701/RIP-7560 which permit arbitrary validation code, this approach restricts validation to predefined auth types, ensuring protocol simplicity and secure account abstraction without EVM execution during validation. A new transaction type leverages this mechanism with native gas abstraction support.

## Motivation

Enable account abstraction benefits—batching, gas sponsorship, custom authentication, programmable logic—while allowing nodes to validate transactions via simple state checks without EVM execution. This enables highly optimizable and performant transaction validation and mempool implementations and removes the need for additional reputation systems to ensure DoS prevention.

Having the account auth configurations accessible and manageable via the EVM enables accounts to build out any additional recovery mechanisms they desire. Calldata delivery to the account address only means the wallet can build out any additional checks for validation they desire.

### Existing Solutions

| Solution | Approach | Limitations |
|----------|----------|-------------|
| ERC-4337 | Application-layer abstraction | Complex mempool rules (ERC-7562), high gas overhead, entrypoint costs |
| [EIP-7701](./eip-7701.md) | Protocol-level with arbitrary validation | Complex mempool rules, major protocol changes, reputation systems |

This proposal addresses these by:

- **Simplifying Validation**: Predefined auth types eliminate EVM execution during validation
- **Optimizable Mempool and Validation Logic**: Validators use only state lookups, mempools can invalidate transactions quickly via (flash)block access lists.
- **Reducing Gas Costs**: No entrypoint contracts or associated overhead for standard transaction flow
- **Ensuring Extensibility**: Supports future quantum-safe algorithms via new auth types, and a `fee_token` field for future token-based gas payment
- **Maintaining Compatibility**: Coexists with EIP-7702 and ERC-4337

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD | [EIP-2718](./eip-2718.md) transaction type |
| `AA_PAYER_TYPE` | TBD | Magic byte for payer signature domain separation |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_ADDRESS` | TBD | Account Configuration system contract address |
| `NONCE_MANAGER_ADDRESS` | TBD | Nonce Manager system contract address |
| `KEY_CHANGE_TYPE` | TBD | Magic byte for key change signature domain separation |
| `MAX_KEY_CHANGES` | 10 | Maximum key change entries per transaction |
| `MAX_SIGNATURE_SIZE` | 2048 | Maximum signature size in bytes (DoS prevention) |

### Account Types

This proposal supports three paths for accounts to use AA transactions:

| Account Type | How It Works | Key Recovery |
|--------------|--------------|--------------|
| **Existing Smart Contracts** | Already-deployed accounts (e.g., ERC-4337 wallets) register keys via `authorizeKey()` on the system contract | Wallet-defined |
| **EOAs via EIP-7702** | EOAs set delegation to a smart wallet implementation, then register keys | EOA key always authorized |
| **New Accounts (No EOA)** | Deploy via `account_initialization` with CREATE2; keys configured at deployment | Wallet-defined |

**Existing smart contracts** can migrate to native AA without redeployment by registering their signing keys with the system contract.

**EOAs** can adopt AA features by either: (1) using EIP-7702 to delegate to a smart wallet, or (2) on chains with a configured default account, submitting AA transactions directly.

**New accounts without an EOA** are created via the `account_initialization` field, deploying wallet bytecode and configuring keys in a single transaction.

### Auth Types

| Auth Type | ID | Algorithm | Public Key Size | Signature Size | keyId Derivation | Intrinsic Gas |
|----------|-----|-----------|-----------------|----------------|------------------|---------------|
| `K1` | `0x01` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | `keccak256(x \|\| y)[12:]` | 6000 |
| `R1` | `0x02` | secp256r1 / P-256 | 33/65 bytes | 64 bytes | `keccak256(x \|\| y)[12:]` | 7000 |
| `WEBAUTHN` | `0x03` | WebAuthn / Passkey | 65 bytes | Variable (max 2KB) | `keccak256(x \|\| y)[12:]` | 12000 + calldata_gas |
| `BLS` | `0x04` | BLS12-381 | 48 bytes | 96 bytes | `keccak256(pubkey)[12:]` | 8000 |
| `DELEGATE` | `0x05` | Delegated validation | 20 bytes (address) | Nested signature | `keccak256(address)[12:]` | 1000 + delegated |

All key types derive `keyId` as the last 20 bytes of `keccak256(public_key_material)`. For K1, R1, and WebAuthn, the input is the uncompressed point `(x, y)` as 64 bytes — for K1 this is the standard Ethereum address, so ecrecover directly returns the keyId and an EOA's own key has `keyId == account address`. R1 and WebAuthn share the same derivation since they use the same curve (P-256); the same physical key has the same keyId regardless of auth type. Cross-type collisions between different key sizes (64, 48, 20 bytes) are prevented by distinct hash inputs.

**WebAuthn Gas Calculation**: The `calldata_gas` component charges 16 gas per non-zero byte and 4 gas per zero byte of the WebAuthn signature data (authenticatorData + clientDataJSON). This accounts for variable signature sizes while the 2KB (`MAX_SIGNATURE_SIZE`) cap prevents DoS attacks via oversized signatures.

**DELEGATE**: Delegates validation to another account's configuration. The `key_data` stores the delegated account's address (20 bytes). Only 1 hop is permitted—if the delegated account's signing key is also a `DELEGATE` type, validation fails. See [DELEGATE Signature Format](#delegate-signature-format) for signature structure.

**BLS**: Enables signature aggregation which can be used to reduce data availability costs for rollups and L2s. (Implementation outside of this scope.)

### Account Configuration

Each account can authorize a set of keys through the Account Configuration Contract at `ACCOUNT_CONFIG_ADDRESS`. Keys are identified by their `keyId`, a 20-byte content-derived identifier (see [Auth Types](#auth-types) for per-type derivation).

Only `msg.sender` can modify their own key configuration within EVM execution. Keys can also be modified via portable key changes (see [Cross-Chain Key Changes](#cross-chain-key-changes)), which enable cross-chain key portability. This enables existing ERC-4337 smart accounts to register keys and migrate to native AA without redeployment.

**Default behavior**: An empty configuration means only the account's EOA key can authorize transactions. The EOA's own key has `keyId == from`, so the protocol checks this directly. The EOA key always retains authorization regardless of configured keys, ensuring recovery capability (for EOA-based accounts). Note that this feature will likely be removed in any sort of quantum migration in a future EIP.

#### Storage Layout

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_ADDRESS)

Key struct (consecutive slots per keyId):
  keccak256(keyId || base_slot) + 0: key_type (uint8) — non-zero = authorized
  keccak256(keyId || base_slot) + 1: public_key bytes [0:32]
  keccak256(keyId || base_slot) + 2: public_key bytes [32:] (if > 32 bytes)

Key change sequence:
  keccak256(base_slot || "key_sequence"): latest applied sequence (uint64)
```

The protocol validates signatures by reading these slots directly — no arbitrary EVM execution during validation.

Key enumeration is performed off-chain via `KeyAuthorized` / `KeyRevoked` event logs rather than on-chain storage, eliminating the gas overhead of maintaining an enumeration array. No key count or limit is enforced on-chain—since keys are stored in a content-addressed mapping and validation only reads the specific signing key (O(1)), gas costs naturally bound key creation.

#### 2D Nonce Storage

Nonce state is managed by a separate system contract at `NONCE_MANAGER_ADDRESS`, isolating high-frequency nonce writes from the Account Configuration Contract's key storage (see [Why a Separate Nonce Contract?](#why-a-separate-nonce-contract)).

```
Contract: NONCE_MANAGER_ADDRESS

Base slot: keccak256(account_address || NONCE_MANAGER_ADDRESS)
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

The protocol reads and increments nonce slots directly during AA transaction processing. Only the protocol may increment nonces; there is no public `increment` function.

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,               // Sender address (20 bytes) | empty for EOA signature
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp or block number 
  max_priority_fee_per_gas,
  max_fee_per_gas,
  gas_limit,
  authorization_list, 
  account_initialization,  // For deploying new accounts if not using 7702 | empty
  key_changes,        // Replayable cross-chain key change operations | empty
  calldata,
  sender_auth,
  fee_token,          // bytes: 0x for ETH, otherwise reserved
  payer_auth          // K1 signature (65 bytes) | empty
])
```

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address. **Required** for configured key signatures (`0xFF` prefix). **Optional** (empty) for EOA signatures—address recovered via ecrecover. |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Transaction invalid after this Unix timestamp |
| `max_priority_fee_per_gas` | Priority fee per gas unit (EIP-1559) |
| `max_fee_per_gas` | Maximum fee per gas unit (EIP-1559) |
| `gas_limit` | Maximum gas |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list |
| `account_initialization` | **Empty**: No account deployment. **Non-empty**: See [Account Initialization](#account-initialization) |
| `key_changes` | **Empty**: No key changes. **Non-empty**: Array of signed key change operations. See [Cross-Chain Key Changes](#cross-chain-key-changes) |
| `calldata` | Data delivered to `from` account |
| `sender_auth` | See [Signature Format](#signature-format) |
| `fee_token` | **Empty (0x)**: Gas paid in ETH. **Non-empty**: Reserved for future token payment EIPs |
| `payer_auth` | **65 bytes**: K1 signature, payer recovered via ecrecover. **Empty**: `from` pays ETH |

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + sender_key_cost + calldata_cost + nonce_key_cost + init_code_cost + key_changes_cost
```

| Component | Value |
|-----------|-------|
| `nonce_key_cost` | 22,100 gas for first use of a `nonce_key` (cold SLOAD + SSTORE set), 5,000 gas for existing keys (cold SLOAD + warm SSTORE reset) |
| `init_code_cost` | 0 if `account_initialization` empty. Otherwise: 32,000 (CREATE2 base) + `init_code` calldata gas + code deposit cost (200 gas per deployed byte) |
| `key_changes_cost` | Per applied entry: 5,000 (signature verification) + `num_operations` × 20,000 per SSTORE for key struct slots. Per skipped entry (already applied): 2,100 (SLOAD to check sequence). 0 if `key_changes` empty |

The `nonce_key_cost` ensures 2D nonce channels incur appropriate storage costs in the Nonce Manager contract:

- **New key**: Cold SLOAD (2,100) to check current value + SSTORE set (20,000) for 0→non-zero = 22,100 gas
- **Existing key**: Cold SLOAD (2,100) to read current nonce + warm SSTORE reset (2,900) to increment = 5,000 gas

#### Signature Format

**EOA key**: Raw 65-byte ECDSA signature `(r || s || v)`. When using an EOA signature, the `from` field may be empty—the sender address is recovered via ecrecover.

**Configured key signatures** use the `0xFF` prefix to distinguish from EOA signatures. A **format byte** after `0xFF` selects between two paths:

- `0xFF || 0x00 || r,s,v (65 bytes)` — **K1 compact path** (ecrecover)
- `0xFF || 0x01 || keyId (20 bytes) || signature_data` — **keyId path** (storage lookup)

Both require `from` to be set (non-empty) so the protocol knows which account to validate against.

| Key Type | Signature Format | Total Size | Protocol Reads |
|----------|-----------------|------------|----------------|
| K1 | `0xFF \|\| 0x00 \|\| r,s,v (65)` | 67 bytes | 1 SLOAD (ecrecover → keyId → auth check) |
| R1 | `0xFF \|\| 0x01 \|\| keyId (20) \|\| r,s (64)` | 86 bytes | 2-3 SLOADs (key_type + pubkey from struct) |
| WebAuthn | `0xFF \|\| 0x01 \|\| keyId (20) \|\| authenticator_data \|\| client_data_json \|\| r,s` | Variable | 2-3 SLOADs (key_type + pubkey from struct) |
| BLS | `0xFF \|\| 0x01 \|\| keyId (20) \|\| sig (96)` | 118 bytes | 2 SLOADs (key_type + pubkey from struct) |
| DELEGATE | `0xFF \|\| 0x01 \|\| keyId (20) \|\| nested_signature` | Variable | 2 SLOADs (key_type + delegate address from struct) |

**K1 compact path** (`0x00`): ecrecover on `(r, s, v)` directly returns the keyId (Ethereum address). The protocol checks the key struct at slot +0 (`key_type > 0`) or `keyId == from` for EOA default authorization. Only 1 SLOAD — the most gas-efficient path. K1 configured keys MAY also use the keyId path if preferred.

**keyId path** (`0x01`): The protocol reads 20 bytes as keyId, looks up the key struct. Reads `key_type` from slot (authorization check + type identification), then reads the public key from slots. Verifies the signature against the stored public key. Used for K1 (optional), R1, WebAuthn, BLS, and DELEGATE key types.

##### DELEGATE Signature Format

For `DELEGATE` keys, the key struct stores the delegate account address (20 bytes) as the public key. The `signature_data` contains a nested signature for the delegated account:

```
0xFF || 0x01 || keyId (20 bytes) || nested_signature
```

Where `nested_signature` is a valid configured key or EOA signature for the delegated account. The protocol reads the key struct, finds `key_type = DELEGATE` and the delegate address, then validates `nested_signature` against the delegated account's configuration. Only 1 hop is permitted.

**Example**:

- Account A has K1 pubkey authorized
- Account B has DELEGATE to Account A authorized (keyId = `0xbbbb...`)
- Valid signature for Account B: `0xFF || 0x01 || 0xbbbb... || 0xFF || 0x00 || ecdsa_sig`

The protocol reads B's key struct at `0xbbbb...`, finds DELEGATE → Account A, then validates the nested K1 signature `0xFF || 0x00 || ecdsa_sig` against Account A's config (ecrecover → keyId → auth check). The nested signature could also be Account A's standard EOA signature (no `0xFF` prefix).

#### Signature Payload

Sender and payer use different type bytes for domain separation, preventing signature reuse attacks:

**Sender signature hash**:

```
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, calldata, fee_token
]))
```

**Payer signature hash** (when sponsoring):

```
keccak256(AA_PAYER_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, calldata, fee_token
]))
```

The different type bytes (`AA_TX_TYPE` vs `AA_PAYER_TYPE`) ensure cryptographic domain separation—a valid sender signature cannot be replayed as a payer signature and vice versa.

#### Payer Modes

Gas payment supports two modes based on the `payer_auth` field:

| Mode | `payer_auth` | Gas Payer | Description |
|------|--------------|-----------|-------------|
| **Self-pay** | Empty | `from` | Sender pays gas in ETH from their own balance |
| **Sponsored** | 65-byte K1 signature | Payer (ecrecover) | Payer signs each transaction, authorizing gas payment for this specific transaction. Suitable for paymasters and trusted sponsors. |

#### Fee Token Field

The `fee_token` field enables future token-based gas payment mechanisms. In this specification, it MUST be empty bytes (`0x`). When empty, gas is paid in ETH by either the sender (self-pay) or payer (sponsored). Nodes MUST reject transactions where `fee_token` is non-empty until a future EIP defines valid formats.

### Account Initialization

New smart contract accounts can be deployed with pre-configured keys in a single transaction using the `account_initialization` field:

```
account_initialization = rlp([
  user_salt,          // bytes32: User-chosen uniqueness factor
  init_code,          // bytes: Contract creation bytecode
  initial_keys        // Array of AuthKey structs
])
```

#### Address Derivation

Addresses are derived using CREATE2 with the Account Configuration Contract (`ACCOUNT_CONFIG_ADDRESS`) as the deployer. The `initial_keys` are sorted by `keyId` before hashing to ensure address derivation is order-independent (the same set of keys always produces the same address regardless of the order specified):

```
sorted_keys = sort(initial_keys, by: keyId)
effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(sorted_keys))))
address = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(init_code))[12:]
```

The `initial_keys` are incorporated into the salt to prevent front-running attacks where an attacker deploys with different keys. Users can receive funds at counterfactual addresses before deployment.

#### Validation (Account Initialization)

When `account_initialization` is non-empty:

1. Parse `[user_salt, init_code, initial_keys]`
2. Sort `initial_keys` by keyId: `sorted_keys = sort(initial_keys, by: keyId)`
3. Compute `effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(sorted_keys))))`
4. Compute `expected = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(init_code))[12:]`
5. Require `from == expected`
6. Require `code_size(from) == 0` (account not yet deployed)
7. Validate `sender_auth` against one of `initial_keys` (keyId extracted from signature must match an entry's computed keyId)

#### Execution (Account Initialization)

1. Register `initial_keys` in Account Config storage for `from`: for each key, compute `keyId`, write key_type and public_key to the key struct slots
2. Apply `key_changes` (if non-empty) — see [Cross-Chain Key Changes](#cross-chain-key-changes)
3. Deploy `init_code` at `from` using CREATE2 semantics with `effective_salt`
4. Proceed with calldata delivery

Key registration and key changes are applied before code deployment so that the constructor can read its own key configuration from the Account Config contract if needed.

#### Default Account (Chain Operator Option)

For EOA accounts, chain operators may configure a **default account**—a wallet implementation automatically used for addresses without deployed code. This enables EOAs to submit AA transactions and use AA features (batching, gas sponsorship) without explicitly deploying code via EIP-7702.

**Behavior**:

- EOA submits AA transaction with valid signature
- During execution, if `from` has no code, use the configured default account bytecode
- The default account interprets `calldata` (e.g., as batched calls)
- Code injection occurs at transaction time; no permanent deployment required

**Configuration**: Chain operators specify the default account bytecode hash. This is an optional feature—chains may require explicit 7702 delegation instead.

### Cross-Chain Key Changes

The `key_changes` field enables cross-chain portable key management. Key change operations are signed without `chain_id`, allowing them to be replayed on any chain to synchronize key state.

#### Key Change Format

```
key_changes = [
  rlp([
    sequence,           // uint64: monotonic ordering (0, 1, 2, ...)
    operations,         // Array of key operations
    authorizer_auth     // Signature from a key valid at this sequence
  ]),
  ...  // max MAX_KEY_CHANGES entries per transaction
]

operation = rlp([
  op_type,              // 0x01 = authorizeKey, 0x02 = revokeKey
  key_type,             // uint8: auth type
  public_key            // bytes: public key material
])
```

Each entry represents a set of key operations authorized at a specific sequence number. The `authorizer_auth` must be valid against the account's key configuration *at the point after all previous entries in the list have been applied*.

#### Key Change Signature Payload

Key change signatures use domain separation via `KEY_CHANGE_TYPE` and intentionally omit `chain_id` to enable cross-chain replay:

```
keccak256(KEY_CHANGE_TYPE || rlp([
  account_address,
  sequence,
  operations
]))
```

The `authorizer_auth` follows the same [Signature Format](#signature-format) as `sender_auth` (EOA or configured key), validated against the account's key state at that point in the sequence.

#### Processing

Key changes are processed after initial key registration (if any) and before code deployment:

1. Read the account's current `key_change_sequence` from the Account Config Contract
2. For each entry in `key_changes` (must be ordered by sequence):
   - If `entry.sequence <= current_sequence`: skip (already applied, charge 2,100 gas for SLOAD check)
   - If `entry.sequence != current_sequence + 1`: reject transaction (gap in sequence)
   - Validate `authorizer_auth` against current key state
   - Apply each operation:
     - `authorizeKey`: compute `keyId`, write key_type and public_key to the key struct slots
     - `revokeKey`: compute `keyId`, clear the key struct slots to zero
   - Increment `key_change_sequence`

During mempool validation, key changes are simulated (not applied) to determine the resulting key state, then `sender_auth` is validated against that state.

#### Key Change Paths

Keys can be modified through three paths:

| | Portable: `key_changes` (tx field) | Portable: `applyKeyChange()` (EVM) | Local: `authorizeKey()` / `revokeKey()` (EVM) |
|--|---|---|---|
| Authorization | Signed operation (any auth type) | Signed operation (any auth type) | `msg.sender` during execution |
| Portability | Cross-chain replayable (no chain_id) | Cross-chain replayable (no chain_id) | Chain-local only |
| Sequence | Increments `key_change_sequence` | Increments `key_change_sequence` | Does NOT affect `key_change_sequence` |
| When processed | Before code deployment (8130 only) | During EVM execution (any chain) | During EVM execution |

**Portable key changes** (`key_changes` tx field or `applyKeyChange()`) use the same signed operations and the same `key_change_sequence` counter. The wallet signs a key change once, and it can be submitted via either path on any chain. `applyKeyChange()` validates the authorizer signature against the account's key state, applies the operations, and increments the sequence — identical behavior to protocol-level `key_changes` processing.

**Local key changes** (`authorizeKey()` / `revokeKey()`) require `msg.sender` authorization and do **not** increment the `key_change_sequence`. These are chain-local customizations (e.g., session keys, chain-specific authorizations). When portable key changes are replayed on a new chain, they write to specific keyIds, potentially overwriting local changes at those same keyIds.

#### Example: Cross-Chain Key Sync

Account deployed on Chain X with Owner A. Owner rotates to Owner B on Chain X. Six months later, user wants to deploy and use the account on Chain Y (only has Owner B's key):

```
Transaction on Chain Y:
  account_initialization: [user_salt, init_code, [AuthKey(K1, pubkey_A)]]
  key_changes: [
    {
      sequence: 0,
      operations: [
        {op: revokeKey, key_type: K1, public_key: pubkey_A},
        {op: authorizeKey, key_type: K1, public_key: pubkey_B}
      ],
      authorizer_auth: <signed by Owner A at the time of rotation>
    }
  ]
  sender_auth: <signed by Owner B>
  calldata: <send USDC>
```

Processing: register initial_keys (Owner A) → apply key_changes (Owner A → Owner B) → validate sender_auth against Owner B ✓ → deploy account → execute calldata.

### Execution

#### Calldata Delivery

The `calldata` is delivered to `from` via self-call:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `from` |
| `msg.value` | 0 |
| `data` | `calldata` |

For EOAs without code, the call succeeds with no effect. For smart accounts, execution begins at the contract's entry point.

#### Validation vs Execution

This proposal constrains **validation** to enshrined auth types but does not constrain **execution**. Once a transaction passes validation, the account's code can implement any logic: multisig, timelocks, spending limits, session keys, or arbitrary business rules. The `calldata` is always delivered to `from` as a self-call, ensuring wallet code controls interpretation.

**Multisig at EVM layer**: Native multisig is intentionally not included in this specification. Accounts requiring multisig validation can implement it in their smart contract code by verifying additional signatures within the `calldata`. The wallet can use `getCurrentSigner()` from the system contract to identify which key authorized the transaction, then require additional co-signers to have signed the `calldata` before executing operations.

#### Transaction Context

During execution, accounts can query the system contract for:

- **Payer**: `getCurrentPayer()` returns the gas payer address
- **Signer**: `getCurrentSigner()` returns `(keyId, keyType, publicKey)` used for authorization

### Portability

Both system contracts—the Account Configuration Contract (`ACCOUNT_CONFIG_ADDRESS`) and the Nonce Manager (`NONCE_MANAGER_ADDRESS`)—are standard Solidity contracts deployed at designated addresses. The same contracts are deployed on both 8130 and non-8130 chains:

- **On non-8130 chains**: The contracts operate as standard smart contracts. `createAccount()` works as an unstaked factory compatible with ERC-4337. Key management functions (`authorizeKey()`, `revokeKey()`, `applyKeyChange()`) and nonce queries (`getNonce()`) operate normally through EVM execution. Crucially, `applyKeyChange()` enables portable key changes on any chain — wallets sign once and submit via EVM.
- **On 8130 chains**: The identical Solidity contracts remain deployed and callable. The protocol additionally reads their storage slots directly during AA transaction validation — no EVM execution required. The protocol may populate storage (e.g., key configurations from `account_initialization`, nonce increments) at the struct level during transaction processing, but the contracts' EVM interfaces remain the canonical way for accounts to manage their configuration.

This enables:

- Same addresses and same contracts across all chains
- Portable key changes via `applyKeyChange()` on any EVM chain, or via `key_changes` tx field on 8130 chains — one signature works for both
- Compatibility with ERC-4337 as an unstaked factory on any chain
- Progressive upgrade path as chains adopt 8130 (no contract changes needed)

### Validation Flow

#### Mempool Acceptance

1. Verify `sender_auth` size does not exceed `MAX_SIGNATURE_SIZE` (2KB)
2. Verify `key_changes` length does not exceed `MAX_KEY_CHANGES`
3. Resolve sender address:
   - If `from` is non-empty: use provided address
   - If `from` is empty: recover address from `sender_auth` via ecrecover (EOA signature required)
4. Determine the effective key state for `sender_auth` validation:
   a. If `account_initialization` is non-empty:
      - Parse `[user_salt, init_code, initial_keys]`
      - Verify address derivation matches `from` (see [Account Initialization](#account-initialization))
      - Verify `code_size(from) == 0`
      - Start with `initial_keys` as the key state
   b. Else: read current key state from Account Config storage
5. If `key_changes` is non-empty:
   - Simulate applying `key_changes` to the key state (validate authorizer signatures, apply operations in sequence, skip already-applied entries)
6. Validate `sender_auth` against the **resulting** key state:
   - EOA signature: ecrecover → keyId, check authorization or `keyId == from` for EOA default
   - Configured key (`0xFF` prefix): extract keyId from signature, read key struct from Account Config, verify signature
7. Resolve payer from `payer_auth`:
   - 65 bytes: recover address via ecrecover (using `AA_PAYER_TYPE` for domain separation)
   - Empty: sender pays ETH
8. Verify `fee_token` is empty (reject if non-empty until future EIPs define valid formats)
9. Verify nonce (read from Nonce Manager), payer ETH balance, expiry
10. Mempool threshold: payer's pending sponsored transaction count must be below node-configured limits

#### Block Execution

1. ETH gas deduction from payer
2. Increment nonce in Nonce Manager storage
3. Process authorization_list (EIP-7702)
4. Register `initial_keys` in Account Config storage (if `account_initialization` non-empty)
5. Apply `key_changes` to Account Config storage (if non-empty)
6. Deploy `init_code` at `from` (if `account_initialization` non-empty)
7. Deliver calldata to `from` via self-call

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels. Reads from the Nonce Manager contract at `NONCE_MANAGER_ADDRESS`.

**`eth_getTransactionReceipt`**: Should include `payer` field.

## Rationale

### Why a System Contract?

The Account Configuration Contract is a standard Solidity contract—not a precompile—deployed at a designated address. A true precompile (native node code with no EVM bytecode) would offer negligible gas savings here because the contract's operations are dominated by storage costs (SLOAD/SSTORE).

Using a system contract instead of a precompile provides key advantages:

1. **Portability**: The identical Solidity contract deploys on any EVM chain. On non-8130 chains it works as a standard contract (compatible with ERC-4337 as an unstaked factory). On 8130 chains, the protocol additionally reads its storage directly for validation.
2. **Protocol-level validation**: On 8130 chains, the protocol reads the contract's well-defined storage slots directly to validate AA transaction signatures—no EVM execution required during validation. The protocol can keep these storage slots warm for efficient access.
3. **Onchain interface**: Smart contracts call the system contract during execution to:
   - Modify keys (`authorizeKey()`, `revokeKey()`, `applyKeyChange()`)
   - Query transaction context (`getCurrentSigner()`, `getCurrentPayer()`)
   - Validate signatures for 4337 compatibility (`validateSignature()`)

Having the system contract accessible onchain means that accounts can build any additional recovery logic into their code.

### Why a Separate Nonce Contract?

Nonce state is isolated in its own system contract (`NONCE_MANAGER_ADDRESS`) rather than stored alongside key configurations in the Account Configuration Contract. This separation is motivated by their fundamentally different access patterns:

| Property | Key Config | Nonces |
|----------|-----------|--------|
| Write frequency | Rare (key rotation) | Every AA transaction |
| Read frequency | Every validation | Every validation |
| Growth | Rare (gas-bounded) | Unbounded (nonce channels) |

**Storage trie performance**: Both contracts accumulate state for every AA account on the chain. Nonces are the hottest write data—every AA transaction mutates a nonce slot. Mixing high-frequency nonce writes with rarely-updated key data in the same storage trie degrades performance at scale: trie depth grows faster, nonce updates re-hash through branches containing key data, and node caching strategies cannot be optimized independently for each access pattern. Separate storage tries allow nodes to optimize caching and pruning strategies for each workload independently.

**Parallel execution**: For parallel EVM implementations, storage conflicts are often tracked at the contract level. Separating nonces from keys makes the independence of nonce writes and key reads explicit, avoiding unnecessary serialization.

**Future state management**: Separate contracts enable different policies for state expiry, rent, or migration. Active nonce channels should remain warm while dormant key configurations may be candidates for future state expiry schemes.

**Modularity**: The Nonce Manager is a minimal contract with a read-only EVM interface (`getNonce()`). Nonce increments are protocol-only operations. This clean separation means nonce logic can evolve independently, and the Nonce Manager could potentially be reused by other transaction types or systems.

**Nonce key range**: Consider bounding `nonce_key` to a smaller range (e.g., `uint16` for 65,536 channels) to limit per-account state growth in the Nonce Manager's storage trie.

### Why Content-Addressed Keys (keyId)?

Keys are identified by a 20-byte content-derived `keyId` (see [Auth Types](#auth-types) for per-type derivation). This content-addressed approach provides several advantages:

1. **Robust cross-chain key operations**: The `key_changes` mechanism references keys by identity, not position. `revokeKey(K1, pubkey_A)` always targets the same key regardless of chain-local state. With an index-based system, `removeKey(index: 2)` could remove different keys on different chains if EVM-based modifications diverged.

2. **Idempotent operations**: `authorizeKey` for an already-authorized key is a no-op. `revokeKey` for a non-existent key is a no-op. This makes `key_changes` safe to replay unconditionally—the protocol applies only entries with sequence > current.

3. **Efficient validation**: Signatures carry the 20-byte keyId, and the protocol reads the key struct from storage. For K1, ecrecover directly returns the keyId—just 1 SLOAD to check authorization, and the EOA default check (`keyId == from`) comes for free. For non-K1 types, the protocol reads the full key struct. The uniform `0xFF || keyId || signature_data` format is simple for wallet SDKs to implement.

4. **Order-independent address derivation**: The `initial_keys` in `account_initialization` are sorted by keyId before salt computation, ensuring the same set of keys produces the same address regardless of specification order.

5. **K1 keys as recognizable addresses**: K1 keyIds are standard Ethereum addresses, so tooling (block explorers, wallet UIs, event indexers) can display them as recognizable addresses. The `KeyAuthorized` event indexes keyId, making it trivial to query which accounts have authorized a given EOA's key.

### Why Cross-Chain Key Changes?

The `key_changes` mechanism solves a fundamental problem: **key state portability across chains**.

Without `key_changes`, if an account rotates from Owner A to Owner B on Chain X, replicating this on Chain Y requires either:

- Having Owner A's key available to authorize the change (the user may no longer have it)
- Pre-signing chain-specific key-change transactions for every chain (requires the old key at signing time, chain-specific nonces, and doesn't work for chains that don't exist yet)
- Building custom cross-chain messaging infrastructure (trust assumptions, latency, cost)

Portable key changes solve this by creating **signed, chain-agnostic key operations**:

- No `chain_id` in the signature — replayable everywhere
- Own monotonic sequence counter — independent of transaction nonces
- Idempotent application — already-applied entries are skipped
- Two submission paths — `key_changes` tx field (8130) or `applyKeyChange()` EVM call (any chain)
- Just-in-time inclusion — attach the key change log to the same transaction that needs the new keys

The wallet signs a key change once. On 8130 chains, it can be included in the `key_changes` transaction field for protocol-level processing. On any EVM chain, it can be submitted via `applyKeyChange()` on the Account Config contract. The `key_change_sequence` counter tracks which portable operations have been applied. Local key changes (via `authorizeKey()`/`revokeKey()`) do not increment this counter, keeping the portable log and chain-local modifications cleanly separated.

### Why CREATE2 for Account Initialization?

Account initialization uses CREATE2 with `ACCOUNT_CONFIG_ADDRESS` as the deployer address for cross-chain portability:

1. **Deterministic addresses**: Same `user_salt + init_code + initial_keys` produces the same address on any chain
2. **Pre-deployment funding**: Users can receive funds at counterfactual addresses before deployment
3. **Portability**: The same Solidity contract at `ACCOUNT_CONFIG_ADDRESS` implements identical address derivation on all chains, enabling the same address whether using native 8130 or ERC-4337
4. **Front-running prevention**: Including `initial_keys` in the salt prevents attackers from deploying with different keys to steal counterfactual funds

The protocol executes CREATE2 semantics directly without having to call into potentially arbitrary code factories.

### Why No Native Multisig?

Native multisig is intentionally excluded to keep the protocol layer simple. Benefits of EVM-layer multisig:

1. **Flexibility**: Wallets can implement any multisig scheme (m-of-n, weighted, time-delayed, etc.)
2. **Upgradability**: Multisig logic can be updated without protocol changes
3. **Simplicity**: Protocol validation handles single signatures; complex policies live in wallet code
4. **Gas efficiency**: Avoid paying for multisig parsing in every transaction

Accounts can still achieve multisig by having the wallet contract use `getCurrentSigner()` to identify the authorizing key, then verify additional co-signer signatures from the `calldata` before executing operations.

### Why Fee Token Field?

The `fee_token` field enables future token-based gas payment without defining a new transaction type:

1. **Token payments**: A future EIP defines the packed format (`token_address || max_amount`) for gas abstraction with ERC-20 tokens.
2. **Signature binding**: The sender signs over `fee_token`, ensuring they explicitly authorize any token payment terms.

This approach provides upgrade flexibility while keeping the initial specification minimal and focused on ETH-based gas payment.

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `authorizeKey()` on the system contract to authorize existing signing keys (K1, R1, WebAuthn, etc.)
2. **Upgrade wallet logic**: Update contract to use the system contract as source of truth:
   - Call `isAuthorized()` / `validateSignature()` for signature verification
   - Call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

**Key principle**: Wallet contracts should avoid duplicating key storage. The system contract is ideally the single source of truth for authentication (for these auth types). Wallets implement authorization logic (spending limits, timelocks, multisig) in their execution code using `getCurrentSigner()` context. Wallets are free to add any additional recovery mechanisms or other logic into their code.


## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys or using the new transaction type, note that code needs to be deployed to do anything useful as calldata is sent to the address and must be interpreted. Chains can opt in for default accounts to not require deployment via 7702 for EOA keys.

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        uint8 keyType;
        bytes publicKey;
    }
    
    event KeyAuthorized(address indexed account, bytes20 indexed keyId, uint8 keyType, bytes publicKey);
    event KeyRevoked(address indexed account, bytes20 indexed keyId);
    event AccountCreated(address indexed account, bytes32 userSalt, bytes32 codeHash);
    event KeyChangeApplied(address indexed account, uint64 sequence);
    
    // Account creation (factory interface for portability)
    function createAccount(bytes32 userSalt, bytes calldata initCode, AuthKey[] calldata initialKeys) external returns (address);
    function getAddress(bytes32 userSalt, bytes calldata initCode, AuthKey[] calldata initialKeys) external view returns (address);
    
    // Key management (local, requires msg.sender)
    function authorizeKey(uint8 keyType, bytes calldata publicKey) external returns (bytes20 keyId);
    function revokeKey(bytes20 keyId) external;
    function isAuthorized(address account, bytes20 keyId) external view returns (bool);
    function getKeyData(address account, bytes20 keyId) external view returns (uint8 keyType, bytes memory publicKey);
    function validateSignature(address account, bytes20 keyId, bytes32 messageHash, bytes calldata signature) external view returns (bool);
    
    // Portable key changes (cross-chain replayable, increments key_change_sequence)
    struct KeyOperation {
        uint8 opType;       // 0x01 = authorizeKey, 0x02 = revokeKey
        uint8 keyType;
        bytes publicKey;
    }
    function applyKeyChange(address account, uint64 sequence, KeyOperation[] calldata operations, bytes calldata authorizerAuth) external;
    function getKeyChangeSequence(address account) external view returns (uint64);
    
    // Transaction context (only valid during AA transaction execution)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (bytes20 keyId, uint8 keyType, bytes memory publicKey);
}
```

### INonceManager

```solidity
interface INonceManager {
    // Read nonce for a given account and nonce channel
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
}
```

The Nonce Manager contract is deployed at `NONCE_MANAGER_ADDRESS`. Nonce increments are performed exclusively by the protocol during AA transaction processing—there is no public write interface. The `getNonce()` view function allows accounts and off-chain systems to query current nonce values.

## Security Considerations

**Enshrined Validation**: Signature verification uses well-established algorithms before any EVM execution. Failed validation rejects transactions before mempool entry.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify account configuration via local EVM calls. Keys can also be modified via portable key changes (`key_changes` transaction field or `applyKeyChange()` EVM call) with proper signature authorization. EOA key always retains authorization for recovery (if created with an EOA via 7702). No artificial key limit is enforced—since keys are stored in a content-addressed mapping and validation reads only the specific signing key (O(1)), gas costs for SSTORE naturally bound key creation.

**Cross-Chain Key Changes**: Key change operations are signed without `chain_id` to enable cross-chain replay. This is by design—the monotonic `key_change_sequence` counter provides ordering, and each entry requires authorization from a key valid at that point in the sequence. The `MAX_KEY_CHANGES` limit bounds the gas cost of processing key changes. Authorizer signatures use a separate domain (`KEY_CHANGE_TYPE`) to prevent reuse as transaction signatures.

**Key Change Sequence Integrity**: The `key_change_sequence` counter increments for portable key changes (via `key_changes` tx field or `applyKeyChange()` EVM call), but not for local EVM key modifications (`authorizeKey()`/`revokeKey()`). This means chain-local changes cannot disrupt the portable key change log. When portable key changes are replayed on a new chain, they may overwrite chain-local modifications at the same keyIds—this is correct behavior, as the portable log represents the canonical cross-chain key state.

**Delegation**: `DELEGATE` key type limited to 1 hop to prevent loops.

**Fee Token Safety**: The `fee_token` field MUST be empty until future EIPs define valid formats. Nodes reject transactions with non-empty `fee_token`, preventing undefined behavior.

**Payer Security**: Sponsors must sign each transaction they pay for, ensuring explicit authorization of gas costs. The use of separate type bytes (`AA_TX_TYPE` vs `AA_PAYER_TYPE`) for sender and payer signatures provides cryptographic domain separation, preventing signature reuse attacks between roles.

**Signature Size Limits**: Signatures exceeding `MAX_SIGNATURE_SIZE` (2KB) MUST be rejected. This prevents DoS attacks via oversized WebAuthn signatures containing arbitrarily large `clientDataJSON` payloads. The 2KB limit accommodates typical WebAuthn signatures (37-byte authenticatorData + ~200-500 byte clientDataJSON + 128-byte signature data) with ample headroom.

**Account Initialization Security**: The `initial_keys` are sorted by keyId and incorporated into the CREATE2 salt derivation (`effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(sorted_keys))))`). Sorting ensures the same set of keys always produces the same address regardless of specification order. This prevents front-running attacks where an attacker observes a pending account initialization and deploys with different keys to steal funds sent to the counterfactual address.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
