---
eip: 8130
title: Account Abstraction by Account Configuration
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 1153, 2718
---

## Abstract

This proposal defines a new [EIP-2718](./eip-2718.md) transaction type and an onchain system contract that together provide account abstraction — batching, gas sponsorship, and alternative authentication without EVM execution during validation. Accounts configure signing keys (secp256k1, P256, BLS, ...) in the system contract; the protocol validates transactions via direct state lookups against enshrined signature algorithms.

## Motivation

Keeping authentication purely cryptographic gives bounded, deterministic validation cost with no wasted compute, and removes the need for compensatory systems to address denial-of-service vectors introduced by arbitrary validation code.

The system contract is accessible via the EVM, so wallet code can layer any additional logic — recovery, multisig, spending limits, session keys — on top. The protocol handles authentication, gas payment and calldata delivery.

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD <!-- TODO --> | [EIP-2718](./eip-2718.md) transaction type |
| `AA_PAYER_TYPE` | TBD <!-- TODO --> | Magic byte for payer signature domain separation |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_ADDRESS` | TBD <!-- TODO --> | Account Configuration system contract address |
| `NONCE_MANAGER_ADDRESS` | TBD <!-- TODO --> | Nonce Manager system contract address |
| `KEY_CHANGE_TYPE` | TBD <!-- TODO --> | Magic byte for key change signature domain separation |
| `MAX_KEY_CHANGES` | 10 | Maximum key change entries per transaction |
| `MAX_SIGNATURE_SIZE` | 2048 | Maximum signature size in bytes (DoS prevention) |
| `ENTRY_POINT_ADDRESS` | TBD <!-- TODO --> | Protocol caller address for call execution |
| `DEPLOYMENT_HEADER_SIZE` | 14 | Size of the deployment header in bytes |

### Account Types

This proposal supports three paths for accounts to use AA transactions:

| Account Type | How It Works | Key Recovery |
|--------------|--------------|--------------|
| **Existing Smart Contracts** | Already-deployed accounts (e.g., ERC-4337 wallets) register keys via `authorizeKey()` on the system contract | Wallet-defined |
| **EOAs via [EIP-7702](./eip-7702.md)** | EOAs set delegation to a smart wallet implementation, then register keys | EOA key authorized by default; revocable |
| **New Accounts (No EOA)** | Created via `account_initialization` with CREATE2 address derivation; runtime bytecode placed at address, keys configured, call execution handles initialization | Wallet-defined |


### Auth Types

| Auth Type | ID | Algorithm | Public Key Size | Signature Size | keyId Derivation |
|----------|-----|-----------|-----------------|----------------|------------------|
| `K1` | `0x01` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | `keccak256(x \|\| y)[12:]` |
| `P256` | `0x02` | secp256r1 / P-256 | 33/65 bytes | 64 bytes (raw) / Variable (WebAuthn) | `keccak256(x \|\| y)[12:]` |
| `BLS` | `0x03` | BLS12-381 | 48 bytes | 96 bytes | `keccak256(pubkey)[12:]` |
| `DELEGATE` | `0xFF` | Delegated validation | 20 bytes (address) | Nested signature | `address` (direct) |

The auth type ID serves as both the stored `auth_type` value and the leading byte in configured key signatures. P256 additionally supports a sub-format byte for WebAuthn verification — see [Signature Format](#signature-format) for details.

**DELEGATE** (`0xFF`): Delegates validation to another account's configuration. The `keyId` is the delegated account's address directly — a transparent pointer. Only 1 hop is permitted (see [DELEGATE](#delegate) for signature structure and disambiguation rules).

> **K1 / DELEGATE mutual exclusion**: Because K1 keyId is an Ethereum address, a K1 key and a DELEGATE entry resolve to the same keyId when they reference the same address. They occupy the same storage slot and are therefore mutually exclusive — an account can register a K1 key for address *or* a DELEGATE to account, but not both. K1 pins trust to a *specific private key*; DELEGATE trusts *any key currently authorized on the target account*.

### Account Configuration

Each account can authorize a set of keys through the Account Configuration Contract at `ACCOUNT_CONFIG_ADDRESS`. Keys are identified by their `keyId`, a 20-byte content-derived identifier (see [Auth Types](#auth-types) for per-type derivation).

Only `msg.sender` can modify their own key configuration within EVM execution. Keys can also be modified via portable key changes (see [Cross-Chain Key Changes](#cross-chain-key-changes)).

**Default behavior**: The EOA key is implicitly authorized by default but can be disabled by revoking it on the contract.

#### Storage Layout

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_ADDRESS)

Key struct (per keyId):
  keccak256(keyId || base_slot) + 0: key_config (uint256, packed)
    byte 0: auth_type (uint8) — non-zero + not revoked = authorized
    byte 1: key_policy (uint8, bitfield)
      bit 0: revoked — key explicitly revoked;
      bit 1: requireSponsor — this key requires gas sponsorship
      bits 2-7: reserved
    bytes 2-31: reserved
  keccak256(keyId || base_slot) + 1: public_key bytes [0:32]
  keccak256(keyId || base_slot) + 2: public_key bytes [32:] (if > 32 bytes)

Key change sequence:
  keccak256(base_slot || "key_sequence" || chain_id): latest applied sequence (uint64)
    chain_id 0 = multichain channel, specific chain_id = chain-local channel
```

The protocol validates signatures by reading `key_config` and public key slots directly. Key enumeration is performed off-chain via `KeyAuthorized` / `KeyRevoked` event logs. No key count is enforced on-chain — gas costs naturally bound key creation.

#### 2D Nonce Storage

Nonce state is managed by a separate system contract at `NONCE_MANAGER_ADDRESS`, isolating high-frequency nonce writes from the Account Configuration Contract's key storage (see [Why a Separate Nonce Contract?](#why-a-separate-nonce-contract)).

```
Contract: NONCE_MANAGER_ADDRESS

Base slot: keccak256(account_address || NONCE_MANAGER_ADDRESS)
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

The protocol reads and increments nonce slots directly during AA transaction processing. Only the protocol may increment nonces; there is no public `increment` function.

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,               // Sender address (20 bytes) | empty for EOA signature
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp (seconds)
  max_priority_fee_per_gas,
  max_fee_per_gas,
  gas_limit,
  authorization_list, 
  account_initialization,  // For creating new accounts if not using 7702 | empty
  key_changes,        // Replayable cross-chain key change operations | empty
  committed_calldata, // Calldata committed first (ie. payer required action)  | empty
  calldata,           // Calldata executed atomically | empty
  sender_auth,
  payer_auth          // 0x01 || K1 sig (65 bytes) | 0xFF || payer_address (20 bytes) | empty
])
```

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address. **Required** (non-empty) for configured key signatures. **Empty** for EOA signatures—address recovered via ecrecover. The presence or absence of `from` is the sole distinguisher between EOA and configured key signatures. |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Unix timestamp (seconds since epoch). Transaction invalid when `block.timestamp > expiry`. A value of `0` means no expiry |
| `max_priority_fee_per_gas` | Priority fee per gas unit ([EIP-1559](./eip-1559.md)) |
| `max_fee_per_gas` | Maximum fee per gas unit ([EIP-1559](./eip-1559.md)) |
| `gas_limit` | Maximum gas |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list |
| `account_initialization` | **Empty**: No account creation. **Non-empty**: See [Account Initialization](#account-initialization) |
| `key_changes` | **Empty**: No key changes. **Non-empty**: Array of signed key change operations. See [Cross-Chain Key Changes](#cross-chain-key-changes) |
| `committed_calldata` | **Empty**: No committed call. **Non-empty**: Calldata (bytes) delivered to `from` via `ENTRY_POINT_ADDRESS`. Committed independently — its state changes persist even if `calldata` execution reverts. See [Call Execution](#call-execution) |
| `calldata` | **Empty**: No call. **Non-empty**: Calldata (bytes) delivered to `from` via `ENTRY_POINT_ADDRESS`. If execution reverts, its state changes are discarded. See [Call Execution](#call-execution) |
| `sender_auth` | See [Signature Format](#signature-format) |
| `payer_auth` | Payer authorization, disambiguated by leading type byte. **Empty**: self-pay. **`0x01` + K1 signature (66 bytes)**: K1 sponsor. **`0xFF` + payer_address (21 bytes)**: delegate payer. See [Payer Modes](#payer-modes) |

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + tx_payload_cost + sender_key_cost + payer_cost + nonce_key_cost + bytecode_cost + key_changes_cost
```

**`sender_key_cost`**: Determined by the auth type byte:

| Signature Type Byte | Auth Type | Gas | Rationale |
|---------------------|-----------|-----|-----------|
| EOA | K1 | 6000 | ecrecover (3000) + 1 SLOAD (key_config) + overhead |
| `0x01` | K1 | 6000 | ecrecover (3000) + 1 SLOAD (key_config) + overhead |
| `0x02` (sub `0x00`) | P256 (raw) | 7000 | P256 verify + 2-3 SLOADs (auth_type + pubkey) |
| `0x02` (sub `0x01`) | P256 (WebAuthn) | 12000 + calldata_gas | P256 verify + WebAuthn parsing + 2-3 SLOADs |
| `0x03` | BLS | 8000 | BLS verify + 2 SLOADs |
| `0xFF` | DELEGATE | 3000 + delegated | 1 SLOAD + nested sig cost |

All types read `key_config` (1 SLOAD) for authorization and key policy checks. Non-K1 types require additional SLOADs to retrieve the stored public key.

**`payer_cost`**: Determined by the payer mode (see [Payer Modes](#payer-modes)):

| Payer Mode | Type Byte | Gas | Rationale |
|------------|-----------|-----|-----------|
| Self-pay | — | 0 | `key_policy.requireSponsor` checked from sender validation SLOAD (no additional read) |
| K1 sponsor | `0x01` | 3,000 | ecrecover |
| Delegate payer | `0xFF` | 2,100 | 1 cold SLOAD (delegate key verification) |

| Component | Value |
|-----------|-------|
| `tx_payload_cost` | Standard per-byte cost over the entire RLP-serialized transaction: 16 gas per non-zero byte, 4 gas per zero byte, consistent with [EIP-2028](./eip-2028.md). Ensures all transaction fields (`account_initialization`, `key_changes`, `authorization_list`, `sender_auth`, `committed_calldata`, `calldata`, etc.) are charged for data availability |
| `nonce_key_cost` | 22,100 gas for first use of a `nonce_key` (cold SLOAD + SSTORE set), 5,000 gas for existing keys (cold SLOAD + warm SSTORE reset) |
| `bytecode_cost` | 0 if `account_initialization` empty. Otherwise: 32,000 (deployment base) + code deposit cost (200 gas per deployed byte). Byte costs for `bytecode` are covered by `tx_payload_cost` |
| `key_changes_cost` | Per applied entry: authorizer signature verification cost (based on authorizer's `auth_type`, using the `sender_key_cost` table above) + `num_operations` × 20,000 per SSTORE for key struct slots. Per skipped entry (already applied): 2,100 (SLOAD to check sequence). 0 if `key_changes` empty |

#### Signature Format

Signature format is determined by the `from` field:

**EOA signature** (`from` empty): Raw 65-byte ECDSA signature `(r || s || v)`. The sender address is recovered via ecrecover.

**Configured key signature** (`from` set):

```
auth_type (1 byte) || [keyId (20 bytes) ||] signature_data
```

| Signature Type | Signature Format | Total Size | Protocol Reads |
|----------------|------------------|------------|----------------|
| `0x01` K1 (recovery) | `r,s,v (65)` | 66 bytes | 1 SLOAD |
| `0x01` K1 (with keyId) | `keyId (20) \|\| r,s,v (65)` | 86 bytes | 1 SLOAD |
| `0x02` P256 (raw) | `keyId (20) \|\| 0x00 \|\| r,s (64)` | 86 bytes | 2-3 SLOADs |
| `0x02` P256 (WebAuthn) | `keyId (20) \|\| 0x01 \|\| authenticatorData \|\| cDJ_len (2) \|\| clientDataJSON \|\| r,s (64)` | Variable | 2-3 SLOADs |
| `0x03` BLS | `keyId (20) \|\| sig (96)` | 117 bytes | 2 SLOADs |
| `0xFF` DELEGATE | `delegate_address (20) \|\| nested_signature` | Variable | 1 SLOAD + nested |

K1 supports two formats, disambiguated by length after the auth type byte: 65 bytes uses recovery (ecrecover derives keyId, saves 20 bytes calldata), 85 bytes includes an explicit keyId. All non-K1 types always include keyId.

##### Validation

1. Parse `auth_type` byte. Derive or parse `keyId` (K1 recovery: ecrecover; all others: read from signature)
2. Read `key_config` for `(from, keyId)`: verify authorized (see [Storage Layout](#storage-layout)) and stored `auth_type` matches signature. For K1 with `keyId == from`: empty slot = EOA default (valid), `revoked` set = blocked.
3. **K1**: verify ecrecover result matches keyId. **P256**: read sub-format byte — `0x00`: raw P-256 ECDSA verify; `0x01`: WebAuthn verify (see [Auth Types](#auth-types)). Both verify against stored public key. **BLS**: verify signature against stored public key. **DELEGATE**: validate nested signature against delegate account (1 hop max)

##### DELEGATE

For DELEGATE (`0xFF`), the protocol confirms authorization then validates `nested_signature` against the delegated account's configuration. Only 1 hop is permitted; nested `DELEGATE` results in an immediate mempool drop. The nested signature always starts with an auth type byte — including K1 (`0x01`). No length-based disambiguation is used.

**Example** (Account B delegates to Account A, which has a P256 key):

```
0xFF || Account_A_address (20) || 0x02 || A_P256_keyId (20) || 0x00 || r,s (64)
```

#### Signature Payload

Sender and payer use different type bytes for domain separation, preventing signature reuse attacks:

**Sender signature hash** (the marker byte in the last position commits to a payer mode — see [Payer Modes](#payer-modes)):

```
// Self-pay (no sponsor):
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata,
  0x80
]))

// Open sponsor (any payer):
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata,
  0x00
]))

// Committed sponsor (specific payer):
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata,
  payer_address
]))
```

**Payer signature hash** (when sponsoring):

```
keccak256(AA_PAYER_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, key_changes, committed_calldata, calldata
]))
```

#### Payer Modes

Gas payment mode is disambiguated by the leading type byte of `payer_auth`:

| Mode | Type Byte | Sender signs | `payer_auth` (wire) | Gas Payer | Description |
|------|-----------|-------------|---------------------|-----------|-------------|
| **Self-pay** | — | `0x80` (empty) | empty | `from` | Rejected if `key_policy.requireSponsor` set. |
| **K1 sponsor** | `0x01` | `<payer_address>` or `0x00` | `0x01 \|\| K1_signature (65)` | Payer (ecrecover) | Committed or open sponsorship. |
| **Delegate payer** | `0xFF` | `<payer_address>` | `0xFF \|\| payer_address (20)` | `payer_address` | Payer has DELEGATE key for sender. No payer signature. |


**Delegate payer**: The payer has a DELEGATE key (`auth_type == 0xFF`) for `keyId == from`, granting standing authorization for the sender to use their ETH for gas. The on-chain DELEGATE key replaces a per-transaction payer signature. The sender always commits to a specific `payer_address` (no open delegate mode).

Combined with per-key `requireSponsor` (see [Storage Layout](#storage-layout)), this enables a "gas piggy bank" pattern: keys that cannot self-pay draw gas from a dedicated funding account. One gas account can fund multiple accounts by registering a DELEGATE key for each, fully isolating gas spend from the accounts' own ETH balances.

Future EIPs may extend `payer_auth` with additional type bytes for account config signatures or other mechanisms.

### Account Initialization

New smart contract accounts can be created with pre-configured keys in a single transaction using the `account_initialization` field. The `bytecode` is the runtime code placed directly at the account address — it is not executed during deployment. The account's initialization logic runs when `calldata` is delivered to the account via the execution phase that follows:

```
account_initialization = rlp([
  user_salt,          // bytes32: User-chosen uniqueness factor
  bytecode,           // bytes: Runtime bytecode placed directly at the account address
  initial_keys        // Array of [auth_type, public_key] pairs
])
```

#### Address Derivation

Addresses are derived using the CREATE2 address formula with the Account Configuration Contract (`ACCOUNT_CONFIG_ADDRESS`) as the deployer. The `initial_keys` are sorted by `keyId` before hashing to ensure address derivation is order-independent (the same set of keys always produces the same address regardless of the order specified):

```
sorted_keys = sort(initial_keys, by: keyId)

keys_commitment = keccak256(keyId_0 || auth_type_0 || keyId_1 || auth_type_1 || ... || keyId_n || auth_type_n)

effective_salt = keccak256(user_salt || keys_commitment)
deployment_code = DEPLOYMENT_HEADER(len(bytecode)) || bytecode
address = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(deployment_code))[12:]
```

The `keys_commitment` uses `keyId || auth_type` (21 bytes) per key — consistent with how the Account Configuration Contract identifies keys.

The `DEPLOYMENT_HEADER(n)` is a 14-byte EVM loader that copies the trailing bytecode into memory and returns it. The header is always 14 bytes, but encodes the bytecode length `n` into its `PUSH2` instructions (4 bytes vary with `n`):

```
DEPLOYMENT_HEADER(n) = [
  0x61, (n >> 8) & 0xFF, n & 0xFF,    // PUSH2 n        (bytecode length)
  0x60, 0x0E,                          // PUSH1 14       (offset: bytecode starts after 14-byte header)
  0x60, 0x00,                          // PUSH1 0        (memory destination)
  0x39,                                // CODECOPY       (copy bytecode from code[14..] to memory[0..])
  0x61, (n >> 8) & 0xFF, n & 0xFF,    // PUSH2 n        (bytecode length)
  0x60, 0x00,                          // PUSH1 0        (memory offset)
  0xF3                                 // RETURN         (return bytecode from memory)
]
```

On non-8130 chains, the Solidity `createAccount()` function constructs `deployment_code` internally and passes it as init_code to CREATE2. On 8130 chains, the protocol constructs the same `deployment_code` for address derivation but places `bytecode` directly (no execution). Both paths produce the same address — callers only provide `bytecode`; the header is never user-facing and this ensures identical addresses across 8130 and non-8130 chains.

Users can receive funds at counterfactual addresses before account creation.

#### Validation (Account Initialization)

When `account_initialization` is non-empty:

1. Parse `[user_salt, bytecode, initial_keys]`
2. For each key in `initial_keys`, derive `keyId` per auth type rules (see [Auth Types](#auth-types)). For compressed public keys, decompress to the uncompressed point before derivation.
3. Reject if any duplicate `keyId` values exist
4. Sort by keyId: `sorted_keys = sort(initial_keys, by: keyId)`
5. Compute `keys_commitment = keccak256(keyId_0 || auth_type_0 || ... || keyId_n || auth_type_n)`
6. Compute `effective_salt = keccak256(user_salt || keys_commitment)`
7. Compute `deployment_code = DEPLOYMENT_HEADER(len(bytecode)) || bytecode`
8. Compute `expected = keccak256(0xff || ACCOUNT_CONFIG_ADDRESS || effective_salt || keccak256(deployment_code))[12:]`
9. Require `from == expected`
10. Require `code_size(from) == 0` (account not yet deployed)
11. Validate `sender_auth` against one of `initial_keys` (keyId extracted from signature must match an entry's computed keyId)

#### Execution (Account Initialization)

1. Register `initial_keys` in Account Config storage for `from`: for each key, compute `keyId`, write auth_type and public_key to the key struct slots
2. Apply `key_changes` (if non-empty) — see [Cross-Chain Key Changes](#cross-chain-key-changes)
3. Place `bytecode` at `from`
4. Proceed with call execution

Key registration and key changes are applied before code placement so that the account's initialization logic (executed via call execution) can read its own key configuration from the Account Config contract.

#### Default Account (Chain Operator Option)

For EOA accounts, chain operators may configure a **default account**—a wallet implementation automatically used for addresses without deployed code. This enables EOAs to submit AA transactions and use AA features (batching, gas sponsorship) without explicitly deploying code via [EIP-7702](./eip-7702.md).


**Configuration**: Chain operators specify the default account bytecode hash. This is an optional feature—chains may require explicit 7702 delegation instead.

### Cross-Chain Key Changes

The `key_changes` field enables cross-chain portable key management. Key change operations include a `chain_id` field where `0` means valid on any chain, allowing them to be replayed across chains to synchronize key state.

#### Key Change Format

```
key_changes = [
  rlp([
    chain_id,           // uint64: 0 = valid on any chain
    sequence,           // uint64: monotonic ordering
    operations,         // Array of key operations
    authorizer_auth     // Signature from a key valid at this sequence
  ]),
  ...  // max MAX_KEY_CHANGES entries per transaction
]

operation = rlp([
  op_type,              // 0x01 = authorizeKey, 0x02 = revokeKey
  auth_type,            // uint8: auth type
  public_key            // bytes: public key material
])
```

Each entry represents a set of key operations authorized at a specific sequence number. The `authorizer_auth` must be valid against the account's key configuration *at the point after all previous entries in the list have been applied*.

The sequence number is scoped to a 2D channel defined by the `chain_id` to prevent cross-chain sequence de-sync. A `chain_id` of `0` uses the multichain sequence channel, while a specific `chain_id` uses that chain's local sequence channel.

#### Key Change Signature Payload

Key change signatures use domain separation via `KEY_CHANGE_TYPE`. The `chain_id` field controls replay scope: `0` means the key change is valid on any chain, otherwise it is only valid on the specified chain.

```
keccak256(KEY_CHANGE_TYPE || rlp([
  from,
  chain_id,
  sequence,
  operations
]))
```

The `authorizer_auth` follows the same [Signature Format](#signature-format) as `sender_auth` (EOA or configured key), validated against the account's key state at that point in the sequence.

#### Key Change Paths

Keys can be modified through three paths:

| | Portable: `key_changes` (tx field) | Portable: `applyKeyChange()` (EVM) | Local: `authorizeKey()` / `revokeKey()` (EVM) |
|--|---|---|---|
| Authorization | Signed operation (any auth type) | Signed operation (any auth type) | `msg.sender` during execution |
| Portability | Cross-chain (chain_id 0) or chain-specific | Cross-chain (chain_id 0) or chain-specific | Chain-local only |
| Sequence | Increments channel's `key_change_sequence` | Increments channel's `key_change_sequence` | Does NOT affect `key_change_sequence` |
| When processed | Before code deployment (8130 only) | During EVM execution (any chain) | During EVM execution |

**Portable key changes** (`key_changes` tx field or `applyKeyChange()`) use the same signed operations and the same `key_change_sequence` channel counters. The wallet signs a key change once; if `chain_id` is `0`, it uses the multichain sequence channel and can be submitted via either path on any chain. `applyKeyChange()` validates the authorizer signature against the account's key state, applies the operations, and increments the channel's sequence — identical behavior to protocol-level `key_changes` processing.

**Local key changes** (`authorizeKey()` / `revokeKey()`) require `msg.sender` authorization and do **not** increment the `key_change_sequence`. These are chain-local customizations (e.g., session keys, chain-specific authorizations). When portable key changes are replayed on a new chain, they write to specific keyIds, potentially overwriting local changes at those same keyIds.

### Execution

#### Call Execution

Both `committed_calldata` and `calldata` are delivered to `from` as individual calls:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `ENTRY_POINT_ADDRESS` |
| `msg.value` | 0 |
| `data` | `committed_calldata` or `calldata` |

Execution proceeds in two phases:

Both phases share a single gas pool from `gas_limit`. `committed_calldata` executes first; `calldata` receives the remainder.

1. **Committed phase**: If `committed_calldata` is non-empty, execute a call to `from`. This call is committed independently — its state changes persist regardless of whether the calldata phase succeeds or reverts. If `committed_calldata` reverts, its state changes are discarded and execution continues to the next phase. For accounts without code, the call succeeds with no effect.

2. **Calldata phase**: If `calldata` is non-empty, execute a call to `from`. If execution reverts, its state changes are discarded. For accounts without code, the call succeeds with no effect.

The wallet fully interprets both payloads — batching, multicall, or any other execution pattern is handled by the wallet's code, not the protocol. This two-phase design enables robust token gas payments: the wallet transfers tokens to a sponsor in `committed_calldata`, while the user's operations execute in `calldata`. The sponsor's payment survives even if `calldata` reverts.

#### Transaction Context

During AA transaction execution, accounts can query the Account Configuration Contract for the current transaction's authorization context:

- **Payer**: `getCurrentPayer()` returns the gas payer address (`from` for self-pay, recovered payer for sponsored)
- **Signer**: `getCurrentSigner()` returns `(keyId, authType, publicKey)` of the key that authorized the transaction

The protocol injects this context using [EIP-1153](./eip-1153.md) transient storage (TSTORE) on the Account Configuration Contract before call execution. Only two values are written:

| Slot | Value | Size |
|------|-------|------|
| `keccak256("context.payer")`  | Payer address | 20 bytes |
| `keccak256("context.signer")` | Signer keyId | 20 bytes |

`getCurrentPayer()` reads payer via TLOAD. `getCurrentSigner()` reads keyId via TLOAD, then looks up `(auth_type, public_key)` from persistent key storage. Transient storage is automatically cleared at transaction end.

**Non-8130 chains**: These functions return zero/default values since no protocol writes to transient storage.

### Portability

Both system contracts are standard Solidity contracts deployed at designated addresses on any EVM chain. On non-8130 chains they operate as normal contracts (ERC-4337 compatible); on 8130 chains the protocol additionally reads their storage directly for validation. See [Why a System Contract?](#why-a-system-contract) for the design rationale.

### Validation Flow

#### Mempool Acceptance

1. Verify `sender_auth` size ≤ `MAX_SIGNATURE_SIZE`, `key_changes` length ≤ `MAX_KEY_CHANGES`
2. Resolve sender: if `from` set, use it; if empty, ecrecover from `sender_auth`
3. Determine effective key state:
   a. If `account_initialization` non-empty: verify address derivation, `code_size(from) == 0`, use `initial_keys`
   b. Else: read from Account Config storage
4. If `key_changes` non-empty: simulate applying operations in sequence, skip already-applied entries
5. Validate `sender_auth` against resulting key state (see [Validation](#validation))
6. Resolve payer from `payer_auth`:
   - Empty: reject if `key_policy.requireSponsor` set. Payer is `from`.
   - Type byte `0x01`: K1 sponsor. Recover payer via ecrecover over the trailing 65-byte signature. Verify sender signed `<payer_address>` or `0x00`.
   - Type byte `0xFF`: Delegate payer. Read trailing 20-byte address. Verify payer has DELEGATE key for sender. Payer is `payer_address`.
7. Verify nonce, payer ETH balance, expiry
8. Mempool threshold: payer's pending sponsored count below node-configured limits

#### Block Execution

1. ETH gas deduction from payer (unused gas is refunded to the payer)
2. Increment nonce in Nonce Manager storage
3. Process authorization_list ([EIP-7702](./eip-7702.md))
4. Register `initial_keys` in Account Config storage (if `account_initialization` non-empty)
5. Apply `key_changes` to Account Config storage (if non-empty)
6. Place `bytecode` at `from` (if `account_initialization` non-empty; code is placed directly, not executed)
7. Write transaction context to Account Config transient storage via TSTORE (payer address, signer keyId)
8. Execute `committed_calldata` via `ENTRY_POINT_ADDRESS` if non-empty (committed independently)
9. Execute `calldata` via `ENTRY_POINT_ADDRESS` if non-empty

Steps 1–7 are protocol-level direct state operations with no EVM execution. Steps 8–9 are the EVM execution phase. Following the precedent of [EIP-7702](./eip-7702.md), the protocol-level state changes applied in steps 1–7 MUST NOT be reverted if the EVM execution in steps 8–9 reverts. `committed_calldata` in step 8 is committed independently — its state changes MUST NOT be reverted if step 9 reverts. For steps 4–6, the protocol SHOULD inject log entries into the transaction receipt (e.g., `KeyAuthorized`, `AccountCreated`) matching the events defined in the [IAccountConfig](#iaccountconfig) interface, following the protocol-injected log pattern established by [EIP-7708](./eip-7708.md). This ensures indexers observe the same events regardless of whether keys are registered via protocol (8130) or via EVM calls (non-8130 chains).

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels. Reads from the Nonce Manager contract at `NONCE_MANAGER_ADDRESS`.

**`eth_getTransactionReceipt`**: Should include a `payer` field with the gas payer address.

## Rationale

### Why a System Contract?

The Account Configuration Contract is a standard Solidity contract—not a precompile—deployed at a designated address. A true precompile (native node code with no EVM bytecode) would offer negligible gas savings here because the contract's operations are dominated by storage costs (SLOAD/SSTORE).

Using a system contract instead of a precompile provides key advantages:

1. **Portability**: The identical Solidity contract deploys on any EVM chain. On non-8130 chains it works as a standard contract (compatible with ERC-4337 as an unstaked factory). On 8130 chains, the protocol additionally reads its storage directly for validation.
2. **Protocol-level validation**: On 8130 chains, the protocol reads the contract's storage slots directly to validate AA transaction signatures. The protocol can keep these slots warm for efficient access.
3. **Onchain interface**: Smart contracts call the system contract during execution to:
   - Modify keys (`authorizeKey()`, `revokeKey()`, `applyKeyChange()`)
   - Query transaction context (`getCurrentSigner()`, `getCurrentPayer()`) — injected by the protocol via [EIP-1153](./eip-1153.md) transient storage (TSTORE) before call execution, read by the contract via TLOAD
   - Validate signatures for 4337 compatibility (`validateSignature()`)

Having the system contract accessible onchain means that accounts can build any additional recovery logic into their code.

**Storage layout is consensus-critical**: Because the protocol reads storage slots directly on 8130 chains, the keccak-derived slot layout (see [Storage Layout](#storage-layout)) becomes a consensus rule. Changing the layout would require a protocol upgrade, equivalent to any other consensus-level change. This is a deliberate trade-off — the same commitment that [EIP-7702](./eip-7702.md) makes with its delegation designator format. The layout is intentionally simple (keccak-derived, fixed-size slots per key) to minimize the likelihood of future changes.

### Why a Separate Nonce Contract?

Nonce state is isolated in its own system contract (`NONCE_MANAGER_ADDRESS`) rather than stored alongside key configurations in the Account Configuration Contract. This separation is motivated by their fundamentally different access patterns:

| Property | Key Config | Nonces |
|----------|-----------|--------|
| Write frequency | Rare (key rotation) | Every AA transaction |
| Read frequency | Every validation | Every validation |
| Growth | Rare (gas-bounded) | Unbounded (nonce channels) |

**Storage trie performance**: Both contracts accumulate state for every AA account on the chain. Nonces are the hottest write data—every AA transaction mutates a nonce slot. Mixing high-frequency nonce writes with rarely-updated key data in the same storage trie degrades performance at scale: trie depth grows faster, nonce updates re-hash through branches containing key data, and node caching strategies cannot be optimized independently for each access pattern. Separate storage tries allow nodes to optimize caching and pruning strategies for each workload independently.

**Modularity**: The Nonce Manager is a minimal contract with a read-only EVM interface (`getNonce()`). Nonce increments are protocol-only operations. This clean separation means nonce logic can evolve independently, and the Nonce Manager could potentially be reused by other transaction types or systems.

### Why CREATE2 for Account Initialization?

Account initialization uses the CREATE2 address formula with `ACCOUNT_CONFIG_ADDRESS` as the deployer address for cross-chain portability:

1. **Deterministic addresses**: Same `user_salt + bytecode + initial_keys` produces the same address on any chain
2. **Pre-deployment funding**: Users can receive funds at counterfactual addresses before account creation
3. **Portability**: Same `deployment_code` produces the same address on both 8130 and non-8130 chains (see [Address Derivation](#address-derivation))
4. **Front-running prevention**: `initial_keys` in the salt prevents attackers from deploying with different keys (see [Account Initialization](#account-initialization))

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `authorizeKey()` on the system contract to authorize existing signing keys (K1, P256, etc.)
2. **Upgrade wallet logic**: Update contract to use the system contract as source of truth:
   - Call `isAuthorized()` / `validateSignature()` for signature verification
   - Call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

### Why Auth Type Byte Encoding?

The `from` field's presence distinguishes EOA from configured key signatures, avoiding reliance on a magic prefix byte that could collide with valid ECDSA `r` values. Configured key signatures use `auth_type || keyId || signature_data`, with K1 optionally omitting keyId since ecrecover derives it.

All non-K1 types verify against stored public keys. The keyId-based format minimizes calldata — particularly important for L2s where data availability costs dominate — while the 1-byte auth type supports up to 255 types for future additions (quantum-safe algorithms, ZK-proof auth) without protocol changes.

### Why Two-Phase Execution (`committed_calldata` + `calldata`)?

Execution is split into `committed_calldata` and `calldata` to guarantee sponsor payment while keeping the main execution simple. The `committed_calldata` persists even if `calldata` reverts, enabling robust token gas payments without protocol-level token awareness: the wallet transfers tokens to a sponsor in `committed_calldata`, and that payment survives regardless of what happens next.

The wallet fully interprets both payloads — batching, multicall, or any other execution pattern is the wallet's responsibility, not the protocol's. `ENTRY_POINT_ADDRESS` serves as the `msg.sender`, allowing wallet code to verify the caller is the protocol.

### Why Key Policy?

The `key_config` slot packs `auth_type` (1 byte) and `key_policy` (1 byte) into the same 32-byte storage slot, read in a single SLOAD during sender validation — zero additional storage cost for policy enforcement.

The `revoked` flag enables cross-chain portable EOA key revocation via the existing `revokeKey` key change mechanism. The `requireSponsor` flag provides protocol-enforced session key semantics — a key that can authenticate but cannot access the account's ETH for gas. This restriction is enforced at the protocol layer before any EVM execution. Wallet code can layer additional restrictions (allowed targets, spending caps) by checking `getCurrentSigner()` during execution, but the ETH-access guarantee comes from the protocol. This limits the blast radius of a compromised session key to whatever the wallet permits, never the account's raw ETH balance.

### Future Auth Types

The auth type system is designed to be extensible. Potential additions include ZK-proof-based auth types, where a succinct proof of off-chain validation replaces a traditional signature. Because proof verification is a fixed algorithm with bounded cost, this fits the protocol's validation model without reintroducing arbitrary EVM execution during transaction validation. This can be used for fully self-sovereign recovery without intermediaries or relayers.

## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys or using the new transaction type, note that code needs to be deployed to do anything useful as calldata is sent to the address and must be interpreted. Chains can opt in for default accounts to not require deployment via 7702 for EOA keys.

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        uint8 authType;
        bytes publicKey;
    }
    
    event KeyAuthorized(address indexed account, bytes20 indexed keyId, uint8 authType, uint8 keyPolicy, bytes publicKey);
    event KeyRevoked(address indexed account, bytes20 indexed keyId);
    event KeyPolicyChanged(address indexed account, bytes20 indexed keyId, uint8 keyPolicy);
    event AccountCreated(address indexed account, bytes32 userSalt, bytes32 codeHash);
    event KeyChangeApplied(address indexed account, uint64 sequence);
    
    // Account creation (factory interface for portability)
    function createAccount(bytes32 userSalt, bytes calldata bytecode, AuthKey[] calldata initialKeys) external returns (address);
    function getAddress(bytes32 userSalt, bytes calldata bytecode, AuthKey[] calldata initialKeys) external view returns (address);
    
    // Key management (local, requires msg.sender)
    function authorizeKey(uint8 authType, bytes calldata publicKey) external returns (bytes20 keyId);
    function revokeKey(bytes20 keyId) external;
    function setKeyPolicy(bytes20 keyId, uint8 keyPolicy) external;
    function isAuthorized(address account, bytes20 keyId) external view returns (bool);
    function getKeyData(address account, bytes20 keyId) external view returns (uint8 authType, uint8 keyPolicy, bytes memory publicKey);
    function validateSignature(address account, bytes20 keyId, bytes32 messageHash, bytes calldata signature) external view returns (bool);
    
    // Portable key changes (cross-chain replayable, increments key_change_sequence)
    struct KeyOperation {
        uint8 opType;       // 0x01 = authorizeKey, 0x02 = revokeKey
        uint8 authType;
        bytes publicKey;
    }
    function applyKeyChange(address account, uint64 chainId, uint64 sequence, KeyOperation[] calldata operations, bytes calldata authorizerAuth) external;
    function getKeyChangeSequence(address account, uint64 chainId) external view returns (uint64);
    
    // Transaction context (reads from transient storage; only returns meaningful values during 8130 AA transaction execution)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (bytes20 keyId, uint8 authType, bytes memory publicKey);
}
```

### INonceManager

```solidity
interface INonceManager {
    // Read nonce for a given account and nonce channel
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
}
```

The Nonce Manager contract is deployed at `NONCE_MANAGER_ADDRESS`.

## Security Considerations

**Enshrined Validation**: Signature verification uses well-established algorithms before any EVM execution. Failed validation rejects transactions before mempool entry.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify keys via local EVM calls; portable key changes require signature authorization. EOA key is implicitly authorized by default; revocable via `revokeKey` (cross-chain portable). Accounts SHOULD have at least one configured key before revoking the EOA key. The `requireSponsor` key policy limits session key blast radius by preventing gas access. `MAX_KEY_CHANGES` bounds per-transaction processing cost; `KEY_CHANGE_TYPE` domain separation prevents authorizer signatures from being reused as transaction signatures.

**Delegation**: See [DELEGATE](#delegate) for hop limits and nested signature rules.

**Payer Security**: `AA_TX_TYPE` vs `AA_PAYER_TYPE` domain separation prevents signature reuse between sender and payer roles. The sender's signed marker commits to a payer mode. Revoking a DELEGATE key immediately invalidates all pending transactions using that payer.

**Signature Size Limits**: Signatures exceeding `MAX_SIGNATURE_SIZE` MUST be rejected to prevent DoS via oversized signatures.

**Account Initialization Security**: `initial_keys` are salt-committed, preventing front-running. Permissionless deployment via `createAccount()` is safe — even if front-run, the account is created with the owner's keys. Wallet bytecode should be inert when uninitialized.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
