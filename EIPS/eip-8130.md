---
eip: 8130
title: Account Abstraction by Account Configuration
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 2718
---

## Abstract

This proposal introduces a standardized validation mechanism for account abstraction using onchain account configurations to define accepted keys and key types. Unlike EIP-7701/RIP-7560 which permit arbitrary validation code, this approach restricts validation to predefined key types, ensuring protocol simplicity and secure account abstraction without EVM execution during validation. A new transaction type leverages this mechanism with native gas abstraction support.

## Motivation

Enable account abstraction benefits—batching, gas sponsorship, custom authentication, programmable logic—while allowing nodes to validate transactions via simple state checks without EVM execution. This enables highly optimizable and performant transaction validation and mempool implementations and removes the need for additional reputation systems to ensure DoS prevention.

Having the account auth configurations accessible and managable via the EVM enables accounts to build out any additional recovery mechanisms they desire. Calldata delivery to the account address only means the wallet can built out any additional checks for validation they desire.

### Existing Solutions

| Solution | Approach | Limitations |
|----------|----------|-------------|
| ERC-4337 | Application-layer abstraction | Complex mempool rules (ERC-7562), high gas overhead, entrypoint costs |
| [EIP-7701](./eip-7701.md) | Protocol-level with arbitrary validation | Complex mempool rules, major protocol changes |

This proposal addresses these by:

- **Simplifying Validation**: Predefined auth types eliminate EVM execution during validation
- **Optimizable Mempool and Validation Logic**: Validators use only state lookups, mempools can invalidate transactions quickly via (flash)block access lists.
- **Reducing Gas Costs**: No entrypoint contracts or associated overhead
- **Ensuring Extensibility**: Supports future quantum-safe algorithms via new auth types, and a `fee_token` field for future token-based gas payment
- **Maintaining Compatibility**: Coexists with EIP-7702 and ERC-4337

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD | [EIP-2718](./eip-2718.md) transaction type |
| `AA_PAYER_TYPE` | TBD | Magic byte for payer signature domain separation |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_PRECOMPILE` | TBD | Account Configuration precompile address |
| `MAX_KEYS` | 127 | Maximum configured keys per account (single-byte RLP encoding) |
| `MAX_SIGNATURE_SIZE` | 2048 | Maximum signature size in bytes (DoS prevention) |

### Account Types

This proposal supports three paths for accounts to use AA transactions:

| Account Type | How It Works | Key Recovery |
|--------------|--------------|--------------|
| **Existing Smart Contracts** | Already-deployed accounts (e.g., ERC-4337 wallets) register keys via `addKey()` on the precompile | Wallet-defined |
| **EOAs via EIP-7702** | EOAs set delegation to a smart wallet implementation, then register keys | EOA key always authorized |
| **New Accounts (No EOA)** | Deploy via `account_initialization` with CREATE2; keys configured at deployment | Wallet-defined |

**Existing smart contracts** can migrate to native AA without redeployment by registering their signing keys with the precompile.

**EOAs** can adopt AA features by either: (1) using EIP-7702 to delegate to a smart wallet, or (2) on chains with a configured default account, submitting AA transactions directly.

**New accounts without an EOA** are created via the `account_initialization` field, deploying wallet bytecode and configuring keys in a single transaction. These accounts have no inherent EOA recovery—recovery mechanisms must be implemented in the wallet code.

### Account Configuration

Each account can configure an ordered array of authorized keys through the Account Configuration Precompile at `ACCOUNT_CONFIG_PRECOMPILE`. Only `msg.sender` can modify their own configuration. This enables existing ERC-4337 smart accounts to register keys and migrate to native AA without redeployment.

**Default behavior**: An empty configuration `[]` means only the account's EOA key can authorize transactions. The EOA key always retains authorization regardless of configured keys, ensuring recovery capability (for EOA-based accounts). Note that this feature will likely be removed in any sort of quantum migration in a future EIP. 

#### Storage Layout

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE)

Slot layout:
- base_slot + 0: key_count (uint8, max 127)
- base_slot + 1 + (index * 2): key_type[index] (uint8)
- base_slot + 1 + (index * 2) + 1: key_data[index] (bytes)
```

The protocol validates signatures by reading these slots directly - no EVM execution required.

**Key limit**: Accounts may configure up to `MAX_KEYS` (127) keys. This limit ensures `key_index` values encode in a single byte in RLP (values 0-127 are single-byte; 128+ require two bytes).

#### 2D Nonce Storage

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE || "nonce")
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

### Auth Types

| Auth Type | ID | Algorithm | Public Key Size | Signature Size | Intrinsic Gas |
|----------|-----|-----------|-----------------|----------------|---------------|
| `K1` | `0x01` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | 6000 |
| `R1` | `0x02` | secp256r1 / P-256 | 33/65 bytes | 64 bytes | 7000 |
| `WEBAUTHN` | `0x03` | WebAuthn / Passkey | 65 bytes | Variable (max 2KB) | 12000 + calldata_gas |
| `BLS` | `0x04` | BLS12-381 | 48 bytes | 96 bytes | 8000 |
| `DELEGATE` | `0x05` | Delegated validation | 20 bytes (address) | Nested signature | 1000 + delegated |

**WebAuthn Gas Calculation**: The `calldata_gas` component charges 16 gas per non-zero byte and 4 gas per zero byte of the WebAuthn signature data (authenticatorData + clientDataJSON). This accounts for variable signature sizes while the 2KB (`MAX_SIGNATURE_SIZE`) cap prevents DoS attacks via oversized signatures.

**DELEGATE**: Delegates validation to another account's configuration. The `key_data` stores the delegated account's address (20 bytes). Only 1 hop is permitted—if the delegated account also has a `DELEGATE` key at the signing index, validation fails. See [DELEGATE Signature Format](#delegate-signature-format) for signature structure.

**BLS**: Enables signature aggregation across multiple transactions can be used to reduce data availability costs for rollups and L2s. (implementation outside of this scope.)

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,               // Sender address (20 bytes) | empty for EOA signature
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp or block number 
  max_priority_fee_per_gas,
  max_fee_per_gas,
  gas_limit,
  authorization_list, 
  account_initialization,  // For deploying new accounts if not using 7702 | empty
  calldata,
  sender_auth,
  fee_token,          // bytes: 0x for ETH, otherwise reserved
  payer_auth          // K1 signature (65 bytes) | empty
])
```

#### Fee Token Field

The `fee_token` field enables future token-based gas payment mechanisms. In this specification, it MUST be empty bytes (`0x`). 

When empty, gas is paid in ETH by either the sender (self-pay) or payer (sponsored).

Future EIPs may define token payment formats. The expected structure is:

```
token_address (20 bytes) || max_amount (32 bytes, optional)
```

Nodes MUST reject transactions where `fee_token` is non-empty until a future EIP defines valid formats.

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + sender_key_cost + calldata_cost + nonce_key_cost + init_code_cost
```

| Component | Value |
|-----------|-------|
| `nonce_key_cost` | 22,100 gas for first use of a `nonce_key` (cold SLOAD + SSTORE set), 5,000 gas for existing keys (cold SLOAD + warm SSTORE reset) |
| `init_code_cost` | 0 if `account_initialization` empty. Otherwise: 32,000 (CREATE2 base) + `init_code` calldata gas + code deposit cost (200 gas per deployed byte) |

The `nonce_key_cost` ensures 2D nonce channels incur appropriate storage costs:

- **New key**: Cold SLOAD (2,100) to check current value + SSTORE set (20,000) for 0→non-zero = 22,100 gas
- **Existing key**: Cold SLOAD (2,100) to read current nonce + warm SSTORE reset (2,900) to increment = 5,000 gas

Consider bounding `nonce_key` to a smaller range (e.g., `uint16` for 65,536 channels) to limit per-account state growth.

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address. **Required** for configured key signatures (`0xFF` prefix). **Optional** (empty) for EOA signatures—address recovered via ecrecover. |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Transaction invalid after this Unix timestamp |
| `max_priority_fee_per_gas` | Priority fee per gas unit (EIP-1559) |
| `max_fee_per_gas` | Maximum fee per gas unit (EIP-1559) |
| `gas_limit` | Maximum gas |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list |
| `account_initialization` | **Empty**: No account deployment. **Non-empty**: See [Account Initialization](#account-initialization) |
| `calldata` | Data delivered to `from` account |
| `sender_auth` | See [Signature Format](#signature-format) |
| `fee_token` | **Empty (0x)**: Gas paid in ETH. **Non-empty**: Reserved for future token payment EIPs |
| `payer_auth` | **65 bytes**: K1 signature, payer recovered via ecrecover. **Empty**: `from` pays ETH |

#### Signature Format

**EOA key**: Raw 65-byte ECDSA signature `(r || s || v)`. When using an EOA signature, the `from` field may be empty—the sender address is recovered via ecrecover.

**Configured key**: `0xFF || key_index || signature_data`. Requires `from` to be set (non-empty) so the protocol knows which account's configuration to validate against. The `key_index` must be in range `[0, 126]` (max `MAX_KEYS - 1`).

The `0xFF` prefix distinguishes configured key signatures from EOA signatures (since valid `v` values are 27 or 28).

##### DELEGATE Signature Format

For `DELEGATE` keys, `signature_data` contains a nested signature for the delegated account:

```
0xFF || key_index || nested_signature
```

Where `nested_signature` is a valid signature for the delegated account's configuration.

**Example**:

- Account A has K1 pubkey at `key_index=2`
- Account B has DELEGATE at `key_index=3` pointing to Account A
- Valid signature for Account B: `0xFF || 0x03 || 0xFF || 0x02 || ecdsa_sig`

The protocol validates `0xFF || 0x02 || ecdsa_sig` against Account A's config at index 2. Note this could also be its standard EOA signature (not required to be in precompile).

#### Signature Payload

Sender and payer use different type bytes for domain separation, preventing signature reuse attacks:

**Sender signature hash**:

```
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, calldata, fee_token
]))
```

**Payer signature hash** (when sponsoring):

```
keccak256(AA_PAYER_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  max_priority_fee_per_gas, max_fee_per_gas, gas_limit,
  authorization_list, account_initialization, calldata, fee_token
]))
```

The different type bytes (`AA_TX_TYPE` vs `AA_PAYER_TYPE`) ensure cryptographic domain separation—a valid sender signature cannot be replayed as a payer signature and vice versa.

**Sender signature**: Authorizes the transaction—calldata execution and gas parameters.

**Payer signature** (when present): Authorizes gas payment for this specific transaction. The payer agrees to pay ETH for gas. The payer does NOT control any execution.

### Payer Modes

Gas payment supports two modes based on the `payer_auth` field:

| Mode | `payer_auth` | Gas Payer |
|------|--------------|-----------|
| Self-pay | Empty | `from` |
| Sponsored | 65-byte K1 signature | Payer (ecrecover) |

**Mode details**:

| Mode | `payer_auth` | Description |
|------|--------------|-------------|
| **Self-pay** | Empty | Sender pays gas in ETH from their own balance |
| **Sponsored** | 65-byte K1 signature | Payer signs each transaction, authorizing gas payment for this specific transaction. Suitable for paymasters and trusted sponsors. |

### Execution

#### Calldata Delivery

The `calldata` is delivered to `from` via self-call:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `from` |
| `msg.value` | 0 |
| `data` | `calldata` |

For EOAs without code, the call succeeds with no effect. For smart accounts, execution begins at the contract's entry point.

#### Validation vs Execution

This proposal constrains **validation** to enshrined auth types but does not constrain **execution**. Once a transaction passes validation, the account's code can implement any logic: multisig, timelocks, spending limits, session keys, or arbitrary business rules. The `calldata` is always delivered to `from` as a self-call, ensuring wallet code controls interpretation.

**Multisig at EVM layer**: Native multisig is intentionally not included in this specification. Accounts requiring multisig validation can implement it in their smart contract code by verifying additional signatures within the `calldata`. The wallet can use `getCurrentSigner()` from the precompile to identify which key authorized the transaction, then require additional co-signers to have signed the `calldata` before executing operations.

#### Transaction Context

During execution, accounts can query the precompile for:

- **Payer**: `getCurrentPayer()` returns the gas payer address
- **Signer**: `getCurrentSigner()` returns `(keyIndex, keyType, publicKey)` used for authorization

**Optional opcodes** (`AAPAYER`, `AASIGNER`) may be added for gas-efficient access.

### Account Initialization

New smart contract accounts can be deployed with pre-configured keys in a single transaction using the `account_initialization` field:

```
account_initialization = rlp([
  user_salt,          // bytes32: User-chosen uniqueness factor
  init_code,          // bytes: Contract creation bytecode
  initial_keys        // Array of AuthKey structs
])
```

#### Address Derivation

Addresses are derived using CREATE2 with `ACCOUNT_CONFIG_PRECOMPILE` as the deployer. The `initial_keys` are incorporated into the salt to prevent front-running attacks where an attacker deploys with different keys:

```
effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(initial_keys))))
address = keccak256(0xff || ACCOUNT_CONFIG_PRECOMPILE || effective_salt || keccak256(init_code))[12:]
```

Users can receive funds at counterfactual addresses before deployment.

#### Portability

The `ACCOUNT_CONFIG_PRECOMPILE` address MAY also have a Solidity contract deployed at the same address on chains without native 8130 support. This contract implements the same `createAccount(bytes32 userSalt, bytes initCode, AuthKey[] initialKeys)` function using identical address derivation, enabling:

- Same address across 8130 and non-8130 chains
- Compatibility with ERC-4337 as an unstaked factory
- Progressive upgrade path as chains adopt 8130

#### Validation (Account Initialization)

When `account_initialization` is non-empty:

1. Parse `[user_salt, init_code, initial_keys]`
2. Compute `effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(initial_keys))))`
3. Compute `expected = keccak256(0xff || ACCOUNT_CONFIG_PRECOMPILE || effective_salt || keccak256(init_code))[12:]`
4. Require `from == expected`
5. Require `code_size(from) == 0` (account not yet deployed)
6. Validate `sender_auth` against `initial_keys[key_index]`

#### Execution (Account Initialization)

1. Deploy `init_code` at `from` using CREATE2 semantics with `effective_salt`
2. Register `initial_keys` in precompile storage for `from`
3. Proceed with calldata delivery

#### Default Account (Chain Operator Option)

For EOA accounts, chain operators may configure a **default account**—a wallet implementation automatically used for addresses without deployed code. This enables EOAs to submit AA transactions and use AA features (batching, gas sponsorship) without explicitly deploying code via EIP-7702.

**Behavior**:

- EOA submits AA transaction with valid signature
- During execution, if `from` has no code, use the configured default account bytecode
- The default account interprets `calldata` (e.g., as batched calls)
- Code injection occurs at transaction time; no permanent deployment required

**Configuration**: Chain operators specify the default account bytecode hash. This is an optional feature—chains may require explicit 7702 delegation instead.

### Validation Flow

#### Mempool Acceptance

1. Verify `sender_auth` size does not exceed `MAX_SIGNATURE_SIZE` (2KB)
2. Resolve sender address:
   - If `from` is non-empty: use provided address
   - If `from` is empty: recover address from `sender_auth` via ecrecover (EOA signature required)
3. If `account_initialization` is non-empty:
   - Parse `[user_salt, init_code, initial_keys]`
   - Verify address derivation matches `from` (see [Account Initialization](#account-initialization))
   - Verify `code_size(from) == 0`
   - Validate `sender_auth` against `initial_keys[key_index]`
4. Else validate `sender_auth` against sender's keys:
   - EOA signature: verify via ecrecover
   - Configured key (`0xFF` prefix): validate against sender's account configuration
5. Resolve payer from `payer_auth`:
   - 65 bytes: recover address via ecrecover (using `AA_PAYER_TYPE` for domain separation)
   - Empty: sender pays ETH
6. Verify `fee_token` is empty (reject if non-empty until future EIPs define valid formats)
7. Verify nonce, payer ETH balance, expiry
8. Mempool threshold: payer's pending sponsored transaction count must be below node-configured limits

#### Block Execution

1. ETH gas deduction from payer
2. Process authorization_list (EIP-7702)
3. Process account_initialization (if non-empty): deploy `init_code`, register `initial_keys`
4. Deliver calldata to `from` via self-call

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels.

**`eth_getTransactionReceipt`**: Should include `payer` field.

## Rationale

### Why a Precompile?

The Account Configuration Precompile serves two roles:

1. **Protocol-level validation**: The chain reads precompile storage directly to validate AA transaction signatures—no EVM execution required during validation. The protocol can keep these storage slots warm for efficient access. 
2. **Onchain interface**: Smart contracts call the precompile during execution to:
   - Modify keys (`addKey()`, `removeKey()`)
   - Query transaction context (`getCurrentSigner()`, `getCurrentPayer()`)
   - Validate signatures for 4337 compatibility (`validateSignature()`)

Having the precompile accessible onchain means that accounts can build any additional recovery logic into their code.

### Why CREATE2 for Account Initialization?

Account initialization uses CREATE2 with `ACCOUNT_CONFIG_PRECOMPILE` as the deployer address for cross-chain portability:

1. **Deterministic addresses**: Same `user_salt + init_code + initial_keys` produces the same address on any chain
2. **Pre-deployment funding**: Users can receive funds at counterfactual addresses before deployment
3. **Portability**: A Solidity contract at `ACCOUNT_CONFIG_PRECOMPILE` on non-8130 chains can implement identical address derivation, enabling the same address via ERC-4337
4. **Front-running prevention**: Including `initial_keys` in the salt prevents attackers from deploying with different keys to steal counterfactual funds

The protocol executes CREATE2 semantics directly without having to call into potentially arbitary code factories.

### Why No Native Multisig?

Native multisig is intentionally excluded to keep the protocol layer simple. Benefits of EVM-layer multisig:

1. **Flexibility**: Wallets can implement any multisig scheme (m-of-n, weighted, time-delayed, etc.)
2. **Upgradability**: Multisig logic can be updated without protocol changes
3. **Simplicity**: Protocol validation handles single signatures; complex policies live in wallet code
4. **Gas efficiency**: Avoid paying for multisig parsing in every transaction

Accounts can still achieve multisig by having the wallet contract use `getCurrentSigner()` to identify the authorizing key, then verify additional co-signer signatures from the `calldata` before executing operations.

### Why Fee Token Field?

The `fee_token` field enables future token-based gas payment without defining a new transaction type:

1. **Token payments**: A future EIP defines the packed format (`token_address || max_amount`) for gas abstraction with ERC-20 tokens.
2. **Signature binding**: The sender signs over `fee_token`, ensuring they explicitly authorize any token payment terms.

This approach provides upgrade flexibility while keeping the initial specification minimal and focused on ETH-based gas payment.

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `addKey()` on the precompile to add existing signing keys (K1, R1, WebAuthn, etc.) to auth config
2. **Upgrade wallet logic**: Update contract to use precompile as source of truth:
   - Call `getKey()` / `validateSignature()` for signature verification
   - Call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

**Key principle**: Wallet contracts should avoid duplicating key storage. The precompile is ideally the single source of truth for authentication (for these auth types). Wallets implement authorization logic (spending limits, timelocks, multisig) in their execution code using `getCurrentSigner()` context. Wallets are free to add any additional recovery mechanisms or other logic into their code.


## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys or using the new transaction type, note that code needs to be deployed to do anything useful as calldata is sent to the address and must be interpreted. Chains can opt in for default accounts to not require deploment via 7702 for EOA keys. 

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        uint8 keyType;
        bytes publicKey;
    }
    
    event KeyAdded(address indexed account, uint8 keyIndex, uint8 keyType, bytes publicKey);
    event KeyRemoved(address indexed account, uint8 keyIndex);
    event AccountCreated(address indexed account, bytes32 userSalt);
    
    // Account creation (factory interface for portability)
    function createAccount(bytes32 userSalt, bytes calldata initCode, AuthKey[] calldata initialKeys) external returns (address);
    function getAddress(bytes32 userSalt, bytes calldata initCode, AuthKey[] calldata initialKeys) external view returns (address);
    
    // Key management (max 127 keys per account)
    function addKey(uint8 keyType, bytes calldata publicKey) external returns (uint8 keyIndex);
    function removeKey(uint8 keyIndex) external;
    function getKeyCount(address account) external view returns (uint8);
    function getKey(address account, uint8 keyIndex) external view returns (uint8 keyType, bytes memory publicKey);
    function validateSignature(address account, uint8 keyIndex, bytes32 messageHash, bytes calldata signature) external view returns (bool);
    
    // Nonce management
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
    
    // Transaction context (only valid during AA transaction execution)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (uint8 keyIndex, uint8 keyType, bytes memory publicKey);
}
```

## Security Considerations

**Enshrined Validation**: Signature verification uses well-established algorithms before any EVM execution. Failed validation rejects transactions before mempool entry.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify account configuration. EOA key always retains authorization for recovery (if created with an EOA via 7702). Maximum 127 keys per account enforced by `MAX_KEYS` constant.

**Delegation**: `DELEGATE` key type limited to 1 hop to prevent loops.

**Fee Token Safety**: The `fee_token` field MUST be empty until future EIPs define valid formats. Nodes reject transactions with non-empty `fee_token`, preventing undefined behavior.

**Payer Security**: Sponsors must sign each transaction they pay for, ensuring explicit authorization of gas costs. The use of separate type bytes (`AA_TX_TYPE` vs `AA_PAYER_TYPE`) for sender and payer signatures provides cryptographic domain separation, preventing signature reuse attacks between roles.

**Signature Size Limits**: Signatures exceeding `MAX_SIGNATURE_SIZE` (2KB) MUST be rejected. This prevents DoS attacks via oversized WebAuthn signatures containing arbitrarily large `clientDataJSON` payloads. The 2KB limit accommodates typical WebAuthn signatures (37-byte authenticatorData + ~200-500 byte clientDataJSON + 128-byte signature data) with ample headroom.

**Account Initialization Security**: The `initial_keys` are incorporated into the CREATE2 salt derivation (`effective_salt = keccak256(abi.encode(user_salt, keccak256(abi.encode(initial_keys))))`). This prevents front-running attacks where an attacker observes a pending account initialization and deploys with different keys to steal funds sent to the counterfactual address.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
