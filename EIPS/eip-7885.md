---
eip: 7885
title: Precompile for NTT operations
description: Proposal to add a precompiled contract that performs number theoretical transformation (NTT) and inverse (InvNTT).
author: Renaud Dubois (@rdubois-crypto), Simon Masson (@simonmasson), Yoon Hyoung Lee (@yhl125)
discussions-to: https://ethereum-magicians.org/t/eip-9374-precompile-for-ntt-operations/22895
status: Draft
type: Standards Track
category: Core
created: 2025-02-12
---

## Abstract

This proposal creates a precompiled contract that performs NTT and Inverse NTT transformations. This provides a way to efficiently perform fast polynomial multiplication for post-quantum and STARK cryptography.

## Motivation

With the recent advances in quantum computing, there are increased concerns for the quantum threat against Ethereum. Today ECDSA is the EOA signature algorithms, which is vulnerable to attacks by quantum computers. Efficient replacement algorithms use polynomial multiplication as the core operation. Once NTT and Inverse NTT are available, the remaining of the verification algorithm is trivial. Choosing to integrate NTT and InvNTT instead of a specific algorithm provides agility, as DILITHIUM or FALCON or any equivalent can be implemented with a modest cost from those operators. NTT is also of interest to speed-up STARK verifiers. This single operator would thus benefit to both the Ethereum scaling and post-quantum threat mitigation.

## Specification

### Constants

| Name                | Value | Comment            |
|---------------------|-------|--------------------|
| NTT_FW              | 0x0f | precompile address |
| NTT_INV             | 0x10  | precompile address |
| NTT_VECMULMOD          | 0x11  | precompile address |
| NTT_VECADDMOD          | 0x12  | precompile address |

We introduce *four* separate precompiles to perform the following operations:

- NTT_FW - to perform the forward NTT transformation (Negative wrap convolution) with a gas cost of `600` gas,

- NTT_INV - to perform the inverse NTT transformation (Negative wrap convolution) with a gas cost of `600` gas,

- NTT_VECMULMOD - to perform vectorized modular multiplication with a gas cost formula defined in the corresponding section,

- NTT_VECADDMOD - to perform vectorized modular addition with a gas cost formula defined in the corresponding section.

### Field parameters

The NTT_FW and NTT_INV are fully defined by the following set of parameters:
Let $R$ be a cyclotomic ring of the form $R=\mathbb F_q[X]/(X^n+1)$. In these notations,

- $n$ is the degree and is a power of 2,

- $\mathbb F_q$ is the prime field where $q=1 \mod 2n$,

- $\omega$ is a $n$-th root of unity in $\mathbb F_q$,

- $\psi$ is a $2n$-th root of unity in $\mathbb F_q$.

Any element $a \in R$ is a polynomial of degree at most $n-1$ with integer coefficients, written
as $a=\sum_{i=0}^{n-1} a_iX^i$

### NTT_FW

The NTT transformation is described by the following algorithm.

**Input:** A vector $a = (a[0], a[1], \dots, a[n-1]) \in \mathbb F_q^n$ in standard order, where $q$ is a prime such that $q \equiv 1 \mod 2n$ and $n$ is a power of two, and a precomputed table $\Psi_\text{rev} \in \mathbb{Z}_q^n$ storing powers of $\psi$ in bit-reversed order.

**Output:** $a \leftarrow \text{NTT\_FW}(a)$ in bit-reversed order.

```plaintext
t ← n
for m = 1 to n-1 by 2m do
    t ← t / 2
    for i = 0 to m-1 do
        j1 ← 2 ⋅ i ⋅ t
        j2 ← j1 + t - 1
        S ← Ψrev[m + i]
        for j = j1 to j2 do
            U ← a[j]
            V ← a[j + t] ⋅ S
            a[j] ← (U + V) mod q
            a[j + t] ← (U - V) mod q
        end for
    end for
end for
return a
```

### NTT_INV

The Inverse NTT is described by the following algorithm.

**Input:** A vector $a = (a[0], a[1], \dots, a[n-1]) \in \mathbb F_q^n$ in bit-reversed order, where $q$ is a prime such that $q \equiv 1 \mod 2n$ and $n$ is a power of two, and a precomputed table $\Psi^{-1}_\text{rev} \in \mathbb F_q^n$ storing powers of $\psi^{-1}$ in bit-reversed order.

**Output:** $a \leftarrow \text{NTT\_INV}(a)$ in standard order.

```plaintext

t ← 1
for m = n to 1 by m/2 do
    j1 ← 0
    h ← m / 2
    for i = 0 to h-1 do
        j2 ← j1 + t - 1
        S ← Ψ⁻¹rev[h + i]
        for j = j1 to j2 do
            U ← a[j]
            V ← a[j + t]
            a[j] ← (U + V) mod q
            a[j + t] ← (U - V) ⋅ S mod q
        end for
        j1 ← j1 + 2t
    end for
    t ← 2t
end for
for j = 0 to n-1 do
    a[j] ← a[j] ⋅ n⁻¹ mod q
end for
return a
```

### NTT_VECMULMOD

The NTT_VECMULMOD is functions similarly to SIMD, but operates with larger input and output sizes.

**Input:** Two vectors $a = (a[0], a[1], \dots, a[n-1]), b=(b[0], b[1], \dots, b[n-1]) \in \mathbb F_q^n$ where $n$ and $q$ are defined above. 

**Output:** The element-wise product $(a[0]\cdot b[0] \mod q, a[1]\cdot b[1]\mod q, \dots, a[n-1]\cdot b[n-1] \mod q)$.

**Gas cost:** Denoting $k$ to be the smallest power of $2$ larger than $\log_2(q)$, the gas cost of this operation is $k\log_2(n) / 8$.

### NTT_VECADDMOD

The NTT_VECMULMOD is similar to SIMD in the functioning, but operates with larger sizes in input and output.

**Input:** Two vectors $a = (a[0], a[1], \dots, a[n-1]), b=(b[0], b[1], \dots, b[n-1]) \in \mathbb F_q^n$ where $n$ and $q$ are defined above. 

**Output:** The element-wise addition $(a[0]+ b[0] \mod q, a[1]+ b[1]\mod q, \dots, a[n-1]+ b[n-1] \mod q)$.

**Gas cost:** Denotoing $k$ to be the smallest power of $2$ larger than $\log_2(q)$, the gas cost of this operation is $k\log_2(n) /32$.

## Rationale

If $f$ and $g$ are two polynomials of $R$, then
$f\times g= \text{NTT\_INV}(\text{NTT\_VECMULMOD}(
\text{NTT\_FW}(a), \text{NTT\_FW}(b)))$ is equal to the product of $f$ and $g$ in $R$. The algorithm has a complexity of $n \log_2n$ rather than $n^2$ with the classical schoolbook multiplication algorithm.

### Gas Cost Analysis

The gas cost for NTT operations is set at **70,000 gas** to target a performance of approximately 50 mgas/s, consistent with existing precompiled contracts like ECRECOVER. Reference implementation benchmarks demonstrate that NTT precompiles achieve 47-50 mgas/s across major cryptographic standards with this gas cost, validating the cost model.

A fixed cost approach is employed because NTT computation complexity is dominated by parameter generation rather than input processing, making costs largely independent of ring degree within practical cryptographic ranges. This simplifies gas estimation for developers while maintaining predictable execution costs.

### Fields of interest

The implementation applies for many fields of interest for cryptography. In particular, the design applies for:

- FALCON: $q=3.2^{12}+1$ (one of the NIST winners for post-quantum signature scheme),

- DILITHIUM: $q=2^{23}-2^{13}+1$ (one of the NIST winners for post-quantum signature scheme),

- KYBER: $q=13.2^8+1$ (one of the NIST winners for post-quantum key encapsulation mechanism),

- Babybear: $q=15.2^{27}+1$ (Risc0),

- Goldilocks: $q=2^{64}-2^{32}+1$ (Polygon's Plonky2),

- M31: $q=2^{31}-1$ (Circle STARKS, STwo, Plonky3),

- StarkCurve: $q=2^{251}+17.2^{192}+1$

### Benchmarks

#### Pure solidity

To illustrate the interest of the precompile, the assets provide the measured gas const for a single NTT and extrapolates the minimal gas cost taking into account the required number of NTT_FW and NTT_INV. The provided assets use pure Yul optimizations, with memory access hacks. It is unlikely that more than one order of magnitude could be spared on such a minimal code. 

|Use case| Parameters                   | single NTT gas cost         |  Required NTT(FW/INV)    | Estimated NTT/Full cost |
|--|------------------------|---------------------|---------------------|---|
|Falcon| $q=12289, n=512$       | 1.8 M | 1 NTTFW+1 NTTINV |3.6 M| 
|Dilithium| $q=2^{23}-2^{13}+1, n=256$| 460K | 4 NTTFW +1 NTTINV|2.3M|

Falcon cost has been measured over a full implementation and is compliant to the estimation. Dilithium cost is evaluated assuming

This demonstrates that using pure solidity enables L2s with low gas fees to experiment with FALCON in the short term, whereas it is too expensive to do so on L1.
Adopting this EIP, the signature verification of Falcon can be reduced to **1500** gas, and a similar result is expected for Dilithium.
Adopting the hash function as a separate EIP would enable a gas verification cost of 2000 gas.
This is in line with the ratio looking at SUPERCOP implementations.

#### Native Client Implementation

A native Go implementation has been developed for op-geth using the Lattigo v6 library for high-performance lattice cryptography operations.

```
BenchmarkPrecompiledNTTCryptoStandards/NTT-Falcon-512-Gas=70000-4
    2511     1435522 ns/op     70000 gas/op        48.76 mgas/s
BenchmarkPrecompiledNTTCryptoStandards/NTT-Kyber-128-Gas=70000-4
    2587     1412883 ns/op     70000 gas/op        49.54 mgas/s
BenchmarkPrecompiledNTTCryptoStandards/NTT-Dilithium-256-Gas=70000-4
    2498     1455829 ns/op     70000 gas/op        48.08 mgas/s

BenchmarkPrecompiledEcrecover/-Gas=3000-4
   61080      59970 ns/op      3000 gas/op        50.02 mgas/s
```

The benchmark demonstrates that the NTT precompile maintains competitive throughput with existing precompiled contracts like ECRECOVER, processing approximately 48-50 million gas per second despite significantly higher computational complexity.

## Backwards Compatibility

There are no backward compatibility questions.

## Test Cases

The functional tests applied to the reference implementation include algorithm validation with known test vectors for post-quantum cryptographic standards (FALCON, DILITHIUM, KYBER), round-trip verification, and error handling for malformed inputs.

Benchmark tests with pre-calculated data validate performance characteristics across different ring degrees and moduli. The integration test suite provides comprehensive validation through real blockchain transactions with >99% accuracy between gas estimation and actual consumption.

Detailed benchmark results are available in the EIP assets:

- [NTT Crypto Standards Benchmark](../assets/eip-7885/op-geth/benchmark_results/BenchmarkPrecompiledNTTCryptoStandards)
- [ECRECOVER Comparison Benchmark](../assets/eip-7885/op-geth/benchmark_results/BenchmarkPrecompiledEcrecover)
- [Integration Test Results](../assets/eip-7885/integration-test/README.md)

## Reference Implementation

- a python reference code provided in the assets of this EIP

- a solidity reference code provided in the assets of this EIP

- a Go implementation integrated in OP-Geth, provided in the assets of this EIP

- TypeScript integration test suite using Viem for end-to-end validation

All implementations have been validated over a large base of reference vectors, and implementing both FALCON and DILITHIUM algorithms as demonstration of the usefulness of the precompile.

## Security Considerations

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
