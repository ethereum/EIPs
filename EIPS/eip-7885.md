---
eip: 7885
title: Precompile for NTT operations
description: Proposal to add a precompiled contract that performs number theoretical transformation (NTT) and inverse (InvNTT).
author: Renaud Dubois (@rdubois-crypto), Simon Masson (@simonmasson), Yoon Hyoung Lee (@yhl125)
discussions-to: https://ethereum-magicians.org/t/eip-9374-precompile-for-ntt-operations/22895
status: Draft
type: Standards Track
category: Core
created: 2025-02-12
---

## Abstract

This proposal creates a precompiled contract that performs NTT and Inverse NTT transformations. This provides a way to efficiently perform fast polynomial multiplication for post-quantum and STARK cryptography.

## Motivation

With the recent advances in quantum computing, there are increased concerns for the quantum threat against Ethereum. Today ECDSA is the EOA signature algorithms, which is vulnerable to attacks by quantum computers. Efficient replacement algorithms use polynomial multiplication as the core operation. Once NTT and Inverse NTT are available, the remaining of the verification algorithm is trivial. Choosing to integrate NTT and InvNTT instead of a specific algorithm provides agility, as DILITHIUM or FALCON or any equivalent can be implemented with a modest cost from those operators. NTT is also of interest to speed-up STARK verifiers. This single operator would thus benefit to both the Ethereum scaling and post-quantum threat mitigation.

## Specification

### Constants

| Name                | Value | Comment            |
|---------------------|-------|--------------------|
| NTT_FW              | 0x0f | precompile address |
| NTT_INV             | 0x10  | precompile address |
| NTT_VECMULMOD          | 0x11  | precompile address |
| NTT_VECADDMOD          | 0x12  | precompile address |

We introduce *four* separate precompiles to perform the following operations:

- NTT_FW - to perform the forward NTT transformation (Negative wrap convolution) with a gas cost of `600` gas,

- NTT_INV - to perform the inverse NTT transformation (Negative wrap convolution) with a gas cost of `600` gas,

- NTT_VECMULMOD - to perform vectorized modular multiplication with a gas cost formula defined in the corresponding section,

- NTT_VECADDMOD - to perform vectorized modular addition with a gas cost formula defined in the corresponding section.

### Field parameters

The NTT_FW and NTT_INV are fully defined by the following set of parameters:
Let $R$ be a cyclotomic ring of the form $R=\mathbb F_q[X]/(X^n+1)$. In these notations,

- $n$ is the degree and is a power of 2,

- $\mathbb F_q$ is the prime field where $q=1 \mod 2n$,

- $\omega$ is a $n$-th root of unity in $\mathbb F_q$,

- $\psi$ is a $2n$-th root of unity in $\mathbb F_q$.

Any element $a \in R$ is a polynomial of degree at most $n-1$ with integer coefficients, written
as $a=\sum_{i=0}^{n-1} a_iX^i$

### NTT_FW

The NTT transformation is described by the following algorithm.

**Input:** A vector $a = (a[0], a[1], \dots, a[n-1]) \in \mathbb F_q^n$ in standard order, where $q$ is a prime such that $q \equiv 1 \mod 2n$ and $n$ is a power of two, and a precomputed table $\Psi_\text{rev} \in \mathbb{Z}_q^n$ storing powers of $\psi$ in bit-reversed order.

**Output:** $a \leftarrow \text{NTT\_FW}(a)$ in bit-reversed order.

```plaintext
t ← n
for m = 1 to n-1 by 2m do
    t ← t / 2
    for i = 0 to m-1 do
        j1 ← 2 ⋅ i ⋅ t
        j2 ← j1 + t - 1
        S ← Ψrev[m + i]
        for j = j1 to j2 do
            U ← a[j]
            V ← a[j + t] ⋅ S
            a[j] ← (U + V) mod q
            a[j + t] ← (U - V) mod q
        end for
    end for
end for
return a
```

### NTT_INV

The Inverse NTT is described by the following algorithm.

**Input:** A vector $a = (a[0], a[1], \dots, a[n-1]) \in \mathbb F_q^n$ in bit-reversed order, where $q$ is a prime such that $q \equiv 1 \mod 2n$ and $n$ is a power of two, and a precomputed table $\Psi^{-1}_\text{rev} \in \mathbb F_q^n$ storing powers of $\psi^{-1}$ in bit-reversed order.

**Output:** $a \leftarrow \text{NTT\_INV}(a)$ in standard order.

```plaintext

t ← 1
for m = n to 1 by m/2 do
    j1 ← 0
    h ← m / 2
    for i = 0 to h-1 do
        j2 ← j1 + t - 1
        S ← Ψ⁻¹rev[h + i]
        for j = j1 to j2 do
            U ← a[j]
            V ← a[j + t]
            a[j] ← (U + V) mod q
            a[j + t] ← (U - V) ⋅ S mod q
        end for
        j1 ← j1 + 2t
    end for
    t ← 2t
end for
for j = 0 to n-1 do
    a[j] ← a[j] ⋅ n⁻¹ mod q
end for
return a
```

### NTT_VECMULMOD

The NTT_VECMULMOD is functions similarly to SIMD, but operates with larger input and output sizes.

**Input:** Two vectors $a = (a[0], a[1], \dots, a[n-1]), b=(b[0], b[1], \dots, b[n-1]) \in \mathbb F_q^n$ where $n$ and $q$ are defined above. 

**Output:** The element-wise product $(a[0]\cdot b[0] \mod q, a[1]\cdot b[1]\mod q, \dots, a[n-1]\cdot b[n-1] \mod q)$.

**Gas cost:** Denoting $k$ to be the smallest power of $2$ larger than $\log_2(q)$, the gas cost of this operation is $k\log_2(n) / 8$.

### NTT_VECADDMOD

The NTT_VECMULMOD is similar to SIMD in the functioning, but operates with larger sizes in input and output.

**Input:** Two vectors $a = (a[0], a[1], \dots, a[n-1]), b=(b[0], b[1], \dots, b[n-1]) \in \mathbb F_q^n$ where $n$ and $q$ are defined above. 

**Output:** The element-wise addition $(a[0]+ b[0] \mod q, a[1]+ b[1]\mod q, \dots, a[n-1]+ b[n-1] \mod q)$.

**Gas cost:** Denotoing $k$ to be the smallest power of $2$ larger than $\log_2(q)$, the gas cost of this operation is $k\log_2(n) /32$.

## Rationale

If $f$ and $g$ are two polynomials of $R$, then
$f\times g= \text{NTT\_INV}(\text{NTT\_VECMULMOD}(
\text{NTT\_FW}(a), \text{NTT\_FW}(b)))$ is equal to the product of $f$ and $g$ in $R$. The algorithm has a complexity of $n \log_2n$ rather than $n^2$ with the classical schoolbook multiplication algorithm.

### Gas Cost Analysis

The gas cost model for EIP-7885 precompiles is designed to target approximately 50 mgas/s performance, consistent with existing precompiled contracts like ECRECOVER.

#### NTT Precompile (0x12) - Fixed Cost Model

**Gas Cost**: 70,000 gas (fixed)

**Rationale**: A fixed cost approach is employed because NTT computation complexity is dominated by parameter generation and ring initialization rather than input processing. Within practical cryptographic ranges (n=256 to n=512), execution costs remain largely independent of ring degree, making a fixed cost model more predictable for developers.

**Benchmark Validation**: Reference implementation demonstrates consistent 48-50 mgas/s performance across all major cryptographic standards:
- Falcon-512: 48.76 mgas/s
- Kyber-128: 49.54 mgas/s
- Dilithium-256: 48.08 mgas/s

#### Vector Operations (0x13, 0x14) - Dynamic Cost Model

**VECMULMOD Gas Cost**: `72,000 + (7 × N)`

**VECADDMOD Gas Cost**: `72,000 + (5 × N)`

**Cost Components**:
1. **Base Cost (72,000 gas)**: Memory allocation overhead dominates execution time (~88% of total cost), justifying the large base cost that is independent of operation complexity.

2. **Per-Element Compute Cost**:
   - VECMULMOD: 7 gas per element (Barrett reduction multiplication)
   - VECADDMOD: 5 gas per element (simpler modular reduction)

**Benchmark Validation**: The dynamic cost model achieves target performance (min-max from 5 runs):
- Falcon-512 VECMULMOD (75,584 gas): 49.94–51.25 mgas/s
- Falcon-512 VECADDMOD (74,560 gas): 49.90–50.58 mgas/s
- Kyber-128 VECMULMOD (72,896 gas): 50.30–51.05 mgas/s
- Kyber-128 VECADDMOD (72,640 gas): 48.01–50.56 mgas/s
- Dilithium-256 VECMULMOD (73,792 gas): 49.60–50.14 mgas/s
- Dilithium-256 VECADDMOD (73,280 gas): 48.57–49.98 mgas/s

The gas cost formulas accurately reflect actual execution costs while maintaining the ~50 mgas/s performance target across all tested cryptographic standards.

### Fields of interest

The implementation applies for many fields of interest for cryptography. In particular, the design applies for:

- FALCON: $q=3.2^{12}+1$ (one of the NIST winners for post-quantum signature scheme),

- DILITHIUM: $q=2^{23}-2^{13}+1$ (one of the NIST winners for post-quantum signature scheme),

- KYBER: $q=13.2^8+1$ (one of the NIST winners for post-quantum key encapsulation mechanism),

- Babybear: $q=15.2^{27}+1$ (Risc0),

- Goldilocks: $q=2^{64}-2^{32}+1$ (Polygon's Plonky2),

- M31: $q=2^{31}-1$ (Circle STARKS, STwo, Plonky3),

- StarkCurve: $q=2^{251}+17.2^{192}+1$

### Benchmarks

#### Pure solidity

To illustrate the interest of the precompile, the assets provide the measured gas const for a single NTT and extrapolates the minimal gas cost taking into account the required number of NTT_FW and NTT_INV. The provided assets use pure Yul optimizations, with memory access hacks. It is unlikely that more than one order of magnitude could be spared on such a minimal code. 

|Use case| Parameters                   | single NTT gas cost         |  Required NTT(FW/INV)    | Estimated NTT/Full cost |
|--|------------------------|---------------------|---------------------|---|
|Falcon| $q=12289, n=512$       | 1.8 M | 1 NTTFW+1 NTTINV |3.6 M| 
|Dilithium| $q=2^{23}-2^{13}+1, n=256$| 460K | 4 NTTFW +1 NTTINV|2.3M|

Falcon cost has been measured over a full implementation and is compliant to the estimation. Dilithium cost is evaluated assuming

This demonstrates that using pure solidity enables L2s with low gas fees to experiment with FALCON in the short term, whereas it is too expensive to do so on L1.
Adopting this EIP, the signature verification of Falcon can be reduced to **1500** gas, and a similar result is expected for Dilithium.
Adopting the hash function as a separate EIP would enable a gas verification cost of 2000 gas.
This is in line with the ratio looking at SUPERCOP implementations.

#### Native Client Implementation

A native Go implementation has been developed for op-geth using the Lattigo v6 library for high-performance lattice cryptography operations. The implementation includes three precompiled contracts deployed at addresses `0x12`, `0x13`, and `0x14` in the Optimism Isthmus hardfork:

**NTT Precompile (0x12)**:
- Fixed gas cost: 70,000 gas
- Supports both forward and inverse NTT transformations
- Input format: operation (1 byte) + ring_degree (4 bytes) + modulus (8 bytes) + coefficients (8*N bytes)

**VECMULMOD Precompile (0x13)**:
- Dynamic gas cost: `72,000 + (7 × N)`
- Element-wise modular multiplication using Barrett reduction
- Memory-aware formula with 72,000 base cost

**VECADDMOD Precompile (0x14)**:
- Dynamic gas cost: `72,000 + (5 × N)`
- Element-wise modular addition
- Cheaper compute cost than multiplication (5 vs 7 gas per element)

Benchmark results on Intel(R) Xeon(R) CPU @ 2.20GHz:

```
BenchmarkPrecompiledNTTCryptoStandards/NTT-Falcon-512-Gas=70000-4
    2511     1435522 ns/op     70000 gas/op        48.76 mgas/s
BenchmarkPrecompiledNTTCryptoStandards/NTT-Kyber-128-Gas=70000-4
    2587     1412883 ns/op     70000 gas/op        49.54 mgas/s
BenchmarkPrecompiledNTTCryptoStandards/NTT-Dilithium-256-Gas=70000-4
    2498     1455829 ns/op     70000 gas/op        48.08 mgas/s

BenchmarkPrecompiledNTTVecOpsCryptoStandards/VECMULMOD-Falcon-512-Gas=75240-4
    2424     1488528 ns/op     75584 gas/op        50.77 mgas/s
BenchmarkPrecompiledNTTVecOpsCryptoStandards/VECADDMOD-Falcon-512-Gas=70120-4
    2432     1482580 ns/op     74560 gas/op        50.29 mgas/s

BenchmarkPrecompiledEcrecover/-Gas=3000-4
   61080      59970 ns/op      3000 gas/op        50.02 mgas/s
```

The benchmarks demonstrate that all NTT precompiles maintain competitive throughput with existing precompiled contracts like ECRECOVER, processing approximately 48-50 million gas per second across all operations. The gas cost formulas accurately reflect actual execution costs while maintaining ~50 mgas/s performance targets.

## Backwards Compatibility

There are no backward compatibility questions.

## Test Cases

The reference implementation includes comprehensive test coverage across multiple layers:

### NTT Precompile Tests (0x12)

**Malformed Input Tests** - 8 test cases covering:
- Invalid operation codes (values other than 0 or 1)
- Invalid ring degrees (non-power-of-2, < 16)
- Zero or non-NTT-friendly moduli (not congruent to 1 mod 2N)
- Coefficients exceeding modulus bounds
- Input length mismatches

**Functional Tests**:
- Forward NTT transformation with ring degree 16, modulus 97
- Inverse NTT transformation ensuring `INTT(NTT(x)) = x`
- Round-trip validation for data integrity

**Crypto Standards Benchmarks**:
- Falcon-512: n=512, q=12289
- Kyber-128: n=256, q=3329
- Dilithium-256: n=256, q=8380417

### Vector Operations Tests (0x13, 0x14)

**Unified Malformed Input Tests** - 7 test cases covering:
- Invalid ring degrees for both VECMULMOD and VECADDMOD
- Zero or non-NTT-friendly moduli
- Input length mismatches (expecting 2*N vectors)
- Coefficient bounds validation

**Functional Tests**:
- Element-wise multiplication: `result[i] = (a[i] * b[i]) mod q`
- Element-wise addition: `result[i] = (a[i] + b[i]) mod q`
- Validation with small test vectors (ring degree 16, modulus 97)

**Crypto Standards Benchmarks** - Performance validation with:
- Falcon-512 parameters (VECMULMOD: 75,584 gas, VECADDMOD: 74,560 gas)
- Kyber-128 parameters (VECMULMOD: 72,896 gas, VECADDMOD: 72,640 gas)
- Dilithium-256 parameters (VECMULMOD: 73,792 gas, VECADDMOD: 73,280 gas)

### Integration Tests

The integration test suite provides end-to-end validation through real blockchain transactions using TypeScript and Viem, demonstrating >99% accuracy between gas estimation and actual consumption.

Detailed test results and benchmark data are available in the EIP assets:

- [NTT Crypto Standards Benchmark](../assets/eip-7885/op-geth/benchmark_results/BenchmarkPrecompiledNTTCryptoStandards)
- [Vector Operations Benchmark](../assets/eip-7885/op-geth/benchmark_results/BenchmarkPrecompiledNTTVecOpsCryptoStandards)
- [ECRECOVER Comparison Benchmark](../assets/eip-7885/op-geth/benchmark_results/BenchmarkPrecompiledEcrecover)
- [Integration Test Results](../assets/eip-7885/integration-test/README.md)

## Reference Implementation

- a python reference code provided in the assets of this EIP

- a solidity reference code provided in the assets of this EIP

- a Go implementation integrated in OP-Geth, provided in the assets of this EIP

- TypeScript integration test suite using Viem for end-to-end validation

All implementations have been validated over a large base of reference vectors, and implementing both FALCON and DILITHIUM algorithms as demonstration of the usefulness of the precompile.

## Security Considerations

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
