---
eip: 8130
title: Account Abstraction by Account Configurations
description: Enable account abstraction feature set through onchain account configurations and a new transaction type
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 2718, 2930, 7702
---

## Abstract

This proposal introduces a standardized validation mechanism for account abstraction using onchain account configurations to define accepted keys and key types. Unlike EIP-7701/RIP-7560 which permit arbitrary validation code, this approach restricts validation to predefined key types, ensuring protocol simplicity and secure account abstraction without EVM execution during validation. A new transaction type leverages this mechanism with native gas abstraction support.

## Motivation

Enable account abstraction benefits—batching, gas sponsorship, custom authentication, programmable logic—while allowing nodes to validate transactions via simple state checks without EVM execution. This enables highly optimizable and performant transaction validation and mempool implementations and removes the need for additional reputation systems to ensure DoS prevention.

Having the account auth configurations accessible and managable via the EVM enables accounts to build out any additional recovery mechanisms they desire. Calldata delivery to the account address only means the wallet can built out any additional checks for validation they desire.

### Existing Solutions

| Solution | Approach | Limitations |
|----------|----------|-------------|
| ERC-4337 | Application-layer abstraction | Complex mempool rules (ERC-7562), high gas overhead, entrypoint costs |
| [EIP-7701](./eip-7701.md) | Protocol-level with arbitrary validation | Complex mempool rules, major protocol changes |

This proposal addresses these by:

- **Simplifying Validation**: Predefined key types eliminate EVM execution during validation
- **Optimizable Mempool and Validation Logic**: Validators use only state lookups, mempools can invalidate transactions quickly via (flash)block access lists.
- **Reducing Gas Costs**: No entrypoint contracts or associated overhead
- **Native Multisig**: Protocol-level threshold signatures without execution-time validation
- **Ensuring Extensibility**: Supports future quantum-safe algorithms via new key types
- **Maintaining Compatibility**: Coexists with EIP-7702 and ERC-4337

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `AA_TX_TYPE` | TBD | [EIP-2718](./eip-2718.md) transaction type |
| `AA_BASE_COST` | 15000 | Base intrinsic gas cost |
| `ACCOUNT_CONFIG_PRECOMPILE` | TBD | Account Configuration precompile address |
| `TOKEN_PAYMENT_REGISTRY` | TBD | Token Payment Registry address |
| `TOKEN_TRANSFER_COST` | 3000 | Gas cost for token payment transfer |
| `NATIVE_PAYER` | TBD | (Optional per chain operator) Native gas AMM payer precompile address  |

### Account Configuration

Each account can configure an ordered array of authorized keys through the Account Configuration Precompile at `ACCOUNT_CONFIG_PRECOMPILE`. Only `msg.sender` can modify their own configuration. This enables existing ERC-4337 smart accounts to register keys and migrate to native AA without redeployment.

**Default behavior**: An empty configuration `[]` means only the account's EOA key can authorize transactions. The EOA key always retains authorization regardless of configured keys, ensuring recovery capability.

#### Storage Layout

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE)

Slot layout:
- base_slot + 0: key_count (uint8)
- base_slot + 1: required_signatures (uint8) - threshold for multisig, default 1
- base_slot + 2 + (index * 2): key_type[index] (uint8)
- base_slot + 2 + (index * 2) + 1: key_data[index] (bytes)
```

The protocol validates signatures by reading these slots directly - no EVM execution required.

#### 2D Nonce Storage

```
Base slot: keccak256(account_address || ACCOUNT_CONFIG_PRECOMPILE || "nonce")
Nonce slot: base_slot + nonce_key
Value: current_sequence (uint64)
```

### Key Types

| Key Type | ID | Algorithm | Public Key Size | Signature Size | Intrinsic Gas |
|----------|-----|-----------|-----------------|----------------|---------------|
| `K1` | `0x01` | secp256k1 (ECDSA) | 33/65 bytes | 65 bytes | 6000 |
| `R1` | `0x02` | secp256r1 / P-256 | 33/65 bytes | 64 bytes | 7000 |
| `WEBAUTHN` | `0x03` | WebAuthn / Passkey | 65 bytes | Variable | 12000 |
| `BLS` | `0x04` | BLS12-381 | 48 bytes | 96 bytes | 8000 |
| `DELEGATE` | `0x05` | Delegated validation | 20 bytes (address) | Nested signature | 1000 + delegated |

**DELEGATE**: Delegates validation to another account's configuration. The `key_data` stores the delegated account's address (20 bytes). Only 1 hop is permitted—if the delegated account also has a `DELEGATE` key at the signing index, validation fails. See [DELEGATE Signature Format](#delegate-signature-format) for signature structure.

**BLS**: Enables signature aggregation across multiple transactions can be used to reduce data availability costs for rollups and L2s. (implementation outside of this scope.)

### AA Transaction Type

A new [EIP-2718](./eip-2718.md) transaction with type `AA_TX_TYPE`:

```
AA_TX_TYPE || rlp([
  chain_id,
  from,
  nonce_key,          // 2D nonce channel (uint192)
  nonce_sequence,     // Sequence within channel (uint64)
  expiry,             // Unix timestamp or block number 
  gas_price,
  gas_limit,
  access_list,
  authorization_list, 
  calldata,
  payment_token,      // Optional: [token_address, max_amount] or []
  sender_signature,
  payer_auth          // K1 signature (65 bytes) | payer address (20 bytes) | empty
])
```

#### Intrinsic Gas

```
intrinsic_gas = AA_BASE_COST + sender_key_cost + calldata_cost + token_transfer_cost + nonce_key_cost
```

| Component | Value |
|-----------|-------|
| `token_transfer_cost` | `TOKEN_TRANSFER_COST` if `payment_token` is non-empty, otherwise 0 |
| `nonce_key_cost` | `SSTORE_SET_GAS` (20,000) for first use of a `nonce_key`, 0 for existing keys |

The `nonce_key_cost` ensures new 2D nonce channels incur appropriate storage costs. Consider bounding `nonce_key` to a smaller range (e.g., `uint16` for 65,536 channels) to limit per-account state growth.

#### Field Definitions

| Field | Description |
|-------|-------------|
| `chain_id` | Chain ID per [EIP-155](./eip-155.md) |
| `from` | Sending account address |
| `nonce_key` | 2D nonce channel key (uint192) for parallel transaction processing |
| `nonce_sequence` | Must equal current sequence for `(from, nonce_key)`. Incremented after inclusion regardless of execution outcome |
| `expiry` | Transaction invalid after this Unix timestamp |
| `gas_price` | Price per gas unit |
| `gas_limit` | Maximum gas |
| `access_list` | [EIP-2930](./eip-2930.md) access list |
| `authorization_list` | [EIP-7702](./eip-7702.md) authorization list |
| `calldata` | Data delivered to `from` account |
| `payment_token` | Optional `[token_address, max_amount]` for token gas payment. See note below. |
| `sender_signature` | See [Signature Format](#signature-format) |
| `payer_auth` | **65 bytes**: K1 signature, payer recovered via ecrecover. **20 bytes**: Payer address (permissionless or `NATIVE_PAYER`) otherwise `from` pays ETH |

> **Note on `max_amount`:** For permissioned payers (65-byte signature), `max_amount` is the exact token amount transferred—the payer's signature constitutes agreement to this price. For permissionless and native payers, `max_amount` is a cap protecting the sender from oracle price fluctuations.

#### Signature Format

**EOA key**: Raw 65-byte ECDSA signature `(r || s || v)`

**Configured key**: `0xFF || key_index || signature_data`

The `0xFF` prefix distinguishes configured key signatures from EOA signatures.

##### Multisig Signature Format

For accounts with `required_signatures > 1`, multiple signatures are concatenated:

```
signature_1 || signature_2 || ... || signature_n
```

Each signature is either an EOA signature (65 bytes, `v ∈ {27,28}`) or a configured key signature (`0xFF || key_index || sig`). The parser distinguishes them by checking if the first byte is `0xFF`.

**Validation rules**:

1. Parse signatures sequentially
2. Track which key indices have signed (no duplicates allowed)
3. EOA signature counts as one valid signature (if known)
4. Transaction valid if `unique_valid_signatures >= required_signatures`

**Examples**:

2-of-3 with EOA + configured key at index 2:

```
ecdsa_sig (65 bytes) || 0xFF || 0x02 || ecdsa_sig (65 bytes)
```

##### DELEGATE Signature Format

For `DELEGATE` keys, `signature_data` contains a nested signature for the delegated account:

```
0xFF || key_index || nested_signature
```

Where `nested_signature` is a valid signature for the delegated account's configuration.

**Example**:

- Account A has K1 pubkey at `key_index=2`
- Account B has DELEGATE at `key_index=3` pointing to Account A
- Valid signature for Account B: `0xFF || 0x03 || 0xFF || 0x02 || ecdsa_sig`

The protocol validates `0xFF || 0x02 || ecdsa_sig` against Account A's config at index 2. Note this could also be its standard EOA signature (not required to be in precompile).

#### Signature Payload

Both sender and payer sign the same payload:

```
keccak256(AA_TX_TYPE || rlp([
  chain_id, from, nonce_key, nonce_sequence, expiry,
  gas_price, gas_limit, access_list, authorization_list,
  calldata, payment_token
]))
```

**Sender signature**: Authorizes the transaction—calldata execution, gas parameters, and token payment terms.

**Payer signature** (permissioned mode): Authorizes gas payment for this specific transaction. The payer agrees to pay ETH for gas and receive `payment_token` at the implied exchange rate. The payer does NOT control any execution.

### Token Payments

Tokens must be registered in the Token Payment Registry before use for gas payment. The registry stores token metadata; pricing is determined per-payer.

#### Token Configuration Storage

```
Base slot: keccak256(token_address || TOKEN_PAYMENT_REGISTRY || "config")

- base_slot + 0: balance_slot_index (uint256)
- base_slot + 1: packed config (uint256)
    - byte 0: token_decimals (uint8)
    - byte 1: active (bool)
    - byte 2: highBitBlockList (bool)
    - bytes 3-31: reserved
```

#### Blocklist Storage

When `highBitBlockList` is false, blocklist status is stored separately:

```
Blocklist slot: keccak256(token_address || account_address || TOKEN_PAYMENT_REGISTRY || "blocklist")
Value: bool
```

When `highBitBlockList` is true, bit 255 of the token's balance slot indicates blocklist status—no separate storage read required.

#### Token Transfer Flow

When `payment_token` is set:

1. Read raw balance from token's `balance_slot_index` for sender

2. Verify sender is not blocklisted (via bit or blocklist storage)
3. Determine `token_cost`:
   - **Permissioned payer** (65-byte signature): `token_cost = max_amount` (payer signed agreeing to this amount)
   - **Permissionless payer** (20-byte address): read exchange rate from payer's oracle config, compute `token_cost`, validate `token_cost <= max_amount`
   - **Native payer**: compute from `NATIVE_PAYER` pricing, validate `token_cost <= max_amount`
4. Validate `balance >= token_cost`
5. Update balances: sender decreases, payer increases
6. Emit `Transfer(from, payer, token_cost)`

Token transfers occur outside EVM execution, before calldata delivery.

### Payer Modes

Gas payment supports multiple modes based on the `payer_auth` and `payment_token` fields:

| Case | `payer_auth` | `payment_token` | Gas Payer | Token Recipient |
|------|--------------|-----------------|-----------|-----------------|
| Sender pays ETH | Empty | Empty | `from` | N/A |
| Sponsor pays ETH | 65-byte K1 signature | Empty | Payer (ecrecover) | N/A |
| Sponsor receives token | 65-byte K1 signature | `[token, max]` | Payer (ecrecover) | Payer |
| Permissionless sponsor | 20-byte address | `[token, max]` | Payer address | Payer |
| Native AMM | `NATIVE_PAYER` or empty | `[token, max]` | `NATIVE_PAYER` | `NATIVE_PAYER` |

**Mode details**:

| Mode | `payer_auth` | Description |
|------|--------------|-------------|
| **Permissioned** | 65-byte K1 signature | Payer signs each transaction. Suitable for trusted sponsors. Any registered token can be used—the signature authorizes the specific transaction and exchange rate. |
| **Permissionless** | 20-byte address | References a registered payer config. No signature required per transaction. |
| **Native** | `NATIVE_PAYER` address or empty | Chain-operated gas abstraction. When empty with `payment_token` set, protocol implicitly uses `NATIVE_PAYER`. Explicit address enables unified onchain lookup. |

### Permissionless Payer Configuration

Permissionless payers register onchain to accept token payments without signing each transaction. Each payer specifies their own oracle per token, enabling a competitive gas market.

#### Storage

```
Base slot: keccak256(payer_address || ACCOUNT_CONFIG_PRECOMPILE || "payer")

- base_slot + 0: active (bool)

Per-token config:
Token slot: keccak256(token_address || payer_address || ACCOUNT_CONFIG_PRECOMPILE || "payer_token")

- token_slot + 0: accepted (bool)
- token_slot + 1: oracle_address (address)
- token_slot + 2: oracle_slot (bytes32)
- token_slot + 3: oracle_decimals (uint8)
```

#### Oracle-Based Pricing

Each payer configures an oracle for each token they accept:

```
oracle_value = SLOAD(payer.oracle_address, payer.oracle_slot)
exchange_rate = oracle_value * 10^token_decimals / 10^oracle_decimals
token_cost = ceil(gas_cost_wei * exchange_rate / 10^18)
```

If oracle returns 0, `token_cost` is 0 (payer assumes this risk).

#### Validation

Protocol verifies permissionless payers by checking:

- Payer config is active
- Payer accepts the specified token with valid oracle config
- Payer has sufficient ETH for gas

Payers can integrate any offchain logic to manage their position—sweeping accumulated tokens to ETH via DeFi protocols periodically.

#### Rationale

Per-payer oracles rather than global oracles:

1. **Market competition**: Payers compete on pricing. Better oracles and tighter margins attract more transactions.
2. **No governance**: Avoids protocol-level debates about which oracle is canonical.
3. **Risk isolation**: A bad oracle only affects users of that payer.
4. **Flexibility**: Payers can use Chainlink, Uniswap TWAP, custom feeds, or promotional rates.
5. **Wallet-layer curation**: Discovery of good payers is handled by wallets, not protocol.

The `max_amount` field provides hard protection—transactions fail if cost exceeds the user-specified limit.

#### Oracle Updates

Oracle maintenance is external to this specification. Payers are responsible for maintaining accurate exchange rates. Common approaches:

| Oracle Type | Description |
|-------------|-------------|
| **Chainlink feeds** | Decentralized price updates via established infrastructure |
| **Keeper-updated** | Payer runs offchain updater with top-of-block updates |
| **DeFi-integrated** | Permissionless contract queries configured DEX pool for current price |

The protocol reads `oracle_slot` at validation time. Stale prices are the payer's risk—they may overpay for gas or have transactions rejected via sender's `max_amount`. A recommended pattern is a non-upgradable oracle contract with a permissionless `update(token)` method that queries configured DEX pools.

### Native Payer

The optional `NATIVE_PAYER` precompile provides chain-operated gas abstraction.

#### Behavior

- Uses the Token Payment Registry for token allowlisting and metadata
- Chain operators define pricing and supported tokens
- Can be referenced explicitly (20-byte address) or implicitly (empty `payer_auth` with `payment_token`)

#### Native DEX Integration

`NATIVE_PAYER` serves as the integration point for native DEX features. Chain operators may implement protocol-level AMM, custom pricing curves, or other mechanisms while maintaining a consistent user interface.

### Execution

#### Calldata Delivery

The `calldata` is delivered to `from` via self-call:

| Parameter | Value |
|-----------|-------|
| `to` | `from` |
| `tx.origin` | `from` |
| `msg.sender` | `from` |
| `msg.value` | 0 |
| `data` | `calldata` |

For EOAs without code, the call succeeds with no effect. For smart accounts, execution begins at the contract's entry point.

#### Validation vs Execution

This proposal constrains **validation** to enshrined key types but does not constrain **execution**. Once a transaction passes validation, the account's code can implement any logic: multisig, timelocks, spending limits, session keys, or arbitrary business rules. The `calldata` is always delivered to `from` as a self-call, ensuring wallet code controls interpretation.

#### Transaction Context

During execution, accounts can query the precompile for:

- **Payer**: `getCurrentPayer()` returns the gas payer address
- **Signer**: `getCurrentSigner()` returns `(keyIndex, keyType, publicKey)` used for authorization
- **Gas Payment**: `getGasPaymentInfo()` returns `(token, amount)` transferred for gas payment

**Optional opcodes** (`AAPAYER`, `AASIGNER`, `AAGASPAYMENT`) may be added for gas-efficient access.

### Account Initialization

New accounts can be created with pre-configured keys in a single transaction:

```
account_init_auth = rlp([
  chain_id,
  salt,
  initial_keys,       // Array of AuthKey structs
  code_hash,          // Wallet bytecode hash
  key_index,          // Index into initial_keys for signature
  signature
])
```

**Address derivation**:

```
address = keccak256(0xff || ACCOUNT_CONFIG_PRECOMPILE || salt || keccak256(abi.encode(initial_keys, code_hash)))[12:]
```

Users can receive funds at counterfactual addresses before deployment.

#### Default Account (Chain Operator Option)

For EOA accounts, chain operators may configure a **default account**—a wallet implementation automatically used for addresses without deployed code. This enables EOAs to submit AA transactions and use AA features (batching, gas sponsorship, token payments) without explicitly deploying code via EIP-7702.

**Behavior**:

- EOA submits AA transaction with valid signature
- During execution, if `from` has no code, use the configured default account bytecode
- The default account interprets `calldata` (e.g., as batched calls)
- Code injection occurs at transaction time; no permanent deployment required

**Benefits**:

- Seamless AA onboarding for existing EOAs
- Users gain smart account capabilities without understanding code delegation
- Chain can standardize on a secure, audited default implementation

**Configuration**: Chain operators specify the default account bytecode hash. This is an optional feature—chains may require explicit 7702 delegation instead.

### Validation Flow

#### Mempool Acceptance

1. Validate `sender_signature` against `from` account's keys (respecting `required_signatures` threshold)
2. Resolve payer from `payer_auth`:
   - 65 bytes: recover address via ecrecover
   - 20 bytes: use directly (permissionless payer or `NATIVE_PAYER`)
   - Empty with `payment_token`: use `NATIVE_PAYER`
   - Empty without `payment_token`: `from` pays ETH
3. Validate spending protection (optional - if implemented by chain):
   - If `requiresSponsor` is set or any native token spend limits 
4. Verify nonce, payer ETH balance, expiry
5. If `payment_token` set: verify token registration, payer acceptance, sender balance/blocklist, max_amount
6. Mempool threshold: payer's pending sponsored transaction count must be below node-configured limits (not applicable for `NATIVE_PAYER`) 

#### Block Execution

1. Token transfer (if applicable)
2. ETH gas deduction from payer
3. Process authorization_list (EIP-7702)
4. Account initialization (if applicable)
5. Deliver calldata to `from` via self-call

### RPC Extensions

**`eth_getTransactionCount`**: Extended with optional `nonceKey` parameter (uint192) to query 2D nonce channels.

**`eth_getTransactionReceipt`**: Should include `payer` field.

## Rationale

### Why a Precompile?

The Account Configuration Precompile serves two roles:

1. **Protocol-level validation**: The chain reads precompile storage directly to validate AA transaction signatures—no EVM execution required during validation. The protocol can keep these storage slots warm for efficient access. 
2. **Onchain interface**: Smart contracts call the precompile during execution to:
   - Modify keys (`addKey()`, `removeKey()`)
   - Query transaction context (`getCurrentSigner()`, `getCurrentPayer()`)
   - Validate signatures for 4337 compatibility (`validateSignature()`)

Having the precompile accessible onchain means that accounts can build any additional recovery logic into their code.

### Smart Wallet Migration Path

Existing ERC-4337 smart accounts migrate to native AA without redeployment:

1. **Register keys**: Call `addKey()` on the precompile to add existing signing keys (K1, R1, WebAuthn, etc.) to auth config
2. **Upgrade wallet logic**: Update contract to use precompile as source of truth:
   - Call `getKey()` / `validateSignature()` for signature verification
   - Call `getCurrentSigner()` during execution to identify which key authorized the transaction
3. **Backwards compatible**: Wallet can still accept ERC-4337 UserOps via EntryPoint alongside native AA transactions

**Key principle**: Wallet contracts should avoid duplicating key storage. The precompile is ideally the single source of truth for authentication (for these key types). Wallets implement authorization logic (spending limits, timelocks, multisig) in their execution code using `getCurrentSigner()` context. Wallets are free to add any additional recovery mechanisms or other logic into their code.


## Backwards Compatibility

No breaking changes. Existing EOAs and smart contracts function unchanged. Adoption is opt-in:

- EOAs continue sending standard transactions
- ERC-4337 infrastructure continues operating
- Accounts gain AA capabilities by configuring keys or using the new transaction type, note that code needs to be deployed to do anything useful as calldata is sent to the address and must be interpreted. Chains can opt in for default accounts to not require deploment via 7702 for EOA keys. 

## Reference Implementation

### IAccountConfig

```solidity
interface IAccountConfig {
    struct AuthKey {
        uint8 keyType;
        bytes publicKey;
    }
    
    event KeyAdded(address indexed account, uint8 keyIndex, uint8 keyType, bytes publicKey);
    event KeyRemoved(address indexed account, uint8 keyIndex);
    event RequiredSignaturesUpdated(address indexed account, uint8 requiredSignatures);
    event PolicyUpdated(address indexed account, uint8 version, uint256 flags); // flags such as requiresSponsor 
    
    // Key management
    function addKey(uint8 keyType, bytes calldata publicKey) external returns (uint8 keyIndex);
    function removeKey(uint8 keyIndex) external;
    function getKeyCount(address account) external view returns (uint8);
    function getKey(address account, uint8 keyIndex) external view returns (uint8 keyType, bytes memory publicKey);
    function validateSignature(address account, uint8 keyIndex, bytes32 messageHash, bytes calldata signature) external view returns (bool);
    
    // Multisig configuration
    function setRequiredSignatures(uint8 threshold) external;
    function getRequiredSignatures(address account) external view returns (uint8);
    
    
    // Nonce management
    function getNonce(address account, uint192 nonceKey) external view returns (uint64);
    
    // Transaction context (only valid during AA transaction execution)
    function getCurrentPayer() external view returns (address);
    function getCurrentSigner() external view returns (uint8 keyIndex, uint8 keyType, bytes memory publicKey);
    function getGasPaymentInfo() external view returns (address token, uint256 amount);
}
```

### ITokenPaymentRegistry

```solidity
interface ITokenPaymentRegistry {
    event TokenRegistered(address indexed token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist);
    event TokenStatusUpdated(address indexed token, bool active);
    event BlocklistUpdated(address indexed token, address indexed account, bool blocked);
    event BlocklistManagerUpdated(address indexed token, address indexed manager, bool authorized);
    
    function registerToken(address token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist) external;
    function setTokenActive(address token, bool active) external;
    function setBlocklistManager(address manager, bool authorized) external;
    function setBlocked(address token, address account, bool blocked) external;
    function isTokenActive(address token) external view returns (bool);
    function isBlocked(address token, address account) external view returns (bool);
    function isBlocklistManager(address token, address manager) external view returns (bool);
    function getTokenDecimals(address token) external view returns (uint8);
    function hasHighBitBlocklist(address token) external view returns (bool);
}
```

### IPayerConfig

```solidity
interface IPayerConfig {
    struct TokenConfig {
        bool accepted;
        address oracleAddress;
        bytes32 oracleSlot;
        uint8 oracleDecimals;
    }
    
    event PayerUpdated(address indexed payer, bool active);
    event PayerTokenConfigured(address indexed payer, address indexed token, address oracle, bytes32 oracleSlot, uint8 oracleDecimals);
    event PayerTokenRemoved(address indexed payer, address indexed token);
    
    function setPayerActive(bool active) external;
    function configureToken(address token, address oracleAddress, bytes32 oracleSlot, uint8 oracleDecimals) external;
    function removeToken(address token) external;
    function isPayerActive(address payer) external view returns (bool);
    function getTokenConfig(address payer, address token) external view returns (TokenConfig memory);
    function getExchangeRate(address payer, address token) external view returns (uint256);
}
```

## Security Considerations

**Enshrined Validation**: Signature verification uses well-established algorithms before any EVM execution. Failed validation rejects transactions before mempool entry.

**Replay Protection**: Transactions include `chain_id`, 2D nonce, and `expiry`.

**Key Management**: Only `msg.sender` can modify account configuration. EOA key always retains authorization for recovery (if created with an EOA via 7702).

**Delegation**: `DELEGATE` key type limited to 1 hop to prevent loops.

**Multisig**: Native multisig requires `required_signatures` valid signatures from distinct keys. EOA signature counts toward threshold if account has EOA origin (created via 7702). Pure multisig (no EOA) is supported for smart accounts initialized without an EOA key.

**Token Spend Protection**: Token gas payments occur before wallet code executes, bypassing wallet-level spend limits. Protocol-level mitigations:

- **Require sponsor** (`requiresSponsor`): When enabled, account requires full ETH sponsorship—`payer_auth` must specify a sponsor AND `payment_token` must be empty. No tokens or ETH can be spent by the account for gas, completely eliminating the token spend attack vector.
- **Future spend limits**: In the future we can consider adding per asset spend limits natively managed.

**Payer Security**: Permissioned payers sign each transaction. Permissionless payers explicitly configure accepted tokens; protocol validates sender balance/blocklist before transfer.

**Oracle Risks**: Per-payer oracles mean manipulation affects only that payer's users. Mitigations: trusted payer lists, `max_amount` field, TWAP oracles.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
