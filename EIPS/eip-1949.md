---
eip: 1949
title: Delayed Distributed Minting
author: Johann Barbie <@johannbarbie>, Pinkiebell <@pinkiebell>
discussions-to: https://ethresear.ch/t/a-distributed-breeding-function/5264
status: Draft
type: Standards Track
category: ERC
created: 2019-04-18
requires: ERC721
requires: ERC1948
---

## Simple Summary

```
Two CryptoKitties take a honeymoon on a side-chain ðŸˆðŸˆðŸ–. The blazing fast transactions heat their blood ðŸ”¥, one thing leads to another â¤ and a rare baby-kitten is born ðŸ’¥ðŸ¯. On the way home to mainnet the family gets stopped at the bridge contract, â€œðŸ‘®â€â™‚ï¸ tokenIDs please!â€. Oh shoot, the baby-kitten doesnâ€™t have one on the root chain ðŸ¤·â€â™€ï¸.
```

The minting function of NFT contracts is centralized to a single chain. This proposal allows to mint tokens across multiple chains.

## Abstract

This ERC introduced a design for NFT tokens to be mintable across multiple chains. A minimal requirement for distributed minting are collision-free token Ids. The Collision-freeness is achieved by introducing to types of tokens, queens and workers. The Ids of the queens are generated by hashing the token contract address with an increasing `queenCounter` in the contract. The Ids of the workers are generated by hashing the queenIds with an increasing counter that the queen tokens carry in themselves using the [data token specification](https://github.com/ethereum/EIPs/pull/1948).

## Motivation

While fungible tokes have a natural performance gain when using side-chains, NFTs need to be minted on the main-net and deposited one by one. With the distributed breeding function described here, NFTs can be minted on side-chains and only cause root chain costs on exit.

## Specification

An extension of ERC721 interface with the following function is suggested:

```
pragma solidity 0.5.2;

/**
 * @title IDelayedBreeder
 * @dev Interface for delayed breeding
 */
contract IDelayedBreeder {

  function breed(uint256 _queenId, uint256 _workerId, address _to) public;
}
```

## Rationale

Sidechain allow for easy user onboarding through fast block times and low transaction fees. Fungible tokes have a natural performance gain when using side-chains, as there can be one big deposit from the main-net followed by many small transfers. NFTs are equally important for user onboarding, but lack the performance advantages through side-chains, as most cost occur on minting. Only some tokens gain value through the lifetime of a dApp, if they can be sold on decentralized markets on the main-net their value can be realized.

The proposal for this ERC stems from the [distributed breeding proposal](https://ethresear.ch/t/a-distributed-breeding-function/5264) to allow better integration of NFTs accross sidechains. [ost.com](https://ost.com/), [Skale](https://skalelabs.com/), [POA](https://poa.network/), and [LeapDAO](https://leapdao.org/) have been part of the discussion.

## Backwards Compatibility

ðŸ¤·â€â™‚ï¸ No related proposals are known to the author, hence no backwards compatibility to consider.

## Test Cases

Simple happy test:

```
const DataToken = artifacts.require('./DataToken.sol');

contract('DataToken', (accounts) => {
  const firstTokenId = 100;
  const empty = '0x0000000000000000000000000000000000000000000000000000000000000000';
  const data = '0x0101010101010101010101010101010101010101010101010101010101010101';
  let dataToken;

  beforeEach(async () => {
    dataToken = await DataToken.new();
    await dataToken.mint(accounts[0], firstTokenId);
  });

  it('should allow to write and read', async () => {
    let rsp = await dataToken.readData(firstTokenId);
    assert.equal(rsp, empty);
    await dataToken.writeData(firstTokenId, data);
    rsp = await dataToken.readData(firstTokenId);
    assert.equal(rsp, data);
  });

});
```


## Implementation

An example implementation of the interface in solidity would look as below. The data token is taken from [this ERC](https://github.com/ethereum/EIPs/pull/1948).

```
pragma solidity 0.5.2;

import "../DataToken.sol";
import "openzeppelin-solidity/contracts/access/roles/MinterRole.sol";
import "./IDelayedBreeder.sol";

/**
 * @title DelayedBreeder
 * @dev A ERC721 token that allows to mint tokens accross multiple chains.
 * The contract contains two classe of tokens, queens and workers.
 */
contract DelayedBreeder is DataToken, MinterRole, IDelayedBreeder {
  uint96 public queenCounter = 0;

  /**
   * @dev Function to mint queen tokens.
   * A queenId is generated by hashing the token address with
   * the contracts queenCounter. Queen counter is increased at each mint.
   */
  function mintQueen() public onlyMinter {
    queenCounter += 1;
    uint256 queenId = uint256(keccak256(abi.encodePacked(address(this), queenCounter)));
    super._mint(msg.sender, queenId);
    data[queenId] = bytes32(uint256(1));
  }

  /**
   * @dev Function to mint worker tokens. This function is used to register
   * worker tokens that have been minted on sidechains in a delayed fashion.
   * @param _queenId The queen token that has produced this worker
   * @param _workerId The token id to mint.
   * @param _to The address that will receive the minted tokens.
   * @return A boolean that indicates if the operation was successful.
   */
  function breed(uint256 _queenId, uint256 _workerId, address _to) public returns (bool) {
    require(ownerOf(_queenId) == msg.sender, "breed called by non-owner");
    uint256 breedCounter = uint256(readData(_queenId));
    require(breedCounter > 0 && breedCounter < 2 ** 32, "queenId not queen");
    require(_to != address(0), "owner should not be null");
    super._mint(_to, _workerId);
    return true;
  }

}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).