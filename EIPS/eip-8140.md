---
eip: 8140
title: Token Gas Payments for EIP-8130
description: Enable gas payments using fungible tokens for EIP-8130 AA transactions via the fee_token field
author: Chris Hunter (@chunter-cb) <chris.hunter@coinbase.com>
discussions-to: https://ethereum-magicians.org/t/eip-8130-account-abstraction-by-account-configurations/25952
status: Draft
type: Standards Track
category: Core
created: 2025-10-14
requires: 8140
---

## Abstract

This proposal extends [EIP-8130](./eip-8130.md) to enable gas payments using ERC-20 tokens. It defines the token payment format for EIP-8130's `fee_token` field, a Token Payment Registry for allowlisting tokens, permissionless payer configurations with oracle-based pricing, and an optional native payer system contract for chain-operated gas abstraction.

## Motivation

EIP-8130 provides account abstraction with ETH-based gas sponsorship. However, many users hold tokens (USDC, USDT, etc.) but no ETH, creating friction for onboarding and transaction submission. Token gas payments enable:

- **Gasless UX**: Users transact with tokens they already hold
- **Stablecoin payments**: Predictable transaction costs in USD-denominated tokens
- **Competitive market**: Permissionless payers compete on exchange rates
- **Chain flexibility**: Native payer option for chain-operated gas abstraction (ie. Native AMM)
- **Zero token changes**: Works with existing ERC-20 tokens using standard transfer logic—no upgrades or storage migrations required

This proposal uses EIP-8130's `fee_token` field to add token payment capability without modifying the base transaction type.

## Specification

### Constants

| Name | Value | Comment |
|------|-------|---------|
| `TOKEN_PAYMENT_REGISTRY` | TBD | Token Payment Registry system contract address |
| `TOKEN_TRANSFER_COST` | 500 (warm) / 5000 (cold) | Per SSTORE costs for balance slot writes |
| `NATIVE_PAYER` | TBD | (Optional) Native gas AMM payer system contract address |

### Fee Token Format

Token payments use the EIP-8130 `fee_token` field with packed byte encoding. The format length determines payer consent:

| Length | Format | Payer Consent |
|--------|--------|---------------|
| 0 bytes | `0x` (empty) | ETH payment only |
| 52 bytes | `token (20) \|\| max_amount (32)` | Native payer or any permissioned payer |
| 72 bytes | `token (20) \|\| max_amount (32) \|\| payer (20)` | Specific payer only |

#### 52-byte Format (Flexible Payer)

```
fee_token = token_address || max_amount
          = address (20 bytes) || uint256 (32 bytes)
          = 52 bytes total
```

The sender signs over `token || max_amount` but does NOT commit to a specific payer. This allows:
- **Native payer**: Empty `payer_auth` resolves to `NATIVE_PAYER`
- **Any permissioned payer**: 65-byte `payer_auth` signature, payer recovered via ecrecover

Permissionless payers (20-byte address in `payer_auth`) are **rejected** with this format because the sender did not consent to a specific payer.

#### 72-byte Format (Specific Payer)

```
fee_token = token_address || max_amount || payer_address
          = address (20 bytes) || uint256 (32 bytes) || address (20 bytes)
          = 72 bytes total
```

The sender signs over `token || max_amount || payer`, explicitly committing to that payer. This allows:
- **Specific permissioned payer**: 65-byte signature must recover to the committed payer
- **Specific permissionless payer**: 20-byte address must match the committed payer
- **Native payer**: Empty `payer_auth` if committed payer equals `NATIVE_PAYER`

| Field | Type | Size | Description |
|-------|------|------|-------------|
| `token_address` | address | 20 bytes | ERC-20 token contract address |
| `max_amount` | uint256 | 32 bytes | Maximum token amount sender will pay |
| `payer_address` | address | 20 bytes | (Optional) Specific payer the sender consents to |

When `fee_token` is non-empty, the transaction uses token-based gas payment instead of ETH.

### Token Payment Registry

Tokens must be registered in the Token Payment Registry system contract at `TOKEN_PAYMENT_REGISTRY` before use for gas payment. Similar to EIP-8130's account configuration precompile, this is a protocol-level system contract with persistent storage. The registry stores token metadata required for protocol-level balance reads and transfers.

#### Token Configuration Storage

All storage keys use byte concatenation (`||` denotes concatenation of raw bytes, addresses as 20 bytes, strings as UTF-8):

```
Base slot: keccak256(token_address || TOKEN_PAYMENT_REGISTRY || "config")

- base_slot + 0: balance_slot_index (uint256)
- base_slot + 1: packed config (uint256)
    - byte 0: token_decimals (uint8)
    - byte 1: active (bool)
    - byte 2: highBitBlocklist (bool)
    - bytes 3-31: reserved
```

| Field | Description |
|-------|-------------|
| `balance_slot_index` | Storage slot index for token's `balanceOf` mapping. User balance at: `keccak256(user_address || balance_slot_index)` |
| `token_decimals` | Token decimal places (e.g., 6 for USDC, 18 for most tokens) |
| `active` | Whether token is currently accepted for gas payments |
| `highBitBlocklist` | If true, bit 255 of balance = 1 indicates account is blocklisted |

#### Blocklist Storage

When `highBitBlocklist` is false, blocklist status is stored separately:

```
Blocklist slot: keccak256(token_address || account_address || TOKEN_PAYMENT_REGISTRY || "blocklist")
Value: bool
```

When `highBitBlocklist` is true, bit 255 of the token's balance slot indicates blocklist status—no separate storage read required. This optimization supports tokens like USDC that encode blocklist status in the balance.

### Payer Modes with Token Payments

This extension adds token payment capability to EIP-8130's payer modes. The `fee_token` length determines which payer modes are permitted:

#### With 52-byte `fee_token` (Native or Permissioned)

| Mode | `payer_auth` | `fee_token` | Gas Payer | Token Recipient |
|------|--------------|-------------|-----------|-----------------|
| Native payer | Empty | `token \|\| max` | `NATIVE_PAYER` | `NATIVE_PAYER` |
| Any permissioned | 65-byte signature | `token \|\| max` | ecrecover(sig) | Payer |
| Permissionless | 20-byte address | `token \|\| max` | **REJECTED** | — |

**Rationale**: Permissioned payers sign the transaction, demonstrating consent. Permissionless payers don't sign, so the sender must explicitly consent by using the 72-byte format.

#### With 72-byte `fee_token` (Specific Payer)

| Mode | `payer_auth` | `fee_token` | Gas Payer | Token Recipient |
|------|--------------|-------------|-----------|-----------------|
| Specific native | Empty | `token \|\| max \|\| NATIVE_PAYER` | `NATIVE_PAYER` | `NATIVE_PAYER` |
| Specific permissioned | 65-byte signature | `token \|\| max \|\| payer` | Must match payer | Payer |
| Specific permissionless | 20-byte address | `token \|\| max \|\| payer` | Must match payer | Payer |

**Rationale**: Sender committed to a specific payer in `fee_token`, enabling permissionless mode safely.

### Permissionless Payer Configuration

Permissionless payers register onchain to accept token payments without signing each transaction. Each payer specifies their own oracle per token, enabling a competitive gas market.

#### Storage

```
Base slot: keccak256(payer_address || TOKEN_PAYMENT_REGISTRY || "payer")

- base_slot + 0: active (bool)

Per-token config:
Token slot: keccak256(token_address || payer_address || TOKEN_PAYMENT_REGISTRY || "payer_token")

- token_slot + 0: accepted (bool)
- token_slot + 1: oracle_address (address)
- token_slot + 2: oracle_slot (bytes32)
- token_slot + 3: oracle_decimals (uint8)
```

#### Oracle-Based Pricing

Each payer configures an oracle for each token they accept. The oracle value represents **tokens per ETH**, scaled by `10^oracle_decimals`:

```
oracle_value = SLOAD(payer.oracle_address, payer.oracle_slot)
exchange_rate = oracle_value * 10^token_decimals / 10^oracle_decimals
token_cost = ceil(gas_cost_wei * exchange_rate / 10^18)
```

**Example**: USDC payment for 0.001 ETH gas cost (1e15 wei), ETH at $2000:
- `oracle_value` = 2000 × 10^8 (2000 USDC/ETH with 8 decimals, Chainlink standard)
- `exchange_rate` = 2000e8 × 10^6 / 10^8 = 2000e6
- `token_cost` = 1e15 × 2000e6 / 1e18 = 2e6 = 2 USDC 

If oracle returns 0, `token_cost` is 0 (payer assumes this risk).

#### Validation

Protocol verifies permissionless payers by checking:

- Payer config is active
- Payer accepts the specified token with valid oracle config
- Payer has sufficient ETH for gas

Payers can integrate any offchain logic to manage their position—sweeping accumulated tokens to ETH via DeFi protocols periodically.

### Oracle Maintenance

Oracle maintenance is external to this specification. Payers are responsible for maintaining accurate exchange rates. Common approaches:

| Oracle Type | Description |
|-------------|-------------|
| **Chainlink feeds** | Decentralized price updates via established infrastructure |
| **Keeper-updated** | Payer runs offchain updater with top-of-block updates |
| **DeFi-integrated** | Permissionless contract queries configured DEX pool for current price |

The protocol reads `oracle_slot` at validation time. Stale prices are the payer's risk—they may overpay for gas or have transactions rejected via sender's `max_amount`. A recommended pattern is a non-upgradable oracle contract with a permissionless `update(token)` method that queries configured DEX pools.

### Native Payer

The optional `NATIVE_PAYER` system contract provides chain-operated gas abstraction.

#### Behavior

- Uses the Token Payment Registry for token allowlisting and metadata
- Chain operators define pricing mechanism and supported tokens (intentionally unspecified—enables AMMs, fixed rates, or custom curves)
- Can be referenced explicitly (20-byte address in `payer_auth`) or implicitly (empty `payer_auth` with non-empty `fee_token`)

### Token Transfer Flow

When `fee_token` is non-empty:

1. Parse `fee_token` to extract `token_address`, `max_amount`, and optionally `payer_address`
2. Resolve payer from `payer_auth` (see [Validation Flow Updates](#validation-flow-updates))
3. Read raw balance from token's `balance_slot_index` for sender
4. Verify sender is not blocklisted (via high bit or blocklist storage)
5. Determine `token_cost`:
   - **Permissioned payer** (65-byte signature): `token_cost = max_amount × (gas_used / gas_limit)` — payer signed agreeing to max price, actual cost scales with gas used
   - **Permissionless payer** (20-byte address, requires 72-byte `fee_token`): read exchange rate from payer's oracle config, compute `token_cost` based on actual `gas_used`, validate `token_cost <= max_amount`
   - **Native payer**: compute from `NATIVE_PAYER` pricing based on actual `gas_used`, validate `token_cost <= max_amount`
6. Validate `balance >= token_cost`
7. Update balances: sender decreases, payer increases
8. Emit `Transfer(from, payer, token_cost)` (implementation-defined)

Token transfers occur outside EVM execution. For permissioned payers, the initial transfer uses `max_amount` at transaction start; any refund based on actual gas usage occurs post-execution.

### Intrinsic Gas

When `fee_token` is non-empty, add to EIP-8130 intrinsic gas:

```
intrinsic_gas = EIP8130_intrinsic_gas + TOKEN_TRANSFER_COST
```

### Validation Flow Updates

Extend EIP-8130 mempool acceptance:

1. (EIP-8130 steps 1-3)
2. If `fee_token` is non-empty (52 or 72 bytes):
   - Parse `fee_token`: extract `token_address`, `max_amount`, and optionally `payer_address`
   - Verify token is registered and active in Token Payment Registry
   - Verify sender is not blocklisted for this token
   - Verify sender has sufficient token balance
   - Resolve payer based on `fee_token` length:
   
   **52-byte format** (native or permissioned):
   - Empty `payer_auth`: use `NATIVE_PAYER`
   - 65-byte `payer_auth`: recover payer via ecrecover (any permissioned payer)
   - 20-byte `payer_auth`: **REJECT** (sender did not consent to permissionless)
   
   **72-byte format** (specific payer):
   - Extract `expected_payer` from `fee_token`
   - Empty `payer_auth`: verify `expected_payer == NATIVE_PAYER`, use `NATIVE_PAYER`
   - 65-byte `payer_auth`: recover payer via ecrecover, verify matches `expected_payer`
   - 20-byte `payer_auth`: verify matches `expected_payer`, use as permissionless payer
   
   - For permissionless payers: verify payer accepts token, has valid oracle, sufficient ETH
   - Verify `token_cost <= max_amount`
3. (EIP-8130 steps 4-6)

### Block Execution Updates

Extend EIP-8130 block execution:

1. **Token transfer** (if `fee_token` is non-empty)
2. ETH gas deduction from payer
3. Process authorization_list (EIP-7702)
4. Account initialization (if applicable)
5. Deliver calldata to sender via self-call

### Transaction Context Extension

Extend EIP-8130's `IAccountConfig` with:

```solidity
// Transaction context (only valid during AA transaction execution)
function getGasPaymentInfo() external view returns (address token, uint256 amount);
```

Returns the token address and amount transferred for gas payment. Returns `(address(0), 0)` for ETH-only payments.

## Rationale

### Why Length-Based Payer Consent?

The `fee_token` field uses length to determine payer consent:

1. **52 bytes = flexible**: Sender allows native or any permissioned payer. Permissioned payers sign the transaction, demonstrating their consent. The sender trusts "anyone willing to sign."

2. **72 bytes = specific**: Sender commits to a specific payer address. This enables permissionless payers safely because the sender explicitly chose that payer.

This design prevents **payer attachment attacks** where an attacker could replace the intended payer with one offering worse rates. Without sender consent:
- Attacker intercepts transaction with 52-byte `fee_token`
- Attacker attaches a permissionless payer with unfavorable oracle rates
- Sender pays more tokens than intended (up to `max_amount`)

By requiring 72-byte format for permissionless payers, the sender's signature binds to the specific payer they trust.

### Why Permissionless Payers?

Permissionless payers create a competitive market for gas payment services:

1. **No gatekeeping**: Anyone can become a payer by registering
2. **Price competition**: Payers compete on exchange rates
3. **Decentralization**: No single entity controls gas payment pricing
4. **Innovation**: Payers can experiment with pricing strategies

### Why Per-Payer Oracles?

Per-payer oracles rather than a global protocol oracle:

1. **Market competition**: Payers compete on pricing—better oracles and tighter margins attract more transactions
2. **No governance**: Avoids protocol-level debates about which oracle is canonical
3. **Risk isolation**: A bad oracle only affects users of that payer
4. **Flexibility**: Payers can use Chainlink, custom feeds, or promotional rates
5. **Wallet-layer curation**: Discovery of reputable payers is handled by wallets, not protocol

The `max_amount` field provides hard user protection—transactions fail if computed cost exceeds the user-specified limit.

### Why Direct Storage Reads?

Reading token balances directly from storage slots rather than calling ERC-20 methods:

1. **No token upgrades**: Existing tokens with standard `mapping(address => uint256)` balance storage work without modification—just register the balance slot index
2. **No storage migrations**: Tokens don't need to move data or conform to new interfaces
3. **Atomic execution**: Balance reads and transfers happen at protocol level, before EVM execution begins
4. **Extensible**: The same approach can support other asset types that use balance-based storage patterns

## Backwards Compatibility

This proposal extends EIP-8130. Nodes not supporting this EIP will reject transactions with non-empty `fee_token` as specified in EIP-8130.

## Reference Implementation

### ITokenPaymentRegistry

```solidity
interface ITokenPaymentRegistry {
    event TokenRegistered(address indexed token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist);
    event TokenStatusUpdated(address indexed token, bool active);
    event BlocklistUpdated(address indexed token, address indexed account, bool blocked);
    event BlocklistManagerUpdated(address indexed token, address indexed manager, bool authorized);
    
    // Token registration (token address or configured admin only)
    function registerToken(address token, uint256 balanceSlotIndex, uint8 tokenDecimals, bool highBitBlocklist) external;
    function setTokenActive(address token, bool active) external;
    
    // Blocklist management
    function setBlocklistManager(address manager, bool authorized) external;
    function setBlocked(address token, address account, bool blocked) external;
    
    // View functions
    function isTokenActive(address token) external view returns (bool);
    function isBlocked(address token, address account) external view returns (bool);
    function isBlocklistManager(address token, address manager) external view returns (bool);
    function getTokenDecimals(address token) external view returns (uint8);
    function getBalanceSlotIndex(address token) external view returns (uint256);
    function hasHighBitBlocklist(address token) external view returns (bool);
}
```

### IPayerConfig

```solidity
interface IPayerConfig {
    struct TokenConfig {
        bool accepted;
        address oracleAddress;
        bytes32 oracleSlot;
        uint8 oracleDecimals;
    }
    
    event PayerUpdated(address indexed payer, bool active);
    event PayerTokenConfigured(address indexed payer, address indexed token, address oracle, bytes32 oracleSlot, uint8 oracleDecimals);
    event PayerTokenRemoved(address indexed payer, address indexed token);
    
    // Payer registration
    function setPayerActive(bool active) external;
    
    // Token configuration
    function configureToken(address token, address oracleAddress, bytes32 oracleSlot, uint8 oracleDecimals) external;
    function removeToken(address token) external;
    
    // View functions
    function isPayerActive(address payer) external view returns (bool);
    function getTokenConfig(address payer, address token) external view returns (TokenConfig memory);
    function getExchangeRate(address payer, address token) external view returns (uint256);
}
```

## Security Considerations

**Token Spend Protection**: Token gas payments occur before wallet code executes, bypassing wallet-level spend limits. Mitigations:

- **`max_amount` cap**: Hard limit on token spend per transaction
- **`requiresSponsor` policy** (EIP-8130): Accounts can enable the `requiresSponsor` flag in their gas payment policy, which disables ALL self-paid gas (ETH and tokens). When enabled, transactions must have a sponsor signature in `payer_auth`. This completely eliminates the gas spend attack vector and is strongly recommended for accounts using EVM-layer multisig.
- **Blocklist checks**: Protocol validates sender is not blocklisted before transfer

**Oracle Risks**: Per-payer oracles mean manipulation affects only that payer's users. Mitigations:

- **Trusted payer lists**: Wallets curate lists of reputable payers
- **`max_amount` field**: User-specified cap protects against price spikes

**Payer Security**: 

- **Permissioned**: Payer signs each transaction, explicitly agreeing to the token amount. Can be used with 52-byte or 72-byte `fee_token`.
- **Permissionless**: Requires 72-byte `fee_token` format where sender commits to the specific payer address. This prevents payer attachment attacks where an attacker substitutes a payer with worse rates. Payers explicitly configure accepted tokens and oracles; protocol validates sender balance/blocklist before transfer.

**Payer Attachment Attack Prevention**: The 52-byte format rejects permissionless payers because the sender didn't sign over a specific payer. An attacker cannot attach an arbitrary permissionless payer to steal value through unfavorable exchange rates. The `max_amount` field provides a hard cap, but the length-based consent model provides the primary protection.

**Balance Manipulation**: Protocol reads token balances directly from storage slots. Tokens with non-standard balance storage (rebasing, fee-on-transfer) may behave unexpectedly. Only register well-understood tokens.

**Token Slot Changes**: If a registered token upgrades and changes its balance storage slot, the registry configuration becomes invalid. The token must be deactivated; there is no migration path currently. This is intentional—tokens used for gas payment should have immutable storage layouts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
