---
eip: 8037
title: State Creation Gas Cost Increase
description: Harmonization and increase of state creation gas costs to mitigate state growth and unblock scaling
author: Maria Silva (@misilva73), Carlos Perez (@CPerezz), Jochem Brouwer (@jochem-brouwer), Ansgar Dietrichs (@adietrichs)
discussions-to: https://ethereum-magicians.org/t/eip-8037-state-creation-gas-cost-increase/25694
status: Draft
type: Standards Track
category: Core
created: 2025-10-01
requires: 2780, 2930
---

## Abstract

This proposal increases the cost of state creation operations, thus avoiding excessive state growth under increased block gas limits. It sets a unit cost per new state byte that targets an average state growth of 60 GiB per year at a block gas limit of 300M gas units and an average gas utilization for state growth of 30%. Contract deployments get a 10x cost increase while new accounts get a 8.5x increase. Deployments of duplicated bytecode do not pay deposit costs when the duplicate is identified through an access-list based mechanism. To avoid limiting the maximum contract size that can be deployed, it also introduces an independent metering for code deposit costs.

## Motivation

State creation does not have a harmonized cost, with different methods incurring varied costs for creating the same size of new state. For instance, while contract deployment only costs 202 gas units per new byte created, new storage slots cost 625 gas units per new byte created. Also, deploying duplicated bytecode costs the same as deploying new bytecode, even though clients don't store duplicated code in the database. This proposal establishes a standard to harmonize all state creation operations.

Additionally, state growth will become a bottleneck for scaling under higher block limits. As of May 2025, the current database size in a Geth node dedicated to state is ~340 GiB. After the increase in gas limit from 30M to 36M gas units, the median size of new state created each day doubled, from ~102 MiB to ~205 MiB.

![new_state_added](../assets/eip-8037/new_state_added.png)

The relationship we are seeing in this example is not linear as expected. This is likely due to other factors impacting user behavior. However, all else being equal, we expect a proportional increase in the number of new states created as gas limits increase. At a 60M gas limit (and a proportional increase in new state per day of 1.7x), we would see a daily state growth of ~349 MiB and a yearly state growth of ~124 GiB. Similarly, at a 100M gas limit, the state would grow at a rate of ~553 MiB per day and 197 GiB per year. This level of state growth would give us less than 2.5 years until the size of the state database exceeds the threshold of 650 GiB, at which point nodes will begin experiencing a degradation in performance.

## Specification

### Parameter changes

Upon activation of this EIP, the following parameters of the gas model are updated:

| **Parameter** | **Current value** | **New value** | **Increase** | **Operations affected** |
|:---:|:---:|:---:|:---:|:---:|
| `GAS_CREATE` | 32,000 | 212,800 | 6.7x | `CREATE`, `CREATE2`, contract creation txs |
| `GAS_CODE_DEPOSIT` | 200 | 1,900 | 9.5x | `CREATE`, `CREATE2`, contract creation txs |
| `GAS_NEW_ACCOUNT` | 25,000 | 212,800 | 8.5x | New EOA funding |
| `GAS_SELF_DESTRUCT_NEW_ACCOUNT` | 25,000 | 212,800 | 8.5x | `SELF_DESTRUCT` |
| `GAS_STORAGE_SET` | 20,000 | 60,800 | 3x | `SSTORE` |
| `PER_EMPTY_ACCOUNT_COST` | 25,000 | 212,800 | 8.5x | EOA delegation |
| `PER_AUTH_BASE_COST` | 12,500 | 43,700 | 3.5x | EOA delegation |

### Multidimensional metering for code deposit gas

Besides the parameter changes, this proposal introduces an independent metering for the code deposit costs. The specification is derived from [EIP-8011](./eip-8011.md). However, it only requires two dimensions, namely, `gas` and `code_deposit_gas`.

### Contract deployment cost calculation

This proposal introduces a discount for contract deployment of duplicated bytecode. To account for the added work of checking bytecode duplication, it additionally charges a storage access cost and a hashing cost, while properly accounting for success and failure paths and ensuring that post-execution costs are only charged when deployment succeeds.

#### Success vs Failure Gas Accounting

When a contract creation transaction or opcode (`CREATE`/`CREATE2`) is executed, gas is charged differently based on whether the deployment succeeds or fails. Given runtime bytecode `R` (length `L`) returned by initcode and `H = keccak256(R)`:

1. **On opcode entry:** Always charge `GAS_CREATE` (212,800 gas)
2. **During initcode execution:** Charge `EXECUTION_GAS` equal to gas consumed by the initcode
3. **Success path** (no error, not reverted, and `L ≤ MAX_CODE_SIZE`):
   - If the target account is new, charge `GAS_NEW_ACCOUNT` (212,800 gas)
   - Charge `HASH_COST(L)` where `HASH_COST(L) = 6 × ceil(L / 32)` to compute `H`
   - Perform deduplication check (see Access-List CodeHash section below):
     - If duplicate: do NOT charge `GAS_CODE_DEPOSIT * L`; link `codeHash` to `H`
     - If not duplicate: charge `GAS_CODE_DEPOSIT * L` (1,900 × L) and persist `R` under `H`, then link
4. **Failure paths** (REVERT, OOG/invalid during initcode, OOG during code deposit, or `L > MAX_CODE_SIZE`):
   - Do NOT charge `GAS_NEW_ACCOUNT`, `HASH_COST(L)`, or `GAS_CODE_DEPOSIT * L`
   - No code is stored; no `codeHash` is linked to the account
   - The account remains unchanged or non-existent

**Total gas formulas:**

```
SUCCESS_PATH_TOTAL_GAS =
    GAS_CREATE
  + EXECUTION_GAS
  + (GAS_NEW_ACCOUNT if account is new else 0)
  + HASH_COST(L)
  + (GAS_CODE_DEPOSIT * L if not deduped else 0)

FAILURE_PATH_TOTAL_GAS =
    GAS_CREATE
  + EXECUTION_GAS
```

#### Access-List CodeHash Deduplication

To determine whether bytecode is duplicated, this EIP introduces an access-list based mechanism that avoids consensus-breaking database lookups. The approach extends EIP-2930 access lists with an optional `checkCodeHash` flag:

```json
{
  "address": "0x...",
  "storageKeys": ["0x..."],
  "checkCodeHash": true
}
```

**Consensus semantics:**

- Before transaction execution, build a set `W` containing the `codeHash` of every **existing** access-listed address where `checkCodeHash == true`. **Important:** `W` is built from state at the start of transaction execution. Only addresses that already exist with deployed code contribute to `W`.
- On successful contract creation, if `H = keccak256(R)` is in `W`, the bytecode is considered a duplicate
- Duplicate bytecode does not incur `GAS_CODE_DEPOSIT * L` charges
- The cost of reading `codeHash` for access-listed addresses is already covered by EIP-2929/2930 access costs

**How deduplication works:**

1. **Transaction T_A** deploys a contract at address `X` with bytecode `B`. This pays full `GAS_CODE_DEPOSIT * L` cost (no prior contract has this bytecode).
2. **Later transaction T_B** (in a later block or later in the same block) wants to deploy the same bytecode `B`:
   - T_B must include address `X` in its access list with `checkCodeHash: true`
   - When T_B starts execution, it builds `W` from current state. Since `X` now exists from T_A's deployment, `W` contains `codeHash(B)`
   - T_B's deployment gets the discount and skips `GAS_CODE_DEPOSIT * L`

**Important edge case:** If two transactions in the same block both deploy identical new bytecode and neither references an existing contract with that bytecode in their access lists, both will pay full `GAS_CODE_DEPOSIT * L`. The first deployment cannot be known at transaction construction time. However, this scenario is extremely rare and not worth the complexity of special handling.

**Implementation:**

```text
// Before execution:
W := ∅
for each tuple t in tx.access_list:
  warm(t.Address)           // per EIP-2930/EIP-2929 rules
  if t.CheckCodeHash == true:
    acc := load_account(t.Address)
    W.insert(acc.codeHash)

// On successful CREATE/CREATE2:
H := keccak256(R)
if (H in W) {
  // duplicate: no deposit gas
  link_codehash(new_account, H)
} else {
  charge GAS_CODE_DEPOSIT * len(R)
  persist_code(H, R)
  link_codehash(new_account, H)
}
```

#### `CREATE` vs `CREATE2`

`CREATE2` already charges for hashing the init code when deriving the address. That cost remains unchanged. The runtime-code deduplication hash (`keccak256(R)`) is separate: even with `CREATE2`, the runtime hash must be computed on success to determine whether the code is new or already stored.

## Rationale

### Harmonization across state creation

With the current pricing, the gas cost of creating 1 byte of state varies depending on the method used. The following table shows the various methods and their gas cost per byte. The calculation ignores the transaction intrinsic cost (21k gas units) and the costs of additional opcodes and scaffolding needed to execute such a transaction.

| Method                                                      | What is written                                | Intrinsic gas                                                                                 | Bytes → state | Gas / byte |
| ----------------------------------------------------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------- | ------------- | ---------- |
| Deploy 24kB contract ([EIP-170](./eip-170.md) limit)        | Runtime code + account trie node               | 32,000 CREATE + 25,000 new account + 200 × 24,576 code deposit = 4,972,200 gas                | 24,576 B      | ~202 gas   |
| Fund fresh EOA with 1 wei                                   | Updated account leaf                           | 25,000 new account                                                                            | ~112 B        | ~223 gas   |
| Add delegate flag to funded EOA ([EIP-7702](./eip-7702.md)) | 23 B (0xef0100‖address) + updated account leaf | 25,000 PER_EMPTY_ACCOUNT + 12,500 PER_AUTH_BASE + 1,616 calldata - 7,823 refund = ~31,300 gas | ~135 B        | ~232 gas   |
| [EIP-7702](./eip-7702.md) authorization to empty address    | 23 B (0xef0100‖address) + updated account leaf | 25,000 PER_EMPTY_ACCOUNT + 12,500 PER_AUTH_BASE + 1,616 calldata = 39,116 gas                 | ~135 B        | ~289 gas   |
| Fill new storage slots (SSTORE 0→x)                         | Slot in storage trie                           | 20,000 gas/slot                                                                               | 32 B          | 625 gas    |

To harmonize costs, we first set the gas cost of a single state byte, `cost_per_state_byte`. **This cost targets an average growth of 60 GiB per year at a block gas limit of 300M gas units and an average gas utilization for state growth of 30%**. A [recent empirical analysis](../assets/eip-8011/multidim_empirical_analysis.md) has shown that, at current gas prices, state creation accounts for approximately 30% of all gas consumed. ** Additionally, on average, blocks use half of the entire available gas in the block. Thus, we are setting the unit gas cost of state creation based on the average case. Finally, we are targeting a 300M block limit to account for scaling optimizations expected in the short to medium term.

This capacity corresponds to an average of $\frac{60 \times 1024^3}{365} = 176,505,505$ bytes per day. With a 300M gas limit, Ethereum will process $150M \times 7,200 = 1,080,000M$ gas units per day, at block target. With a 30% consumption dedicated to state creation, the total gas units per day for state creation are $1,080,000M \times 0.3 = 324,000M$. Thus, the cost per byte is $\frac{324,000M}{176,505,505}=~1,835$. To provide a further buffer and simplify calculations, we round this number and set `cost_per_state_byte` to 1900.

Now that we have a standardized cost per byte, we can derive the various costs parameters by multiplying the unit cost by the increase in bytes any given operation creates in the database (i.e., 32 bytes per slot, 112 bytes per account and 23 bytes per authorization):

- `GAS_CREATE` = 112 x `cost_per_state_byte`= 212,800
- `GAS_CODE_DEPOSIT` = `cost_per_state_byte` = 1,900
- `GAS_STORAGE_SET` = 32 x `cost_per_state_byte` = 60,800
- `GAS_NEW_ACCOUNT` = 112 x `cost_per_state_byte`= 212,800
- `GAS_SELF_DESTRUCT_NEW_ACCOUNT` = 112 x `cost_per_state_byte` = 212,800
- `PER_EMPTY_ACCOUNT_COST` = 112 x `cost_per_state_byte` = 212,800
- `PER_AUTH_BASE_COST` = 23 x `cost_per_state_byte` = 43,700

Note that the fixed cost `GAS_CREATE` for contract deployments assumes the same cost as a new account creation.

### Multidimensional metering

[EIP-7825](./eip-7825.md) introduces a limit of 16.7M gas units for a single transaction. With the proposed contract creation costs, this cap would limit the maximum contract size that can be deployed to roughly 6kb ($\frac{16,777,216 - 21,000 - 5,000,000 - 212,800}{1,900} = 6,075$). The limit by transaction was set in place to mitigate DoS attacks that result in uneven load distribution. This is not a concern for contract deployments, specially after the proposed 10x increase in costs.

An independent metering of the code deposit costs allows to lift this limit for contract creation transactions, while ensuring that users still pay the fair costs of contract deployment.

This proposal is consistent with the multidimensional gas metering introduced in [EIP-8011](./eip-8011.md). However, it only requires two dimensions, namely, `gas` and `code_deposit_gas`. If [EIP-8011](./eip-8011.md) is not implemented, a two-dimensional version of [EIP-8011](./eip-8011.md) is still required.

### Duplicated bytecode discount

- Ordering & same-block deployments: Sequential transaction execution ensures that a deployment storing new code makes it visible to later transactions in the same block. First transaction paying `code_deposit_cost`; subsequent transactions see the code as present and pay only lookup + hash costs.
- Hashing cost is necessary: Always charge `hash_cost` for runtime code. Protects against abuse with large constructor outputs.
- What counts as “same code”? Exact runtime bytecode. Even minor differences produce distinct hashes.
- Empty code handling: Clients can treat empty code as a special case with a hard-coded hash lookup (`EMPTY_CODE_HASH`), making it effectively free.

#### Access-List CodeHash Deduplication Rationale (Solving the existing-bytecode lookup issues)

The access-list based deduplication mechanism addresses a critical consensus issue that arises from database divergence across different node implementations and sync modes:

##### The Database Divergence Problem

Empirical analysis reveals that approximately **27,869 bytecodes** exist in full-synced node databases with no live account pointing to them (as of the time of writing this EIP). These orphaned codes arise from:

1. Chain reorganizations: Code blobs persist in the database even when the blocks containing their creation are reorganized away
2. Sync mode differences:
   - Full-sync nodes: Retain all historical code, including from reverted/reorged transactions
   - Snap-sync nodes: Only store code reachable from the current state trie
   - Archive nodes: May have different retention policies

This divergence means that a naive "database contains hash?" check would yield **different gas costs on different nodes for the same transaction**, breaking consensus.

##### Why Access-List Based Solution

The access-list approach solves the bytecode duplication check problem by:

1. Deterministic behavior: Only code hashes explicitly included in the transaction's access list are considered for deduplication. This makes the result independent of local database state.
2. No reverse index requirement: Unlike other approaches, this doesn't require maintaining a `codeHash → account` reverse index, which would add significant complexity and storage overhead.
3. Leverages existing infrastructure: Builds on EIP-2930 access lists and EIP-2929 access costs, requiring minimal protocol changes.
4. Explicit opt-in: Transactions must explicitly indicate which addresses to check, preventing unexpected behavior and giving users control over gas optimization.
5. Forward compatibility: This mechanism provides smooth upgrade paths. Pre-fork, nodes ignore the `checkCodeHash` field and never grant discounts. Post-fork, all consensus clients MUST enforce identical behavior. Wallet providers and transaction builders can optionally add the field to optimize gas costs, but its absence doesn't invalidate transactions.

## Backwards Compatibility

This is a backwards-incompatible gas repricing that requires a scheduled network upgrade.

Wallet developers and node operators MUST update gas estimation handling to accommodate the new calldata cost rules. Specifically:

- Wallets: Wallets using `eth_estimateGas` MUST be updated to ensure that they correctly account for the updated gas parameters. Failure to do so could result in underestimating gas, leading to failed transactions.
- Node Software: RPC methods such as `eth_estimateGas` MUST incorporate the updated formula for gas calculation with the new floor cost values.

Users can maintain their usual workflows without modification, as wallet and RPC updates will handle these changes.

### Estimated price impacts

Users and dApp developers will experience an increase in transaction costs associated with creating a new state. Assuming an ETH price of 4000 USD, here is a comparison for some operations:

New account:

- OLD: 0.5 Gwei x 25,000 x 4,000 USD = 0.05 USD
- NEW: 0.5 Gwei x 212,800 x 4,000 USD = 0.425 USD

New slot:

- OLD: 0.5 Gwei x 20,000 x 4,000 USD = 0.04 USD
- NEW: 0.5 Gwei x 60,800 x 4,000 USD = 0.122 USD

24kB contract deployment:

- OLD: 0.5 Gwei x (32,000 + 200 × 24,576) x 4,000 USD = 9.8944 USD
- NEW: 0.5 Gwei x (212,800 + 2100 + 6 * 768 + 1,900 × 24,576) x 4,000 USD = 93.828 USD

24kB contract deployment with duplicated bytecode:

- OLD: 0.5 Gwei x (32,000 + 200 × 24,576) x 4,000 USD = 9.8944 USD
- NEW: 0.5 Gwei x (212,800 + 2100 + 6 * 768) x 4,000 USD = 0.439 USD

Note that we are ignoring transaction intrinsic costs (21k gas units), call data costs, and the costs of additional opcodes and scaffolding needed to execute such transactions.

## Security Considerations

Increasing the cost of state creation operations could impact the usability of certain applications. More analysis is needed to understand the potential effects on various dApps and user behaviors.

### Mispricing with respect to ETH transfers

One potential concern is the cost of creating a new account (212,800 gas units), compared to transferring ETH to a fresh account (21,000 gas units). With this mismatch, users wishing to create new account are incentivized to first send a normal transaction (costing 21k) to this account to create it, thus avoiding the `PER_EMPTY_ACCOUNT_COST` of 212,800 gas units.

[EIP-2780](./eip-2780.md) solves this mispricing by adding a new component to the intrinsic gas cost of transactions. For transactions the sending ETH that send ETH to a fresh account. If a non-create transaction has value > 0 and targets a non-existent account, the `GAS_NEW_ACCOUNT` is added to intrinsic cost.

### Independent metering for code deposit costs

Contract creation now introduces a cost that is not accounted for in the traditional gas metering and thus doesn't contribute to the block gas limit or the individual transaction limit. This could potentially be exploited by an attacker to create very large contracts that would stress the network. More benchmarking and analysis is needed to understand the potential risks and to determine if additional mitigations are necessary.

## Reference Implementation

### Access-List Extension

For developers implementing this feature, the access list structure is extended as follows:

```go
// Geth-style struct (JSON/RPC; optional field)
type AccessTuple struct {
    Address       common.Address `json:"address"`
    StorageKeys   []common.Hash  `json:"storageKeys"`
    CheckCodeHash bool           `json:"checkCodeHash,omitempty"`
}
```

**Consensus semantics:**

- The transaction's **CodeHash Access-Set** is $W = \{ \text{codeHash}(a) \mid a \text{ is in access list and } a.\text{CheckCodeHash} = \text{true} \text{ and } a \text{ exists in state} \}$.
- `W` is built from state at the start of transaction execution. Only existing addresses with deployed code contribute.
- **Deduplication rule:** On success, if $H \in W$ $\rightarrow$ **no** `GAS_CODE_DEPOSIT * L`; else $\rightarrow$ **charge** `GAS_CODE_DEPOSIT * L` and persist.
- **Gas costs:** The cost of reading $\text{codeHash}(a)$ is already covered by EIP-2929/2930 access costs (intrinsic access-list cost and cold→warm charging). No additional lookup cost is introduced.
- **Backwards compatibility:** The `checkCodeHash` field is optional. Transactions without this field behave as they do today (no deduplication discount).

**Example transaction with access list:**

```json
{
  "from": "0x...",
  "to": null,
  "data": "0x...",
  "accessList": [
    {
      "address": "0x1234...5678",
      "storageKeys": [],
      "checkCodeHash": true
    },
    {
      "address": "0xabcd...ef00",
      "storageKeys": ["0x..."],
      "checkCodeHash": false
    }
  ]
}
```

In this example, if the deployed contract's runtime bytecode hash matches the `codeHash` of address `0x1234...5678`, the deployment receives the deduplication discount and skips `GAS_CODE_DEPOSIT * L`.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
