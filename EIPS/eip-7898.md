---
eip: 7898
title: Uncouple execution payload from beacon block
description: Separates the execution payload from beacon block to independently transmit them
author: Gajinder Singh (@g11tech)
discussions-to: https://ethereum-magicians.org/t/uncouple-execution-payload-from-beacon-block/23029
status: Draft
type: Standards Track
category: Core
created: 2025-03-01
---

## Abstract

Currently, the beacon block in Ethereum Consensus embeds transactions within the `ExecutionPayload` field of `BeaconBlockBody`. This EIP proposes to replace `ExecutionPayload` with `ExecutionPayloadHeader` in `BeaconBlockBody` and to independently transmit `ExecutionPayloadBundle`.

However, this EIP makes no change to the block import mechanism, with the exception that block availability now includes waiting for the availability of `ExecutionPayloadBundle`, making it different and simpler from proposals like ePBS/APS.

But this availability requirement can in fact be restricted to `gossip` import while allowing optimistic syncing of the execution layer (EL) on checkpoint/range sync as EL can pull full blocks from their peers in optimistic sync as they do now.

## Motivation

The Ethereum protocol has an ambitious goal to grow the `gasLimit` of the execution payloads (possibly by 10X). This leads to larger messages, negatively affecting the networking and block processing pipelines of the consensus layer (CL) clients leading to following issues:

1. Higher latencies for the arrival of beacon blocks increase, requiring larger bandwidth resources to be made available for the beacon node.
2. The greater number and size of transactions directly increase the merkelization compute time, increasing the import time of the block.

We know from timing games that the block import latency greatly affects a client's performance to make correct head attestations. With this EIP, block transmission and block import processes will be decongested, allowing for greater flexibility in receiving a larger `ExecutionPayloadBundle`, while the beacon block can simultaneously undergo processing. 

In addition, EL clients can also independently participate in forwarding and receiving larger execution blocks. That mechanism however can be independently developed and is out of scope for this EIP.

Additional benefits obtained from this EIP:

- Consensus clients don't need to store and serve blocks with transactions, providing greater efficiency and reduced resource requirements for running a beacon node.
- The proposer-builder separation (PBS) pipeline becomes more efficient by the proposer transmitting the signed block directly to the p2p network, while submitting to the builder/relay for the independent reveal of the `ExecutionPayloadBundle`.
- In the future with zero-knowledge (ZK) proof of the EL block execution, nodes could treat the transactions similarly to blobs which leverage data availability sampling (DAS) mechanisms for available data without requiring re-execution of transactions to establish validity. Hence the L1 execution could itself become a rollup by alleviating the need to import all transaction data by a node.

Furthermore CL clients apis and code path will become cleaner and more maintainable because of collapse of blinded and full versions (like `BlindedBeaconBlock`, `BlindedBeaconBlockBody`) into same types.

## Specification

- `ExecutionPayload` in the `BeaconBlockBody` is replaced by `ExecutionPayloadHeader`
- `ExecutionPayloadBundle` is computed by the block proposer/builder and gossiped independently on a separate new topic. Also builder `submitBlindedBlock` api is modified to respond with `ExecutionPayloadBundle` instead.
- Data availability checks for block import into forkchoice now must wait for availability of the corresponding `ExecutionPayloadBundle` but only for gossiped blocks
- `newPayloadHeader` engine api is introduced to augment the previous usage of `newPayload` in block processing when `ExecutionPayload` is not available for e.g. in processing range synced blocks signaling EL clients to optimistic sync those payloads from EL p2p network.

ELs can optionally introduce a `getExecutionPayload` method (similar to `getBlobs`) to assist with faster recovery of execution payload from the EL's p2p network peers who could announce new payload hashes when they see new `VALID` payloads. However, as noted above, that mechanism could be independently specified and is out of scope for this EIP.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Types

- `ExecutionPayloadHeader` and `ExecutionPayload` refer to the canonical types in the consensus and execution specifications for the active fork. This EIP does not change the field set of either type.

- Terminology note: this document previously referred to the bundle below as `ExecutionPayloadWithInclusionProof`. To avoid implying a cryptographic inclusion proof, it is renamed to `ExecutionPayloadBundle`. The bundle contains a header and full payload; consistency is established by recomputing the header from the payload, not by providing a separate Merkle proof.

- `ExecutionPayloadBundle` is defined for gossip and handoff purposes as:

```
class ExecutionPayloadBundle(Container):
    header: ExecutionPayloadHeader         # Header committed in the beacon block body
    payload: ExecutionPayload              # Full execution payload for the same block
```

Validation rule for `ExecutionPayloadBundle`:

- `derive_header(payload) == header` where `derive_header` deterministically computes all `ExecutionPayloadHeader` fields from `ExecutionPayload` (e.g., `transactions_root`, `receipts_root`, `state_root`, `withdrawals_root`, `base_fee_per_gas`, etc.). Nodes MUST recompute and compare for equality. No additional cryptographic proof is required beyond recomputation.

Implementations MAY additionally include per-field SSZ Merkle proofs for early filtering, but such proofs are non-normative and not required by this EIP.

### P2P gossip

- A new global gossip topic is introduced for `ExecutionPayloadBundle` messages corresponding to the current fork. Implementations MUST version this topic per-fork similarly to other consensus topics.
- Gossip message payload is the SSZ serialization of `ExecutionPayloadBundle`.
- Upon receiving a message, nodes MUST before re-gossiping:
  - Verify that `payload.block_hash` matches `header.block_hash` semantics for the active fork (i.e., the hash derived from `payload` equals `header.block_hash`).
  - Verify `derive_header(payload) == header`.
  - Perform basic sanity checks (parent hash linkage, timestamp, withdrawals format for the fork, blob commitments if applicable, etc.).
- Nodes SHOULD enforce size caps and rate limits consistent with existing large-object topics (e.g., blob sidecars) and MAY defer full validation of the payload body to background tasks after initial header consistency checks.

### Engine API

- Introduce `engine_newPayloadHeader` to complement `engine_newPayload` when only the header is available during block processing:

```
engine_newPayloadHeader(payloadHeader: ExecutionPayloadHeader, parentBeaconBlockRoot: Hash32) -> PayloadStatus
```

Semantics:

- Clients call `engine_newPayloadHeader` during processing of a beacon block that includes only `ExecutionPayloadHeader`.
- The Execution Layer MUST respond with one of the standard `PayloadStatus` values: `VALID`, `INVALID`, `SYNCING`, `ACCEPTED`. The status reflects header-level checks (e.g., parent availability, timestamp monotonicity, base fee math, withdrawals root format, blob gas fields when applicable).
- Upon later receipt of the full payload via `engine_newPayload` (triggered by gossip recovery or EL p2p sync), the EL completes full execution and updates status accordingly.

This EIP does not change existing `engine_forkchoiceUpdated` semantics. Implementations MAY use `engine_forkchoiceUpdated` to hint optimism while the body is being synced.

### Forkchoice and availability

- For blocks received via gossip, Consensus Layer clients MUST treat the beacon block as available for forkchoice only after the corresponding `ExecutionPayloadBundle` has been received and validated per the rules above. Until then, the block MUST NOT be considered available for head selection.
- For checkpoint or range sync, Consensus Layer clients MAY proceed optimistically by processing the beacon block with only `ExecutionPayloadHeader` and signaling the EL to recover bodies. In this mode, forkchoice participation MUST follow existing optimistic-sync safety constraints until bodies are validated.

### Builder/relay interaction (non-normative guidance)

- Existing `submitBlindedBlock` style APIs SHOULD be extended to return `ExecutionPayloadBundle` (or equivalently, a full `ExecutionPayload` together with the `ExecutionPayloadHeader` committed in the beacon block). Implementations SHOULD ensure the returned object satisfies the validation rule `derive_header(payload) == header`.

## Rationale

There is another choice we could have made to go for `SignedExecutionPayload` instead of `ExecutionPayloadBundle` and having a `SignedExecutionPayloadHeader` with builder signing these messages (validator is the builder in local block building). But without builder enshrinement tight gossip validation of `SignedExecutionPayload` would be an issue and could become a DOS vector.

The benefit of `SignedExecutionPayload` design is that it could be transmitted ahead of even the `SignedExecutionPayloadHeader` inclusion in beacon block and is especially useful in PBS pipeline where the proposal to builder/relay latency can be reduced significantly.

## Backwards Compatibility

This change isn't backward compatible and a new hardfork is required to activate this EIP.

## Test Cases

<-- TODO -->

## Reference Implementation

<-- TODO -->

## Security Considerations

<-- TODO -->

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
