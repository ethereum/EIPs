---
eip: 0288
title: Secure Intents for Agent Coordination
description: Cryptographic coordination of autonomous agents via verifiable intent structures without trusted intermediaries
author: Kwame Bryan (@kbryan)
discussions-to: https://ethereum-magicians.org/t/secure-intents-a-cryptographic-framework-for-autonomous-agent-coordination-draft-eip/24989
status: Draft
type: Standards Track
category: Interface
created: 2025-08-02
---

## Abstract

This EIP proposes a cryptographic framework that enables autonomous agents to coordinate directly without relying on trusted intermediaries for verification. The framework addresses the fundamental trust problem in autonomous agent interactions by providing cryptographic guarantees for authenticity, integrity, confidentiality, and temporal validity of agent intentions. Through the composition of digital signatures, public-key encryption, temporal validity constraints, and execution metadata, agents can create verifiable proofs of their intentions that can be validated by any party without requiring centralized verification authorities. The framework includes formal security properties, protocol specifications, and implementation guidelines specifically adapted for Ethereum and cross-chain environments.

## Motivation

The proliferation of autonomous agents in decentralized systems has created a fundamental coordination problem that existing solutions fail to address adequately. Current approaches to autonomous agent coordination rely heavily on centralized verification authorities, trusted execution environments, or assume agents operate within trusted network boundaries. These limitations create significant barriers to scalability, interoperability, and decentralization in autonomous system architectures.

Consider a typical autonomous agent interaction scenario: Agent A generates a trading decision based on market analysis and communicates this intent to Execution System B. Under conventional architectures, System B must establish trust across multiple dimensions: first, that the decision actually originated from Agent A and has not been forged by a malicious actor; second, that the decision payload has not been tampered with or modified during transmission; third, that the decision reflects current market conditions rather than stale or replayed information; and fourth, that sensitive strategy information contained within the decision remains confidential from unauthorized observers who might exploit this information for front-running or other adversarial purposes.

The conventional solution to this multi-faceted trust problem involves deploying authentication servers, managing API keys, implementing access control lists, and establishing secure communication channels. However, this approach fundamentally fails to scale across heterogeneous systems and creates dangerous single points of failure. When autonomous agents need to coordinate across organizational boundaries, different blockchain networks, or diverse execution environments, the complexity of managing trust relationships grows exponentially. Each new integration requires establishing bilateral trust agreements, managing credential lifecycles, and maintaining secure communication infrastructure.

Furthermore, existing solutions typically address these security properties independently rather than providing a unified framework. Authentication systems verify identity but may not ensure message integrity. Encryption provides confidentiality but does not guarantee authenticity. Timestamp services can provide temporal ordering but may not prevent replay attacks. This fragmented approach leads to complex system architectures with multiple potential failure points and inconsistent security guarantees.

The emergence of cross-chain and multi-protocol environments has exacerbated these challenges. Autonomous agents operating in DeFi protocols, for example, may need to coordinate actions across multiple blockchain networks, each with different security models, consensus mechanisms, and trust assumptions. Traditional centralized coordination mechanisms become bottlenecks and introduce counterparty risks that undermine the decentralized nature of these systems.

What is needed is a cryptographic framework that provides unified security guarantees for autonomous agent coordination without requiring trusted third parties or centralized infrastructure. Such a framework must be mathematically sound, practically implementable, and compatible with existing blockchain and decentralized system architectures. It must enable agents to prove the authenticity, integrity, confidentiality, and temporal validity of their intentions through purely cryptographic means, allowing any party to verify these properties without relying on external authorities or shared trust assumptions.

This EIP addresses these fundamental challenges by proposing a cryptographic framework that composes standard cryptographic primitives in a novel way specifically designed for autonomous agent coordination. The framework enables direct agent-to-agent and agent-to-system coordination across organizational and protocol boundaries while maintaining strong security guarantees and preserving the decentralized nature of the underlying systems.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Core Definitions

This specification defines a cryptographic framework for autonomous agent coordination based on the composition of standard cryptographic primitives. The framework introduces the concept of a "Secure Intent" as the fundamental unit of agent communication.

**Definition 1 (Secure Intent)**: A secure intent is a cryptographic construct defined by the structured encoding:

```
SecureIntent = (I, σ) where I = len(C) || C || len(T) || T || len(M) || M

```

Where:

- `C = E_KR(P)` is the encrypted payload where `P ∈ {0,1}*` contains the agent's intention

- `T ∈ ℕ` is a Unix timestamp representing the intent's time-to-live (8 bytes, big-endian)

- `M ∈ {0,1}*` contains JSON-encoded execution metadata

- `len(x)` denotes the 4-byte big-endian length prefix for field x

- `||` denotes binary concatenation

- `σ = Sign_A(I)` represents digital signature of I using agent A's private key

**Definition 2 (Intent Validity)**: An intent `(I, σ)` is considered valid at time `t` if and only if:

1. `Parse(I) ≠ ⊥` (intent structure is well-formed)

2. `Verify_A(I, σ) = 1` (signature verification succeeds)

3. `t ≤ T + CLOCK_TOLERANCE` (temporal validity with clock skew tolerance)

4. `ValidateMetadata(M) = 1` (metadata conforms to schema)

Where `CLOCK_TOLERANCE` is a system parameter (RECOMMENDED: 300 seconds).

### Cryptographic Primitives

The framework relies on standard cryptographic primitives with specific security requirements:

**Digital Signature Scheme**: The framework requires a digital signature scheme `(KeyGen, Sign, Verify)` where:

- `KeyGen(1^λ) → (pk, sk)`: Generates a key pair with security parameter λ ≥ 256

- `Sign(sk, m) → σ`: Produces signature σ on message m using private key sk

- `Verify(pk, m, σ) → {0,1}`: Outputs 1 if σ is a valid signature on m under public key pk

The signature scheme MUST satisfy existential unforgeability under chosen message attack (EUF-CMA). For Ethereum compatibility, ECDSA with secp256k1 curve is REQUIRED.

**Public-Key Encryption Scheme**: The framework requires a public-key encryption scheme `(Gen, Enc, Dec)` where:

- `Gen(1^λ) → (pk, sk)`: Generates a key pair with security parameter λ ≥ 2048 (RSA) or λ ≥ 256 (ECC)

- `Enc(pk, m) → c`: Encrypts message m under public key pk

- `Dec(sk, c) → m`: Decrypts ciphertext c under private key sk

The encryption scheme MUST provide indistinguishability under chosen plaintext attack (IND-CPA). ECIES with secp256k1 is RECOMMENDED for Ethereum compatibility.

### Key Management Requirements

**Key Generation**: All cryptographic keys MUST be generated using cryptographically secure pseudo-random number generators (CSPRNG) with entropy sources providing at least 256 bits of security.

**Key Storage**: Private keys MUST be protected using one of the following methods:

- Hardware Security Modules (HSMs) compliant with FIPS 140-2 Level 2 or higher

- Secure enclaves with remote attestation capabilities

- Software-based keystores with AES-256 encryption and secure key derivation

**Key Distribution**: Public key distribution MUST ensure authenticity through one of:

- On-chain registration with cryptographic proof of ownership

- Certificate authorities with verifiable trust chains

- Web-of-trust mechanisms with multi-party verification

- Self-sovereign identity systems with decentralized identifiers (DIDs)

### Metadata Schema

The metadata component M MUST conform to the following JSON schema for interoperability:

```

json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "required": ["version", "intent_type", "created_at", "chain_id", "gas_limit"],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$",
      "description": "Semantic version (e.g., '1.0.0')"
    },
    "intent_type": {
      "type": "string",
      "enum": ["swap", "transfer", "execute", "delegate", "bridge", "custom"],
      "description": "Classification of intent purpose"
    },
    "created_at": {
      "type": "integer",
      "minimum": 1609459200,
      "description": "Unix timestamp of intent creation"
    },
    "chain_id": {
      "type": "integer",
      "minimum": 1,
      "description": "EIP-155 chain identifier"
    },
    "gas_limit": {
      "type": "integer",
      "minimum": 21000,
      "maximum": 30000000,
      "description": "Maximum gas for execution"
    },
    "priority": {
      "type": "integer",
      "minimum": 0,
      "maximum": 255,
      "description": "Execution priority level"
    },
    "dependencies": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^0x[a-fA-F0-9]{64}$"
      },
      "description": "Required predecessor intent hashes"
    },
    "constraints": {
      "type": "object",
      "description": "Additional validation rules"
    },
    "nonce": {
      "type": "string",
      "pattern": "^0x[a-fA-F0-9]{64}$",
      "description": "Unique identifier for deduplication"
    }
  }
}

```

### EIP-712 Integration

For Ethereum wallet compatibility, intents MUST support EIP-712 structured data signing with the following domain and type definitions:

**Domain Separator**:

```

javascript
const domain = {
  name: 'SecureIntents',
  version: '1.0.0',
  chainId: metadata.chain_id,
  verifyingContract: '0x0000000000000000000000000000000000000000'
};

```

**Type Definitions**:

```

javascript
const types = {
  SecureIntent: [
    { name: 'encryptedPayload', type: 'bytes' },
    { name: 'timestamp', type: 'uint256' },
    { name: 'metadata', type: 'string' }
  ]
};

```

### Protocol Specifications

**Intent Generation Protocol**:

```
Input: Payload P, recipient public key K_R, metadata M, TTL T, agent private key s_A
Output: Secure intent (I, σ) or ⊥

1. Validate inputs:

   - Verify |P| ≤ MAX_PAYLOAD_SIZE (65,536 bytes)
   - Verify T > current_time
   - Verify T ≤ current_time + MAX_TTL (86,400 seconds)
   - Validate metadata M against JSON schema

2. Generate encrypted payload:

   - C ← Enc(K_R, P)

3. Encode intent structure:

   - I ← encode_length_prefixed(C, T, M)
   

4. Generate signature:

   - σ ← Sign(s_A, I)

5. Return (I, σ)

function encode_length_prefixed(C, T, M):
   return len(C) || C || len(T) || T || len(M) || M

```

**Intent Verification Protocol**:

```
Input: Intent (I, σ), agent public key pk_A, current time t
Output: {VALID, INVALID, EXPIRED}

1. Parse intent structure:

   - (C, T, M) ← decode_length_prefixed(I)
   - If parsing fails, return INVALID

2. Check temporal validity:

   - If t > T + CLOCK_TOLERANCE, return EXPIRED

3. Verify signature:

   - If Verify(pk_A, I, σ) ≠ 1, return INVALID

4. Validate metadata:

   - If ValidateMetadata(M) ≠ 1, return INVALID

5. Return VALID

function decode_length_prefixed(I):
   offset = 0
   C_len = read_uint32_be(I[offset:offset+4])
   offset += 4
   C = I[offset:offset+C_len]
   offset += C_len
   T_len = read_uint32_be(I[offset:offset+4])
   offset += 4
   T = read_uint64_be(I[offset:offset+8])
   offset += 8
   M_len = read_uint32_be(I[offset:offset+4])
   offset += 4
   M = I[offset:offset+M_len]
   return (C, T, M)

```

### Cross-Chain Intent Coordination

**Cross-Chain Intent Structure**: Cross-chain intents extend the metadata with additional fields:

```

json
{
  "source_chain": 1,
  "target_chain": 137,
  "bridge_protocol": "polygon-pos",
  "atomic_execution": true,
  "rollback_data": "0x...",
  "inclusion_proof": {
    "block_number": 18500000,
    "merkle_root": "0x...",
    "proof": ["0x...", "0x..."],
    "leaf_index": 42
  }
}

```

**Cross-Chain Atomic Execution Protocol**:

```
Phase 1 - Commitment (Source Chain):

1. Submit intent to source chain commitment contract

2. Generate inclusion proof for intent commitment

3. Set execution timeout (recommended: 1 hour)

Phase 2 - Verification (Target Chain):

1. Submit intent + inclusion proof to target chain

2. Verify proof against source chain state root

3. Execute intent if verification succeeds

4. Generate execution proof

Phase 3 - Finalization:

1. If execution successful: Submit completion proof to source chain

2. If execution failed: Submit failure proof and trigger rollback

3. If timeout exceeded: Automatic rollback after timeout period

Rollback Protocol:

1. Verify timeout condition or explicit failure proof

2. Execute rollback transaction using rollback_data

3. Release locked resources on source chain

4. Emit rollback event for monitoring systems

```

**Cross-Chain Security Requirements**:

- Inclusion proofs MUST be verified against finalized block headers

- Atomic execution MUST complete within specified timeout periods

- Rollback mechanisms MUST restore source chain state consistency

- Bridge protocols MUST provide fraud proof capabilities

### Ethereum Integration

**Smart Contract Interface**:

```

solidity
pragma solidity ^0.8.19;

interface ISecureIntentVerifier {
    struct Intent {
        bytes encryptedPayload;
        uint256 timestamp;
        string metadata;
    }
    
    struct CrossChainProof {
        uint256 sourceChain;
        uint256 blockNumber;
        bytes32 merkleRoot;
        bytes32[] proof;
        uint256 leafIndex;
    }
    
    function verifyIntent(
        Intent calldata intent,
        bytes calldata signature,
        address agentAddress
    ) external view returns (bool valid, bool expired);
    
    function executeIntent(
        Intent calldata intent,
        bytes calldata signature,
        address agentAddress
    ) external;
    
    function executeCrossChainIntent(
        Intent calldata intent,
        bytes calldata signature,
        address agentAddress,
        CrossChainProof calldata proof
    ) external;
    
    function commitIntent(
        bytes32 intentHash,
        uint256 targetChain,
        uint256 timeout
    ) external;
    
    function rollbackIntent(
        bytes32 intentHash,
        bytes calldata rollbackData
    ) external;
    
    event IntentExecuted(
        address indexed agent,
        bytes32 indexed intentHash,
        uint256 timestamp,
        uint256 gasUsed
    );
    
    event CrossChainIntentCommitted(
        bytes32 indexed intentHash,
        uint256 indexed targetChain,
        uint256 timeout
    );
    
    event IntentRolledBack(
        bytes32 indexed intentHash,
        string reason
    );
}

```

**Gas Cost Analysis**:

Based on current Ethereum gas costs, the framework operations have the following estimated costs:

- Intent verification (signature + metadata validation): ~5,000 gas

- Single-chain intent execution: ~25,000 gas base + execution costs

- Cross-chain intent commitment: ~35,000 gas

- Cross-chain intent execution: ~55,000 gas + proof verification costs

- Intent rollback: ~30,000 gas

Optimization techniques:

- Batch verification for multiple intents: ~60% gas reduction per additional intent

- Precomputed signature verification tables: ~20% gas reduction

- Compressed metadata encoding: ~30% storage cost reduction

### Security Properties

The framework provides the following formal security guarantees:

**Theorem 1 (Authenticity)**: Under the assumption that the underlying signature scheme satisfies EUF-CMA security, no polynomial-time adversary can forge valid intents for honest agents with probability greater than negl(λ), where negl is a negligible function and λ is the security parameter.

**Theorem 2 (Confidentiality)**: Under the assumption that the underlying encryption scheme satisfies IND-CPA security, no polynomial-time adversary can distinguish between encrypted payloads with advantage greater than negl(λ).

**Theorem 3 (Temporal Integrity)**: For any intent with timestamp T, the probability that an adversary can cause acceptance of the intent at time t > T + CLOCK_TOLERANCE is 0, assuming honest verifiers.

**Theorem 4 (Cross-Chain Consistency)**: Under the assumption that bridge protocols provide fraud-proof capabilities and finality guarantees, cross-chain intent execution maintains atomic consistency with probability 1 - negl(λ).

## Rationale

The design of this cryptographic framework reflects careful consideration of the unique requirements of autonomous agent coordination in decentralized environments. Several key design decisions distinguish this approach from existing solutions and warrant detailed explanation.

### Structured Encoding Approach

The move from simple concatenation to length-prefixed encoding addresses the critical parsing ambiguity while maintaining efficiency. Length prefixes provide unambiguous field boundaries without requiring complex delimiter escaping or variable-length encoding schemes. The 4-byte length prefixes support payloads up to 4GB while maintaining reasonable overhead for typical intent sizes.

This encoding approach enables streaming parsers and provides natural extension points for future protocol versions. The structured format also facilitates efficient verification in resource-constrained environments such as smart contracts.

### Enhanced Cross-Chain Architecture

The atomic execution protocol addresses the fundamental consistency challenges in cross-chain coordination. By requiring explicit commitment phases, inclusion proofs, and rollback mechanisms, the framework provides stronger guarantees than simple message-passing approaches.

The timeout-based rollback mechanism ensures liveness even when target chains experience extended downtime or congestion. The fraud-proof requirement for bridge protocols ensures that cross-chain operations maintain security equivalent to the stronger of the two participating chains.

### Key Management Integration

While maintaining implementation flexibility, the specification now provides concrete security requirements for key management. This guidance helps implementers avoid common pitfalls while supporting diverse deployment scenarios from hardware wallets to enterprise HSM systems.

The multiple options for key distribution acknowledge that different deployment contexts have varying trust assumptions and infrastructure requirements. The framework remains agnostic to specific solutions while ensuring minimum security baselines.

### EIP-712 Integration

The complete EIP-712 specification enables seamless wallet integration and user verification workflows. This integration is crucial for scenarios requiring human oversight or approval, particularly for high-value or irreversible operations.

The structured data approach provides users with clear visibility into intent contents while maintaining the cryptographic guarantees of the framework. This transparency is essential for building user trust and enabling adoption.

### Gas Optimization Strategy

The gas cost analysis and optimization techniques address practical deployment concerns in Ethereum's fee-sensitive environment. Batch verification capabilities enable cost-effective processing of multiple intents, crucial for high-throughput applications.

The optimization strategies maintain security properties while reducing operational costs, making the framework economically viable for a broader range of use cases.

## Backwards Compatibility

This EIP introduces new cryptographic standards for autonomous agent coordination and does not modify existing Ethereum protocol rules or consensus mechanisms. The structured encoding format maintains compatibility with existing binary processing libraries and smart contract development frameworks.

The EIP-712 integration ensures compatibility with existing Ethereum wallets and user interfaces. Legacy systems can adopt the framework incrementally, implementing intent verification alongside existing security mechanisms during transition periods.

Version fields in the metadata schema enable forward compatibility and smooth migration paths for future protocol enhancements. The modular design allows selective adoption of framework components based on specific security and functionality requirements.

## Test Cases

### Basic Intent Operations

```

typescript
// Test Case 1: Valid intent creation and verification
const agent = await generateKeyPair();
const recipient = await generateKeyPair();
const payload = "swap 100 USDC for ETH";
const metadata = {
  version: "1.0.0",
  intent_type: "swap",
  created_at: Math.floor(Date.now() / 1000),
  chain_id: 1,
  gas_limit: 200000
};
const ttl = Math.floor(Date.now() / 1000) + 3600;

const intent = await createIntent(payload, recipient.publicKey, metadata, ttl, agent.privateKey);
const verification = await verifyIntent(intent, agent.publicKey, Math.floor(Date.now() / 1000));
assert(verification === "VALID");

```

### Temporal Validity Testing

```

typescript
// Test Case 2: Expired intent rejection
const expiredTtl = Math.floor(Date.now() / 1000) - 3600;

const expiredIntent = await createIntent(payload, recipient.publicKey, metadata, expiredTtl, agent.privateKey);
const expiredVerification = await verifyIntent(expiredIntent, agent.publicKey, Math.floor(Date.now() / 1000));
assert(expiredVerification === "EXPIRED");

```

### Cross-Chain Coordination

```

typescript
// Test Case 3: Cross-chain atomic execution
const crossChainMetadata = {
  ...metadata,
  source_chain: 1,
  target_chain: 137,
  bridge_protocol: "polygon-pos",
  atomic_execution: true,
  rollback_data: "0x1234567890abcdef"
};

const crossChainIntent = await createIntent(payload, recipient.publicKey, crossChainMetadata, ttl, agent.privateKey);
const commitmentTx = await commitCrossChainIntent(crossChainIntent, 137, 3600);
const inclusionProof = await generateInclusionProof(commitmentTx.blockNumber, commitmentTx.transactionHash);
const execution = await executeCrossChainIntent(crossChainIntent, inclusionProof);
assert(execution.success === true);

```

### Security Property Validation

```

typescript
// Test Case 4: Signature forgery resistance
const maliciousAgent = await generateKeyPair();
try {
  const forgedIntent = await createIntent(payload, recipient.publicKey, metadata, ttl, maliciousAgent.privateKey);
  const forgedVerification = await verifyIntent(forgedIntent, agent.publicKey, Math.floor(Date.now() / 1000));
  assert(forgedVerification === "INVALID");
} catch (error) {
  // Expected: signature verification should fail
}

```

## Reference Implementation

```

typescript
import { createHash, randomBytes } from 'crypto';
import { generateKeyPairSync, sign, verify } from 'crypto';
import * as secp256k1 from 'secp256k1';

import { encrypt, decrypt } from 'eciesjs';

export class SecureIntentFramework {
  private static readonly MAX_PAYLOAD_SIZE = 65536; // 64KB
  private static readonly MAX_TTL_SECONDS = 86400; // 24 hours
  private static readonly CLOCK_TOLERANCE = 300; // 5 minutes

  public static async createIntent(
    payload: string,
    recipientPublicKey: Buffer,
    metadata: IntentMetadata,
    ttl: number,
    agentPrivateKey: Buffer
  ): Promise<SecureIntent> {
    // Validate inputs
    const payloadBuffer = Buffer.from(payload, 'utf8');
    if (payloadBuffer.length > this.MAX_PAYLOAD_SIZE) {
      throw new Error('Payload exceeds maximum size');
    }
    
    const currentTime = Math.floor(Date.now() / 1000);
    if (ttl <= currentTime || ttl > currentTime + this.MAX_TTL_SECONDS) {
      throw new Error('Invalid TTL');
    }

    this.validateMetadata(metadata);

    // Encrypt payload using ECIES
    const encryptedPayload = encrypt(recipientPublicKey, payloadBuffer);
    
    // Encode timestamp as 8-byte big-endian
    const timestampBuffer = Buffer.allocUnsafe(8);
    timestampBuffer.writeBigUInt64BE(BigInt(ttl), 0);
    
    // Encode metadata as JSON
    const metadataBuffer = Buffer.from(JSON.stringify(metadata), 'utf8');

    // Create length-prefixed structure
    const intentData = this.encodeLengthPrefixed(encryptedPayload, timestampBuffer, metadataBuffer);

    // Generate signature using secp256k1
    const hash = createHash('sha256').update(intentData).digest();
    const signature = secp256k1.ecdsaSign(hash, agentPrivateKey);

    return {
      intentData: intentData.toString('base64'),
      signature: Buffer.concat([
        Buffer.from(signature.signature),
        Buffer.from([signature.recid])
      ]).toString('base64')
    };
  }

  public static async verifyIntent(
    intent: SecureIntent,
    agentPublicKey: Buffer,
    currentTime: number
  ): Promise<'VALID' | 'INVALID' | 'EXPIRED'> {
    try {
      const intentData = Buffer.from(intent.intentData, 'base64');
      const signatureBuffer = Buffer.from(intent.signature, 'base64');

      // Parse intent structure
      const { encryptedPayload, timestamp, metadata } = this.decodeLengthPrefixed(intentData);

      // Check temporal validity with clock tolerance
      if (currentTime > timestamp + this.CLOCK_TOLERANCE) {
        return 'EXPIRED';
      }

      // Verify signature
      const hash = createHash('sha256').update(intentData).digest();
      const signature = signatureBuffer.slice(0, 64);
      const recid = signatureBuffer[64];
      
      const recoveredPubKey = secp256k1.ecdsaRecover(signature, recid, hash, false);
      if (!agentPublicKey.equals(Buffer.from(recoveredPubKey))) {
        return 'INVALID';
      }

      // Validate metadata
      this.validateMetadata(metadata);

      return 'VALID';
    } catch (error) {
      return 'INVALID';
    }
  }

  private static encodeLengthPrefixed(
    encryptedPayload: Buffer,
    timestamp: Buffer,
    metadata: Buffer
  ): Buffer {
    const result = Buffer.alloc(
      4 + encryptedPayload.length + 
      4 + timestamp.length + 
      4 + metadata.length
    );
    
    let offset = 0;
    
    // Encrypted payload
    result.writeUInt32BE(encryptedPayload.length, offset);
    offset += 4;
    encryptedPayload.copy(result, offset);
    offset += encryptedPayload.length;
    
    // Timestamp
    result.writeUInt32BE(timestamp.length, offset);
    offset += 4;
    timestamp.copy(result, offset);
    offset += timestamp.length;
    
    // Metadata
    result.writeUInt32BE(metadata.length, offset);
    offset += 4;
    metadata.copy(result, offset);
    
    return result;
  }

  private static decodeLengthPrefixed(intentData: Buffer): {
    encryptedPayload: Buffer;
    timestamp: number;
    metadata: IntentMetadata;
  } {
    let offset = 0;
    
    // Read encrypted payload
    const payloadLength = intentData.readUInt32BE(offset);
    offset += 4;
    const encryptedPayload = intentData.slice(offset, offset + payloadLength);
    offset += payloadLength;
    
    // Read timestamp
    const timestampLength = intentData.readUInt32BE(offset);
    offset += 4;
    if (timestampLength !== 8) {
      throw new Error('Invalid timestamp length');
    }
    const timestamp = Number(intentData.readBigUInt64BE(offset));
    offset += 8;
    
    // Read metadata
    const metadataLength = intentData.readUInt32BE(offset);
    offset += 4;
    const metadataBuffer = intentData.slice(offset, offset + metadataLength);
    const metadata = JSON.parse(metadataBuffer.toString('utf8'));
    
    return { encryptedPayload, timestamp, metadata };
  }

  private static validateMetadata(metadata: IntentMetadata): void {
    const required = ['version', 'intent_type', 'created_at', 'chain_id', 'gas_limit'];
    for (const field of required) {
      if (!(field in metadata)) {
        throw new Error(`Missing required metadata field: ${field}`);
      }
    }

    if (!/^\d+\.\d+\.\d+$/.test(metadata.version)) {
      throw new Error('Invalid version format');
    }

    const validTypes = ['swap', 'transfer', 'execute', 'delegate', 'bridge', 'custom'];
    if (!validTypes.includes(metadata.intent_type)) {
      throw new Error('Invalid intent type');
    }

    if (metadata.gas_limit < 21000 || metadata.gas_limit > 30000000) {
      throw new Error('Invalid gas limit');
    }

    if (metadata.chain_id < 1) {
      throw new Error('Invalid chain ID');
    }
  }
}

export interface IntentMetadata {
  version: string;
  intent_type: 'swap' | 'transfer' | 'execute' | 'delegate' | 'bridge' | 'custom';
  created_at: number;
  chain_id: number;
  gas_limit: number;
  priority?: number;
  dependencies?: string[];
  constraints?: any;
  nonce?: string;
  // Cross-chain fields
  source_chain?: number;
  target_chain?: number;
  bridge_protocol?: string;
  atomic_execution?: boolean;
  rollback_data?: string;
}

export interface SecureIntent {
  intentData: string;
  signature: string;
}

```

## Security Considerations

The security of this framework depends critically on the proper implementation and deployment of several components, each of which introduces specific security considerations that implementers must carefully address.

### Cryptographic Implementation Security

The framework's security guarantees are only as strong as the underlying cryptographic implementations. Implementers MUST use cryptographically secure random number generators for all key generation and nonce creation. The secp256k1 curve implementation MUST be resistant to timing attacks and other side-channel vulnerabilities.

The length-prefixed encoding prevents parsing ambiguities but introduces potential integer overflow vulnerabilities. Implementations MUST validate length prefixes before allocation and ensure buffer bounds checking throughout the parsing process.

### Key Management Security

Private keys MUST be protected according to the specified requirements. For high-value applications, hardware security modules provide the strongest protection against key extraction attacks. Software-based keystores MUST use memory protection techniques to prevent key material from being written to swap files or core dumps.

Key distribution mechanisms MUST prevent man-in-the-middle attacks during public key exchange. On-chain registration provides strong authenticity guarantees but requires careful management of registration permissions and validation logic.

### Cross-Chain Security Considerations

The atomic execution protocol provides consistency guarantees but relies on the security of underlying bridge protocols. Implementers MUST validate that bridge protocols provide adequate fraud-proof mechanisms and finality guarantees before deployment.

Inclusion proofs MUST be verified against finalized block headers to prevent attacks based on chain reorganizations or temporary forks. The timeout mechanism provides liveness guarantees but MUST be set appropriately for the expected latency and finality characteristics of participating chains.

### Smart Contract Security

On-chain implementation introduces additional attack vectors including reentrancy, gas limit manipulation, and front-running attacks. The reference smart contract interface provides security-focused design patterns but requires careful audit and testing before production deployment.

Gas optimization techniques MUST NOT compromise security properties. Batch verification provides efficiency gains but requires careful validation of individual intent authenticity within batches.

### Operational Security

Clock synchronization requirements introduce potential attack vectors if adversaries can manipulate system clocks. Implementers SHOULD use secure time synchronization protocols and monitor for unusual clock skew patterns.

The framework's cryptographic operations consume computational resources that could be targeted in denial-of-service attacks. Rate limiting and resource quotas MAY be necessary to prevent abuse in high-throughput environments.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md)
