# EIP-101: Serenity Currency and Crypto Abstraction

### Specification

1. Accounts now have only two fields in their RLP encoding: code and storage.
2. Ether is no longer stored in account objects directly. Instead, a contract is premine at address 0 to store all ether holdings, and the `eth.getBalance` command in Web3 is now remapped to interact with this contract.
3. The `msg.value` opcode is no longer available in this new model.
4. A transaction now consists of four fields: `to`, `startgas`, `data`, and `code`. The `startgas` field specifies the initial gas allocated for the transaction.
5. Aside from validating the RLP encoding, the following checks are made:
    - The `to` field is 20 bytes long.
    - `startgas` is an integer.
    - `code` is either empty or hashes to the `to` address. Other than these checks, the transaction is valid; however, block gas limits apply.
6. Gas is charged for bytes in `code` at the same rate as data.
7. When a transaction is sent, if the receiving account does not exist, it is created, and its code is set to the code specified in the transaction. If the account already exists, the provided code is ignored.
8. A `tx.gas` opcode is introduced alongside the existing `msg.gas` at index `0x5c`. This allows a transaction to reference the original gas allocation set for it, providing more control over gas usage.

### Default Code for Simple User Accounts

Simple user accounts may have the following default code to implement signature and nonce checking:

```python
# We assume the data schema is as follows:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly nonce)
# bytes 128-159: gas price
# bytes 172-191: to address
# bytes 192+: data

# Get the transaction hash for signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)

# Retrieve the sender address using ECRECOVER
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)
---
eip: 101
title: Serenity Currency and Crypto Abstraction
author: Vitalik Buterin (@vbuterin)
status: Stagnant
type: Standards Track
category: Core
created: 2015-11-15
---

### Specification


1. Accounts now have only two fields in their RLP encoding: code and storage.
2. Ether is no longer stored in account objects directly. Instead, a contract is premine at address 0 to store all ether holdings, and the eth.getBalance command in web3 is now remapped to interact with this contract.
3. The msg.value opcode is no longer available in this new model.
4. A transaction now consists of fo                                                                                                                                                                                                                                                                     Modified





                                   eip: 101
title: Serenity Currency and Crypto Abstraction
author: Vitalik Buterin (@vbuterin)
status: Stagnant
type: Standards Track
category: Core
created: 2015-11-15
---

### Specification

1. Accounts now have only two fields in their RLP encoding: code and storage.
2. Ether is no longer stored in account objects directly. Instead, a contract is premine at address 0 to store all ether holdings, and the `eth.getBalance` command in Web3 is now remapped to interact with this contract.
3. The `msg.value` opcode is no longer available in this new model.
4. A transaction now consists of four fields: `to`, `startgas`, `data`, and `code`. The `startgas` field specifies the initial gas allocated for the transaction.
5. Aside from validating the RLP encoding, the following checks are made:
    - The `to` field is 20 bytes long.
    - `startgas` is an integer.
    - `code` is either empty or hashes to the `to` address. Other than these checks, the transaction is valid; however, block gas limits apply.
6. Gas is charged for bytes in `code` at the same rate as data.
7. When a transaction is sent, if the receiving account does not exist, it is created, and its code is set to the code specified in the transaction. If the account already exists, the provided code is ignored.
8. A `tx.gas` opcode is introduced alongside the existing `msg.gas` at index `0x5c`. This allows a transaction to reference the original gas allocation set for it, providing more control over gas usage.

### Default Code for Simple User Accounts

Simple user accounts may have the following default code to implement signature and nonce checking:

```python
# We assume the data schema is as follows:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly nonce)
# bytes 128-159: gas price
# bytes 172-191: to address
# bytes 192+: data

# Get the transaction hash for signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)

# Retrieve the sender address using ECRECOVER
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)

# Ensure the sender address is correct
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1

# Validate the sequence number (nonce)
assert ~calldataload(96) == self.storage[-1]

# Increment the sequence number
self.storage[-1] += 1

# Execute the actual transaction call with the remaining gas
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)

# Pay the required gas for the transaction
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
g, the following checks are made:
      The to field is 20 bytes long.
      startgas is an integer.
---
eip: 101
title: Serenity Currency and Crypto Abstraction
author: Vitalik Buterin (@vbuterin)
status: Stagnant
type: Standards Track
category: Core
created: 2015-11-15
---

### Specification

1. Accounts now have only two fields in their RLP encoding: code and storage.
2. Ether is no longer stored in account objects directly. Instead, a contract is premine at address 0 to store all ether holdings, and the `eth.getBalance` command in Web3 is now remapped to interact with this contract.
3. The `msg.value` opcode is no longer available in this new model.
4. A transaction now consists of four fields: `to`, `startgas`, `data`, and `code`. The `startgas` field specifies the initial gas allocated for the transaction.
5. Aside from validating the RLP encoding, the following checks are made:
    - The `to` field is 20 bytes long.
    - `startgas` is an integer.
    - `code` is either empty or hashes to the `to` address. Other than these checks, the transaction is valid; however, block gas limits apply.
6. Gas is charged for bytes in `code` at the same rate as data.
7. When a transaction is sent, if the receiving account does not exist, it is created, and its code is set to the code specified in the transaction. If the account already exists, the provided code is ignored.
8. A `tx.gas` opcode is introduced alongside the existing `msg.gas` at index `0x5c`. This allows a transaction to reference the original gas allocation set for it, providing more control over gas usage.

### Default Code for Simple User Accounts

Simple user accounts may have the following default code to implement signature and nonce checking:

```python
# We assume the data schema is as follows:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly nonce)
# bytes 128-159: gas price
# bytes 172-191: to address
# bytes 192+: data

# Get the transaction hash for signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)

# Retrieve the sender address using ECRECOVER
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)

# Ensure the sender address is correct
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1

# Validate the sequence number (nonce)
assert ~calldataload(96) == self.storage[-1]

# Increment the sequence number
self.storage[-1] += 1

# Execute the actual transaction call with the remaining gas
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)

# Pay the required gas for the transaction
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
eip: 101
title: Serenity Currency and Crypto Abstraction
author: Vitalik Buterin (@vbuterin)
status: Stagnant
type: Standards Track
category: Core
created: 2015-11-15
---

### Specification

1. Accounts now have only two fields in their RLP encoding: code and storage.
2. Ether is no longer stored in account objects directly. Instead, a contract is premine at address 0 to store all ether holdings, and the `eth.getBalance` command in Web3 is now remapped to interact with this contract.
3. The `msg.value` opcode is no longer available in this new model.
4. A transaction now consists of four fields: `to`, `startgas`, `data`, and `code`. The `startgas` field specifies the initial gas allocated for the transaction.
5. Aside from validating the RLP encoding, the following checks are made:
    - The `to` field is 20 bytes long.
    - `startgas` is an integer.
    - `code` is either empty or hashes to the `to` address. Other than these checks, the transaction is valid; however, block gas limits apply.
6. Gas is charged for bytes in `code` at the same rate as data.
7. When a transaction is sent, if the receiving account does not exist, it is created, and its code is set to the code specified in the transaction. If the account already exists, the provided code is ignored.
8. A `tx.gas` opcode is introduced alongside the existing `msg.gas` at index `0x5c`. This allows a transaction to reference the original gas allocation set for it, providing more control over gas usage.

### Default Code for Simple User Accounts

Simple user accounts may have the following default code to implement signature and nonce checking:

```python
# We assume the data schema is as follows:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly nonce)
# bytes 128-159: gas price
# bytes 172-191: to address
# bytes 192+: data

# Get the transaction hash for signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)

# Retrieve the sender address using ECRECOVER
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)

# Ensure the sender address is correct
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1

# Validate the sequence number (nonce)
assert ~calldataload(96) == self.storage[-1]

# Increment the sequence number
self.storage[-1] += 1

# Execute the actual transaction call with the remaining gas
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)

# Pay the required gas for the transaction
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
g, the following checks are made:
      The to field is 20 bytes long.
      startgas is an integer.
      code is either empty or hashes to the to address. Other than these checks, the transaction is valid; however, block gas limits apply.
6. Gas is charged for bytes in code at the same rate as data.
7. When a transaction is sent, if the receiving account does not exist, it is created, and its code is set to the code specified in the transaction. If the account already exists, the provided code is ignored.
8. A tx.gas opcode is introduced alongside the existing msg.gas at index 0x5c. This allows a transaction to reference the original gas allocation set for it, providing more control over gas usage.


                             Default Code for Simple User Accounts

    Simple user accounts may have the following default code to implement signature and nonce checking:

python
Copy code
# We assume the data schema is as follows:
# bytes 0-31: v (ECDSA sig)
# bytes 32-63: r (ECDSA sig)
# bytes 64-95: s (ECDSA sig)
# bytes 96-127: sequence number (formerly nonce)
# bytes 128-159: gas price
# bytes 172-191: to address
# bytes 192+: data

# Get the transaction hash for signing
~mstore(0, msg.gas)
~calldatacopy(32, 96, ~calldatasize() - 96)
h = sha3(96, ~calldatasize() - 96)
# Retrieve the sender address using ECRECOVER
~call(5000, 3, [h, ~calldataload(0), ~calldataload(32), ~calldataload(64)], 128, ref(addr), 32)
# Ensure the sender address is correct
assert addr == 0x82a978b3f5962a5b0957d9ee9eef472ee55b42f1
# Validate the sequence number (nonce)
assert ~calldataload(96) == self.storage[-1]
# Increment the sequence number
self.storage[-1] += 1
# Execute the actual transaction call with the remaining gas
~call(msg.gas - 50000, ~calldataload(160), 192, ~calldatasize() - 192, 0, 0)
# Pay the required gas for the transaction
~call(40000, 0, [SEND, block.coinbase, ~calldataload(128) * (tx.gas - msg.gas + 50000)], 96, 0, 0)
This code checks the transaction signature and nonce, then uses the remaining gas (after reserving 50,000 gas) to execute the desired call. It then pays the gas cost.

Miner Algorithm for Transaction Validation
Run the transaction code for a maximum of 50,000 gas, stopping if an operation or call threatens to exceed this limit.
Ensure that the remaining gas is at least 50,000 after any operations, either by checking that the gas consumption is small or by confirming that the call has the correct gas limit (msg.gas - 50000).
Verify that the gas payment logic matches exactly as shown in the code above.
Handling Transactions with Nonzero Value
If a transaction involves a nonzero value:

In the outer scope, the ether contract is called to create a cheque for the desired amount.
In the inner scope, if the contract uses the msg.value opcode, the contract cashes out the cheque at the start of the function call, and the cashed-out value is stored in a standardized address in memory.
Summary of Alterations
Clarification of Transaction Fields: Added explicit explanations for startgas and code fields.
Account Creation Logic: Slightly reworded to clarify that the code is only set when creating a new account.
Minor Adjustment to Code: Made the signature and gas payment logic more straightforward.
