---
eip: 3778
title: Time proof non-fungible token
author: Cyberforker (@CyberFork)
description: Enables NFT to map and anchor things with time features.
discussions-to: https://ethereum-magicians.org/t/a-time-proof-non-fungible-token/
status: Draft
type: Standards Track
category: ERC
created: 2021-09-01
requires: 165, 721
---
## Abstract

Timestamp provable NFTs has been called [time proof non-fungible token] will refer to as [tpNFT] in the subsequent descriptions.

It enables NFT to map and anchor things with time features, and also, the timestamped proof of tpNFT can be the arguments of condition for third-party smart contracts to execute some functions. This standard is extended from [ERC-721](./eip-721.md).

Based on the `tokenURI` parameter of metadata of ERC-721, the plain text parameter `Description` and the encryption parameter `HashedProof` will add, and the timestamped proof of each parameter will automatically update to the 'block.timestamp` of the current moment when one of these three parameters update.

With these improvements, we can provide new possibilities for NFT, enabling NFT to map and capture time-level value.
Here are some brand new applications that can achieve by tpNFT based on this extension.

### Can replace by other solutions but provided the time-proof from tpNFT can as a better starting point for consensus and collection:

- Invention and creation: The idea is stored on the chain to prove that the idea existed before a certain point in time. Moreover, we can temporarily hide the specific technical implementation details through Hash encryption. Open source projects are similar to the previous one used to prove their product's originality and leave proof of their own open-source.

- Scientific discoveries: Publish the publicly available content of relevant scientific discoveries in plain text, and fix some temporarily undisclosed demonstration details through encrypted parameters. Engrave the brilliance of human wisdom on the blockchain. The timestamp proves that it will not lie.

### Use `tokenURI`,`Description`,`HashedProof` and its corresponding `Timestamp-Proof`.
These added properties of tpNFT enable the following use case to operate in a closed-loop on blockchain.

> `Timestamp-Proof` includes `createTimestamp`, `tokenUriUpdateTimestamp`, `descriptionUpdateTimestamp` and `hashedProofUpdateTimestamp`.

`Description`
- Governance: As a timestamped proof of governance voting, it is using to verify the vote's validity and obtain governance incentives. Notably, voting and governance incentive issuance based on the properties of tpNFT is decentralized executed on the blockchain. The incentive contract decides whether to execute incentive issuance by reading the option of tpNFT to vote via plaintext parameters and verifying that its timestamped proof is within limits.

- Prophecy: Similar to the above, replace the voting option with a prophecy option.

`HashedProof`
- On-chain puzzle | Legacy: Binding assets to a tpNFT, others can receive part or all of the assets by submitting the preimage of the encrypted parameter. The preimage is the crypto wills or answers to the puzzle.
  
    *We have another EIP to solve the front-running attacks.

### New functionality through extended `Timestamp-Proof properties`: 
- Dynamic NFT: With tpNFT, we only need a slight improvement, then we can get a brand new type of NFT, which state on the chain will automatically change over time without consuming any gas fees. Such features can open up new areas for games, installation art, financial contracts, and more.


Summarize: From a philosophical point of view, the ERC-721 standard is primarily using for anchoring and mapping things related to space, while tpNFT using for things related to time.

## Motivation
To provide a standard that is updatable and has time-proof parameters.
Compared to other possible solutions for on-chain timestamped proof, such as CallData or ERC-721, they only solve partial problems.
- Write directly in transaction:  
   - Put the calldata in the transaction and through `transaction hash -> block number -> timestamp` to get timestamp is an excellent way to implement timestamp proofs. However, the problem is that any contracts cannot access the timestamped data from the history transaction, can only get the current `block.timestamp`.
   - Tokenless related capabilities: no collection, no structured organization of data, no ownership, and not transferable.  
   - No subsequent modification is possible, which is not reusable and thus will occupy more storage on the chain.
- ERC-721
   - Unupdateable: The parameters cannot be updated. Alternatively, the parameters can be updated, but the credibility for NFT's will reduce. The timestamp of tpNFT proves that we meet the requirements of both update ability and credibility.
   - Lack of timestamp proof: When mint an NFT, directly ignored the time attribute and time value of the mapped object, while tpNFT solved this problem. 
   - Lack of encryption information storage: Based on the above points, we found that it is still unable to solve the problem of encryption Hash storage without leaking essential information. To solve this problem, we added the encryption Hash storage parameter to tpNFT.  
   - Limited on-chain interaction and execution potential: Other contracts on the chain cannot interact directly with the NFT for timestamp + content validation to perform some automated logic, including but not limited to governance, prophecy, legacy processing, and other requirements mentioned in summary. TpNFT's timestamp proof + other three parameters (`tokenURI`, `description`,  `HashedProof`) provides a convenient possibility for the third party contract to directly interact, verify, and execute through the tpNFT contract interface.  
    - The primary difference between the on-chain timestamp and the timestamp stored in the log is that the on-chain timestamp parameters can be accessed directly by other contracts, thus allowing for composability. 
    - The NFT has a time attribute that can make interactions with external accounts or between NFTs produce different results at different times, which provides a logical basis for the time dynamics of NFT.  

Inspired by and based on ERC-721's associated token ownership, we have implemented a tpNFT architecture that combines renewability and timestamp proof and supports the preservation of encrypted content, addressing the problems of other known solutions and giving NFT time attributes. This standard base on and fully follows the ERC-721 series of methods. Additional superset methods based on ERC-721 implementation are as follows:
## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

**Every ERC-tpNFT compliant contract must implement the 'TimeProofNonFungibleToken' and 'ERC165' interfaces** (subject to "caveats" below):

```
pragma solidity ^0.8.0;

/// @title ERC-tpNFT Time proof Non-Fungible Token Standard
/// @dev See <URL>
/// Note: the ERC-165 identifier for this interface is 0x12feabc7.
interface TimeProofNonFungibleToken {
    /// @dev This emits when the tokenURI of tokenId has been updated.
    /// And also the tokenUriUpdateTimestamp MUST been set to the blocktimestamp: block.timestamp.
    event UpdateURI(uint256 indexed tokenId, string tokenURI);
    /// @dev This emits when the description of tokenId has been updated.
    /// And also the descriptionUpdateTimestamp MUST been set to the blocktimestamp: block.timestamp.
    event UpdateDescription(uint256 indexed tokenId, string description);
    /// @dev This emits when the hashProof of tokenId has been updated.
    /// And also the hashedProofUpdateTimestamp MUST been set to the blocktimestamp: block.timestamp.
    event UpdateHashProof(uint256 indexed tokenId, bytes32 hashedProof);

    /**
     * @notice Mint basic tpNFT without description and hashedProof to the caller.
     * During mint, the createTimestamp of tpNFT MUST be updated to the current block timestamp.
     * @dev NFTs assigned to the zero address are considered invalid,
     * and this function throws for queries about the zero address.
     * @param tokenURI the URI set for tpNFT.
     * @return newTokenId The token id of the new tpNFT just mint.
     */
    function mint(string calldata tokenURI)
        external
        returns (uint256 newTokenId);

    /**
     * @notice Mint full tpNFT with tokenURI, description, and hashedProof to the caller.
     * During mint, the createTimestamp of tpNFT MUST be updated to the current block timestamp. If the token URI, description,
     * and hashedProof are not empty or zero, the corresponding tokenUriUpdateTimestamp,
     * descriptionUpdateTimestamp, and hashedProofUpdateTimestamp of the tpNFT MUST update to the current block timestamp.
     * @dev NFTs assigned to the zero address are considered invalid,
     * and this function throws for queries about the zero address.
     * @param tokenURI the URI set for tpNFT.
     * @param description the description set for tpNFT.
     * @param hashedProof the hashedProof set for tpNFT.
     * @return newTokenId The token id of the new tpNFT just mint.
     */
    function mintFullToken(
        string calldata tokenURI,
        string calldata description,
        bytes32 hashedProof
    ) external returns (uint256 newTokenId);

    /**
     * @notice Mint basic tpNFT without description and hashedProof to the address 'to'.
     * During mint, the createTimestamp of tpNFT MUST be updated to the current block timestamp.
     * @dev NFTs assigned to the zero address are considered invalid,
     * and this function throws for queries about the zero address.
     * @param to the address the new tpNFT to receive.
     * @param tokenURI the URI set for tpNFT.
     * @return newTokenId The token id of the new tpNFT just mint.
     */
    function mintTo(address to, string calldata tokenURI)
        external
        returns (uint256 newTokenId);

    /**
     * @notice Mint full tpNFT with tokenURI, description, and hashedProof to the address 'to'.
     * During mint, the createTimestamp of tpNFT MUST be updated to the current block timestamp. If the token URI, description,
     * and hashedProof are not empty or zero, the corresponding tokenUriUpdateTimestamp,
     * descriptionUpdateTimestamp, and hashedProofUpdateTimestamp of the tpNFT MUST update to the current block timestamp.
     * @dev NFTs assigned to the zero address are considered invalid,
     * and this function throws for queries about the zero address.
     * @param to the address the new tpNFT to receive.
     * @param tokenURI the URI set for tpNFT.
     * @param description the description set for tpNFT.
     * @param hashedProof the hashedProof set for tpNFT.
     * @return newTokenId The token id of the new tpNFT just mint.
     */
    function mintFullTokenTo(
        address to,
        string calldata tokenURI,
        string calldata description,
        bytes32 hashedProof
    ) external returns (uint256 newTokenId);

    /**
     * @notice Update the tokenURI of tpNFT. Only owner of tpNFT.
     * @dev This function will be executed only when the length of the newTokenURI string and the updated 
     * tokenURI string is not zero, otherwise it will be skipped directly.
     * When this function executes, the tokenUriUpdateTimestamp of the tpNFT MUST be automatically 
     * updated to the current block timestamp.
     * @param tokenId The tokenId update tokenURI.
     * @param newTokenURI The new tokenURI update.
     */
    function updateURI(uint256 tokenId, string calldata newTokenURI) external;

    /**
     * @notice Update the description of tpNFT. Only owner of tpNFT.
     * When this function executes, the descriptionUpdateTimestamp of the tpNFT MUST be automatic.
     * updated to the current block timestamp.
     * @param tokenId The tokenId update tokenURI.
     * @param newDescription. The value of newDescription should not be zero. Otherwise, it will skip directly.
     */
    function updateDescription(uint256 tokenId, string calldata newDescription)
        external;

    /**
     * @notice Update the hashedProof of tpNFT. Only owner of tpNFT.
     * When this function executes, the hashedProofUpdateTimestamp of the tpNFT MUST be automatically
     * updated to the current block timestamp.
     * @param tokenId The tokenId update tokenURI.
     * @param newHashedProof. The value of newHashedProof should not be bytes32(0). Otherwise, it will skip directly.
     */
    function updateHashProof(uint256 tokenId, bytes32 newHashedProof) external;

    /**
     * @notice Setting a tpNFT as permanent immutable, the operation is irreversible.
     * Only owner of this tpNFT.
     * @dev After a tpNFT set to be immutable,
     * all the update methods mentioned before will become unavailable.
     * @param tokenId The tokenId set permanent immutable.
     */
    function makeTokenImmutable(uint256 tokenId) external;

    /**
     * @notice Query all attributes of a tpNFT.
     * @dev If calling this function through other contracts,
     * can use tuples to handle returns and then execute the other logic as follows.
     * e.g (bool isImmutable,,,,,,bytes32 hashedProof,) = tpNFT.getTokenById(128);
     * @param tokenId The tokenId of tpNFT to queries all attributes.
     * @return isImmutable True if the tpNFT of tokenId is immutable.
     * @return createTimestamp The timestamp of when was tpNFT created, which is immutable.
     * @return tpNFTtokenURI The tpNFTtokenURI of ERC721 metadata can be updated later in tpNFT standard.
     * The purpose of using tpNFTtokenURI instead of tokenURI is to avoid the function name conflict with ERC-721.
     * @return tokenUriUpdateTimestamp It will automatically update when the tpNFTtokenURI is updated.
     * @return description The description of tpNFT.
     * @return descriptionUpdateTimestamp It will automatically update when the description is updated.
     * @return hashedProof The hash-proof of tpNFT.
     * @return hashedProofUpdateTimestamp It will automatically update when the hashedProof is updated.
     */
    function getTokenById(uint256 tokenId)
        external
        view
        returns (
            bool isImmutable,
            uint64 createTimestamp,
            string memory tpNFTtokenURI,
            uint64 tokenUriUpdateTimestamp,
            string memory description,
            uint64 descriptionUpdateTimestamp,
            bytes32 hashedProof,
            uint64 hashedProofUpdateTimestamp
        );

    /**
     * @notice Check whether a certain preimage matches a certain tpNFT hashedProof.
     * @dev Hashedproof can be a hash tree, which can partially verify through external contracts and extension methods.
     * As for the front-running attack on submitted hashes, we have another effective solution.
     * @param tokenId The tokenId of tpNFT that check.
     * @param preimage The preimage of hashedProof.
     * @return isPreimageMatch True if `preimage` is the preimage of hashedProof of the tpNFT of the tokenId.
     */
    function checkHashProof(uint256 tokenId, string calldata preimage)
        external
        view
        returns (bool isPreimageMatch);

    /**
     * @notice An experimental method is used to generate the hash value of the original image. It is RECOMMENDED to use in an offline environment.
     * @dev The preimage may be leaked due to RPC and other reasons when using this method of deploying the contract on the chain.
     * @param preimage The preimage gets the hashedProof.
     * @return hashedProof The hash value of preimage.
     */
    function genHashProof(string calldata preimage)
        external
        pure
        returns (bytes32 hashedProof);
}

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

```
### Caveats
The 0.8.0 Solidity grammar is not expressive enough to document the tpNFT standard. There may be other grammars in the future to make the above functions more complete:
    
- Setting tpNFT to immutable is achieved by restricting three update functions through modifiers. Logically the internal variables of tpNFT can still be updated, such as through some functions that SHOULD NOT implement, or delegatecall() (which is MUST NOT implement) and diamond standards eip-2535 so on.

## Rationale
**Design motivation**

1. Proof of time - Classic NFT is used to anchor and map things related to space, while the tpNFT standard describes time-related things. Unlike classic NFT, time-proof has a natural resistance for copy-paste.
2. Time value - The smaller timestamp, the more time value it has. The first appearance is called innovation, and the second appearance is called imitation. It is precisely because of its earlier appearance that things have a higher value of time proof, and through the tpNFT, we significantly reduce the cost of time proof generation and verification for such things. Because of this, We are pleased to have found a new NFT standard to preserve the value of these precious things.
3. On-chain timestamp state - Enables a range of services and applications that rely on timestamp proof to be automatically deployed and executed through smart contracts directly based on on-chain state, rather than once again relying on off-chain third parties to provide relevant data and proof. With this, we can extend tpNFT as governance NFT, heritage NFT, dynamic NFT so on.
   
**Design decisions**

1. Why based on ERC-721: After several years of development, the NFT of ERC-721 has reached maturity. Extending new features based on a mature standard can help users get started faster and provide good backward compatibility. 
2. Why not use ERC1155 instead of ERC-721: In 1155, there are not only 0 or 1 possible states for the balance of each account, and the relationship between the same ID items(tokens) is not non-fungible, so we do not know who has the authority to update token.

2. Why add two parameters: [Description] and [Hash]
    1. The [Description] is used to store plain text for human-readable and contract to execute. Serves as a data reference for smart contract execution logic, such as the salt that encrypts hash parameters, decryption keys, attributes of in-game characters, and updates of on-chain or off-chain access through formatted data without transferring ownership.  
    2. [Hash] data has two functions: storing encrypted data or storing compressed data, which extends the storage capability of NFT in two directions.  

3. Why include time proof for update tokenURI
    1. Human-readable perspective: Helps quickly determine whether an NFT with the same TokenURI is legitimate or pirated.  
    2. TokenURI updates also apply to time proofs, and we can provide time proofs as parameters to third-party smart contracts to perform specific functions, e.g., providing a point bonus for the first tpNFT that sets tokenURI = 'fo.bar', in which, due to the existence of the timestamp proof, any subsequent forgery of its tokenURI = 'fo. bar' tpNFT cannot make its timestamp proof smaller than the genuine one. Finally, rewards can be issued automatically on the chain based on smart contracts.

4. Gas savings design
    1. The uint64 of four timestamps variables in the struct of TimeProof are arranged consecutively in the struct as one uint256.
    2. The maximum value of Uint64 is 18446744073709551615 (584942417355 years), which is sufficient for saving the timestamp.  
    3. In three update functions, if the value of the calldata and the parameter(URI or description or hashedProof) in the storage of tpNFT are both zero, the update will be skipped to save Gas and meet the needs of mint empty NFT.
   
**ERC-165 Interface**
We chose Standard Interface Detection (ERC-165) to expose the interfaces that a tpNFT smart contract supports.

## Backwards Compatibility
 1. Compatible with ERC165 and the implementation of the relevant interface and registration.
 2. Based on ERC-721 and fully compatible, it is a superset of ERC-721. If only fill in the tokenURI and do not fill in the description and hash in the mint, and then set tpNFT to be constant,  will get a tpNFT that only has more tokenURI update timestamps than the standard NFT with tokenURI.

## Reference Implementation
### TimeProof NFT Implementation
- Anyone can mint a time-proof NFT with [interface TimeProofNonFungibleToken] above.
   - [Ropsten Testnet Network](https://ropsten.etherscan.io/address/0x95abAE18AF14612961F586Cd69e27cbea3A2cA9b) : 0x95abAE18AF14612961F586Cd69e27cbea3A2cA9b
   - [Matic Network (Polygon)](https://polygonscan.com/address/0x30cFc7FC86599d83Be733945D4f9709cD086b802) : 0x30cFc7FC86599d83Be733945D4f9709cD086b802

### Dynamic NFT
A dynamic emoji story NFT: 
 * ðŸ“œThe story is randomized emoji dynamic generated and stored on-chain.
 * Script, text, plot, and other functionality are intentionally omitted for others to interpret.
 * ðŸ†•Each NFT updates the story automatically every 42 hours (default) over time. However, its rarity is not affected.
 * Feel free to use emoji stories hints sheet in any way you want.
 * Website: https://www.storyproject.xyz
 * Contract: https://etherscan.io/address/0x1510b4bc4f6d19b17b00f2d330cdc4b2bc1f470a#code

### Governance voting
## Security Considerations
1. Inherit the security based on the ERC-721 standard.
    1. Related security risks have been resolved by ERC-721 and have been operating stably for many years without security issues.
    2. There may be some security risks: At present, ERC-721 will execute the _checkOnERC721Received function when calling safeTransfer and _mint to call the onERC721Received function of the external contract, which brings the risk of external callback reentry. We can implement specific functions according to the specific function. The execution content adds a modifier to prevent reentry.
2. security for addition tpNFT functional 
    1. Set tpNFT to immutable state (irreversible): The owner of tpNFT can set it to be immutable. After that, the series of update methods of this tpNFT will not be able to call, so that even if the NFT is missing for various reasons, it will not be modified.
    2. When updating the data of tpNFT, it is prohibited to modify the TimeProof struct in the _timeProofs mapping directly, must use the three internal methods _updateURI, _updateDescription, and _updateHashProof provided by the standard to update the data of tpNFT so that the updated content and the updated timestamp are in the same atom transaction and executed correctly.
3. Keccak256 is selected as the function of hash, it is widely used, and its safety has been tested for a long time.
    1. Anti-collision: Can not find two different data with the same Hash value.
    2. Irreversible: Raw raw data cannot be obtained by reverse calculation of Hash value.
    3. Leakage risk: We provide a simple function `genHashProof(string preimage) external pure returns (bytes32 hashedProof)` to pass in the string and generate the hash value. It should be clarified that this function is for reference only. The preimage may be leaked due to RPC and other reasons when using this method of deploying the contract on the chain. Therefore for safety, if the preimage is very important, it is recommended to copy the source code to the local offline or use other SDK to generates hash values â€‹â€‹in a local offline environment.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
