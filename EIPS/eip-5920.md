---
eip: 5920
title: PAY opcode
description: Introduces a new opcode, PAY, to send ether to an address without calling any of its functions
author: Gavin John (@Pandapip1), Zainan Victor Zhou (@xinbenlv), Sam Wilson (@SamWilsn), Jochem Brouwer (@jochem-brouwer), Charles Cooper (@charles-cooper)
discussions-to: https://ethereum-magicians.org/t/eip-5920-pay-opcode/11717
status: Review
type: Standards Track
category: Core
created: 2022-03-14
requires: 2929, 7523
---

## Abstract

This EIP introduces a new opcode, `PAY`, taking two stack parameters, `addr` and `val`, that transfers `val` wei to the address `addr` without calling any of its functions.

## Motivation

Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues:

- First of all, it opens a reentrancy attack vector, as the recipient can call back into the sender. More generally, the recipient can unilaterally execute arbitrary state changes, limited only by the gas forwarded, which is not desirable from the point of view of the sender.
- Secondly, it opens a DoS vector. Contracts which want to send ether must be cognizant of the possibility that the recipient will run out of gas or revert.
- The `EXTCALL` opcode (introduced in [EOF](./eip-7069)) does not provide a way to restrict the amount of gas being forwarded to the recipient, which means sending ether via `EXTCALL` is always subject to the reentrancy attack vector.
- The `CALL` and `EXTCALL` opcodes will execute code on the receipient, which is unintended when wanting to send ether and which could lead to unintentional operations. The code execution also has to be paid for in gas, even when the intention is to only send ether, which is thus an unnecessary waste of gas.
- Finally, [EIP-7702](./eip-7702.md) allows to delegate externally owned accounts (EOAs) to other accounts, which breaks the invariant that EOAs cannot contain code. Therefore, calling such EOA with the intention to send ether will thus also execute code and cost unnecessary gas.

Having a dedicated opcode for ether transfers solves all of these issues, and would be a useful addition to the EVM.

## Specification

### Constants

| Constant                   | Definition                |
| -------------------------- | ------------------------- |
| `WARM_STORAGE_READ_COST`   | [EIP-2929](./eip-2929.md) |
| `COLD_ACCOUNT_ACCESS_COST` | [EIP-2929](./eip-2929.md) |
| `GAS_NEW_ACCOUNT`          | [EELS][gna]               |
| `GAS_CALL_VALUE`           | [EELS][gcv]               |

[gna]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L52
[gcv]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L53

### Behavior

A new opcode is introduced: `PAY` (`0xfc`), which:

- Halt with exceptional failure if the current frame is in `static-mode`.
- Pops two values from the stack: `addr` then `val`.
- Exceptionally halts if `addr` has any of the high 12 bytes set to a non-zero value (i.e. it does not contain a 20-byte address).
- Charges the gas cost detailed below.
- Marks `addr` as warm (adding `addr` to `accessed_addresses`).
- Transfers `val` wei from the current address to the address `addr`, only if the current address has a balance higher than or equal to `val`.
- Push a value to the stack signalling the success or failure of the `PAY` operation:
  - If the operation succeeds, push `0`.
  - If the operation fails, push a nonzero value (defined below, currently only one situation)
    - Note: this is different from the stack item pushed for the `CALL` opcode, which pushes `1` for success and `0` for failure.
    - In case of insufficient balance, push `1`.
    - In the future, the PAY operation could fail for new reasons (such as accounts not directly accepting ether). These situations could be added, with the possibility of using another nonzero value than `1` to signal this fail reason. Therefore, other nonzero stack return values are reserved for different failure reasons. Checking for the `0` stack value for success is thus future-proof, indicating a succesful transfer of ether.

### Gas Cost

The gas cost for `PAY` is the sum of the following:

- Is `addr` in `accessed_addresses`?
    - If yes, `WARM_STORAGE_READ_COST`;
    - Otherwise, `COLD_ACCOUNT_ACCESS_COST`.
- Is `val` non-zero?
  - Charge `GAS_CALL_VALUE`
  - Is `addr` non-existent?
      - Charge `GAS_NEW_ACCOUNT`

`PAY` cannot be implemented on networks with empty accounts (see [EIP-7523](./eip-7523.md)).

## Rationale

### Argument order

The order of arguments mimics that of `CALL`, which pops `addr` before `val`. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, so `PAY` always appears immediately after `COINBASE`.

### Halting for invalid address

The halting behavior is designed to allow for Address Space Extension.
If the high bytes were truncated, as in `CALL`, contracts could depend on the truncating behavior.
If the address space were extended beyond 20 bytes, `PAY` would either not be able to target those accounts, or code expecting truncation could send ether to the wrong address.

Because this behavior may be changed, contracts should not rely on this halting behavior and use methods designated to intentionally halt (such as the [`INVALID`](./eip-141.md) opcode).

## Backwards Compatibility

This change requires a hard fork.

## Security Considerations

Existing contracts should not rely on their balance being under their control, since it is already possible to send ether to an address without calling it, by using the [deprecated `SELFDESTRUCT`](./eip-6780.md) opcode.
It is also possible to involuntarily fund an account using priority fees to fund `block.coinbase`.
However, this opcode does make this process cheaper and easier for already-vulnerable contracts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
