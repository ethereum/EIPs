---
eip: 5920
title: PAY opcode
description: Introduces a new opcode, PAY, to send ether to an address without calling any of its functions
author: Gavin John (@Pandapip1), Zainan Victor Zhou (@xinbenlv), Sam Wilson (@SamWilsn), Jochem Brouwer (@jochem-brouwer), Charles Cooper (@charles-cooper)
discussions-to: https://ethereum-magicians.org/t/eip-5920-pay-opcode/11717
status: Review
type: Standards Track
category: Core
created: 2022-03-14
requires: 2929, 7523
---

## Abstract

This EIP introduces a new opcode, `PAY`, taking two stack parameters, `addr` and `val`, that transfers `val` wei to the address `addr` without calling any of its functions.

## Motivation

Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues:

- First of all, it opens a reentrancy attack vector, as the recipient can call back into the sender. More generally, the recipient can unilaterally execute arbitrary state changes, limited only by the gas stipend, which is not desirable from the point of view of the sender.
- Secondly, it opens a DoS vector. Contracts which want to send ether must be cognizant of the possibility that the recipient will run out of gas or revert.
- The `EXTCALL` opcode (EOF) does not provide a way to restrict gas, which means sending ether via `EXTCALL` is subject to the reentrancy attack vector.
- The `CALL` and `EXTCALL` opcodes will execute code on the receipient, which is unintended when wanting to send ether and which could lead to unintentional operations. The code execution also has to be paid for in gas, when the intention is to only send ether.
- Finally, EIP-7702 allows to delegate externally owned accounts (EOAs) to other accounts, which breaks the invariant that EOAs cannot contain code. Therefore, calling such EOA with the intention to send ether will thus also execute code and cost unnecessary gas.

Having a dedicated opcode for ether transfers solves all of these issues, and would be a useful addition to the EVM.

## Specification

### Constants

| Constant                   | Definition                |
| -------------------------- | ------------------------- |
| `WARM_STORAGE_READ_COST`   | [EIP-2929](./eip-2929.md) |
| `COLD_ACCOUNT_ACCESS_COST` | [EIP-2929](./eip-2929.md) |
| `GAS_NEW_ACCOUNT`          | [EELS][gna]               |
| `GAS_CALL_VALUE`           | [EELS][gcv]               |

[gna]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L52
[gcv]: https://github.com/ethereum/execution-specs/blob/4d953035fb0cceda7cf21d71b2ab7a9a6f4632f0/src/ethereum/frontier/vm/gas.py#L53

### Behavior

A new opcode is introduced: `PAY` (`0xfc`), which:

- Halt with exceptional failure if the current frame is in `static-mode`.
- Pops two values from the stack: `addr` then `val`.
- Exceptionally halts if `addr` has any of the high 12 bytes set to a non-zero value (i.e. it does not contain a 20-byte address).
- Charges the gas cost detailed below.
- Marks `addr` as warm (adding `addr` to `accessed_addresses`).
- Transfers `val` wei from the current address to the address `addr`, only if the current address has a balance higher than or equal to `val`.
- Push a value to the stack signalling the success or failure of the `PAY` operation
  - If the operation succeeds, push `0`
  - If the operation fails, push `1`
  - This is different from normal stack push value of `*CALL*` opcodes, which signals `0` on failure or `1` on success
    - It is choosen here to signal `0` for success, and `1` for failure
      - It is only possible here to push `1` for a balance failure
      - In the future, it could be possible that for other reasons (such as accounts not directly accepting ETH) the PAY operation fails
      - Therefore, nonzero stack return values are reserved for failure reasons. Checking for the `0` stack value for success is thus future-proof.

### Gas Cost

The gas cost for `PAY` is the sum of the following:

- Is `addr` in `accessed_addresses`?
    - If yes, `WARM_STORAGE_READ_COST`;
    - Otherwise, `COLD_ACCOUNT_ACCESS_COST`.
- Is `val` non-zero?
  - Charge `GAS_CALL_VALUE`
  - Is `addr` non-existent?
      - Charge `GAS_NEW_ACCOUNT`

`PAY` cannot be implemented on networks with empty accounts (see [EIP-7523](./eip-7523.md)).

## Rationale

### Argument order

The order of arguments mimics that of `CALL`, which pops `addr` before `val`. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, so `PAY` always appears immediately after `COINBASE`.

### Halting for invalid address

The halting behavior is designed to allow for Address Space Extension.
If the high bytes were truncated, as in `CALL`, contracts could depend on the truncating behavior.
If the address space were extended beyond 20 bytes, `PAY` would either not be able to target those accounts, or code expecting truncation could send ether to the wrong address.

Because this behavior may be changed, contracts should not rely on this halting behavior and use other methods to intentionally halt (like the cheaper `INVALID` opcode).

## Backwards Compatibility

This change requires a hard fork.

## Security Considerations

Existing contracts should not rely on their balance being under their control, since it is already possible to send ether to an address without calling it, by creating a temporary contract and immediately `SELFDESTRUCT`ing it, sending the ether to an arbitrary address.
It is also possible to involuntarily fund an account using priority fees.
However, this opcode does make this process cheaper and easier for already-vulnerable contracts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
