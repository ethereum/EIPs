---
eip: 0000
title: Exempt state from gas limit and cap growth
description: Track state bytes and target 250 MiB/day by dynamically adjusting the state gas cost. Exempt state from the gas limit to facilitate scaling.
author: Anders Elowsson (@anderselowsson), TBD
discussions-to: TODO
status: Draft
type: Standards Track
category: Core
created: 2025-10-02
requires: 1559, 4844, 8037
---

## Abstract

This EIP precisely caps state growth while at the same time roughly doubling the amount of non-state operations possible per block. This is achieved by tracking state creation and attaching a separate state byte limit, exempting state from the current block gas limit. A dedicated EIP-4844 style fee market mechanism ensure precise capping of state growth at a targeted 250 MiB per day. To preserve the existing transaction format and EVM execution patterns, state is still priced in gas during transaction processing, using a similar idea as in EIP-8011. The state gas cost is updated every block, adjusting slowly so that users can set reasonable gas limits. The byte-level harmonization of state creation operations provided by EIP-8037 are applied when setting the state gas price.

## Motivation

Ethereum is currently focused on scaling the layer 1, with a rapid expansion of the block gas limit foreseen in the near-term from compute and memory optimization, as well as via headliner proposals EIP-7732 and EIP-7928. Unfortunately, if the gas cost for state creation is kept fixed, state would likely expand in line with an expanding gas limit. As client database sizes increase, degradation in performance is expected. EIP-8037 addresses state growth by harmonizing current state creation costs according to how many bytes they add to the state. It also increases the gas cost of state creation significantly, by between 3x and 9.5x per operation. 

It can be assumed that increased gas costs will somewhat keep state from expanding in line with the increased gas limit. However, since the price-elasticity of demand for state creation is unknown, it is impossible to say exactly what the effect would be. Users may not be particularly sensitive to the increased state gas costs and still continue to purchase state relative to other resources similar to present usage patterns. This would have two effects:

1. State would continue to expand by a higher rate than desired.
2. Under equilibrium, well over 50% of all consumed gas may be spent on state. This impedes scaling under the current one-dimensional fee market, because state gas crowds out gas that can be used for other resources such as compute.

To confidently target some specific state growth, it is necessary to dynamically vary the price of state creation according to its usage. The EIP-4844 mechanism is particularly suitable. This proposal tracks `state_bytes_used` each block and keep a running counter of `excess_state_bytes`. When `state_bytes_used` exceeds the target, `excess_state_bytes` increases, resulting in an increase to the gas charged per state byte. Users should not need to attach excessive margins to the transaction gas limit without risking transactions failure, and the gas charged per state byte is thus set to vary very moderately between blocks.

To not impede scaling when a higher gas is charged per state byte, it is necessary to exempt state gas from the block gas limit. This is achieved by tracking the `regular_gas_used` and `state_gas_used` separately, counting only `regular_gas_used` against the limit. The maximum state bytes per block is expanded to eight times the target, since the long running `excess_state_bytes` counter still guarantees a precise cap. 

## Specification 

This EIP could easily be combined with EIP-8011, simply by expanding the resource vector and applying the EIP-8011 processing on all other resources than state. Such extensions, as well as the `code_deposit_gas` proposed in EIP-8037 are discussed in the Rationale.

### Parameters

Four constants have a similar role as in EIP-4844.

| Constant | Value 
| - | - |
| `STATE_GAS_UPDATE_FRACTION` | `25_607_189` |
| `TARGET_STATE_BYTES_PER_BLOCK` | `36_400` |
| `MAX_STATE_BYTES_PER_BLOCK` | `8 * TARGET_STATE_BYTES_PER_BLOCK` |
| `MIN_STATE_GAS_PER_BYTE` | `380` |

The bytes assigned to each state operation follow EIP-8037.

| Constant | Value 
| - | - |
| `CREATE_BYTES`            | `112` |
| `CODE_DEPOSIT_BYTES`      |   `1` | 
| `NEW_ACCOUNT_BYTES`       | `112` |
| `STORAGE_SET_BYTES`       |  `32` |
| `PER_EMPTY_ACCOUNT_BYTES` | `112` |
| `PER_AUTH_BASE_BYTES`     |  `23` |

### Header extension

The current header encoding is extended with two new 64-bit unsigned integer fields with similar properties to those created in EIP-4844, but focusing instead on state bytes:

* `state_bytes_used` is the total amount of state bytes created by the transactions within the block.
* `excess_state_bytes` is a running total of state bytes created in excess of the target, prior to the block. Blocks with above-target state bytes creation increase this value, blocks with below-target state bytes creation decrease it (bounded at 0).

The header sequence of the new fields is `[..., TBD, state_bytes_used, excess_state_bytes]`. In an alternative specification, we also rename `gas_used` to `regular_gas_used`.

### Transaction level gas accounting

Gas accounting during transaction execution follows the design in EIP-8011. The EVM stores a 2-dimensional vector accounting for `regular_gas` and `state_gas`, tracking each operation's `regular_cost` and `state_cost`, etc. Just as in EIP-8011, we aggregate gas usage across resources `gas_used = regular_gas + state_gas`, counting them against the transaction's `gas_limit`. We also store a `gas_used_vector` keeping track of gas usage of the two resources in separation. We will refer to the two vector elements as `regular_gas_used` and `state_gas_used`.

### Computing the state gas per byte

The protocol keeps track of `excess_state_bytes`, and computes the `state_gas_per_byte` from that variable (referred to as `cost_per_state_byte` in EIP-8037). The same update mechanism as in EIP-4844 is applied. 

```python
def get_state_gas_per_byte(header: Header) -> int:
    return fake_exponential(
        MIN_STATE_GAS_PER_BYTE,
        header.excess_state_bytes,
        STATE_GAS_UPDATE_FRACTION
    )
```

The `STATE_GAS_UPDATE_FRACTION` is set so that the maximum increase in `state_gas_per_byte` is 1%, when a block consumes `MAX_STATE_BYTES_PER_BLOCK`. The `state_gas_per_byte` has a floor of `MIN_STATE_GAS_PER_BYTE`, corresponding to EIP-8037 when scaled down to a 60M block gas limit. The `excess_state_bytes` are updated just as in EIP-4844:

```python
def calc_excess_state_bytes(parent: Header) -> int:
    if parent.excess_state_bytes + parent.state_bytes_used < TARGET_STATE_BYTES_PER_BLOCK:
        return 0
    else:
        return parent.excess_state_bytes + parent.state_bytes_used - TARGET_STATE_BYTES_PER_BLOCK
```

### Computing state gas costs for the block 

The block level gas cost for each state operation is computed as `GAS_STATE_OPERATION = STATE_OPERATION_BYTES * state_gas_per_byte`. For completeness, the table below specifies this for all operations:

| Constant | Value 
| - | - |
| `GAS_CREATE`             | `state_gas_per_byte * CREATE_BYTES` |
| `GAS_CODE_DEPOSIT`       | `state_gas_per_byte * CODE_DEPOSIT_BYTES` | 
| `GAS_NEW_ACCOUNT`        | `state_gas_per_byte * NEW_ACCOUNT_BYTES` |
| `GAS_STORAGE_SET`        | `state_gas_per_byte * STORAGE_SET_BYTES` |
| `PER_EMPTY_ACCOUNT_COST` | `state_gas_per_byte * PER_EMPTY_ACCOUNT_BYTES` |
| `PER_AUTH_BASE_COST`     | `state_gas_per_byte * PER_AUTH_BASE_BYTES` |

### Block validation

The EIP-1559 gas accounting at the block level only accounts for `regular_gas_used` at `gas_used_vector[0]`. We also keep track of `state_bytes_used` derived from `state_gas_used` at `gas_used_vector[1]`.

```python
def validate_block(block: Block) -> None:
    ...

    # Check that the excess state bytes was updated correctly
    assert block.header.excess_state_bytes == calc_excess_state_bytes(block.parent.header)
    # Compute the per-block state_gas_per_byte from the header
    state_gas_per_byte = get_state_gas_per_byte(block.header)

    state_bytes_used = 0
    for tx in block.transactions:
        ...

        # Transaction execution returns also a gas_used_vector
        gas_used, gas_used_vector = self.execute_transaction(transaction, effective_gas_price)
        # The gas refund stays the same, we charge across both
        gas_refund = transaction.gas_limit - gas_used 
        # Modify the EIP-1559 transaction gas counter to only count regular gas
        cumulative_transaction_gas_used += gas_used_vector[0]
        # Track also of the state gas used in the block
        state_bytes_used += gas_used_vector[1] // state_gas_per_byte
        ...
    
    # Ensure the total state bytes are within the per-block limit
    assert state_bytes_used <= MAX_STATE_BYTES_PER_BLOCK
    # Ensure state_bytes_used matches header
    assert state_bytes_used == block.header.state_bytes_used
    ...

```

## Rationale

TODO

## Backwards Compatibility

TODO

## Security Considerations

TODO

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
