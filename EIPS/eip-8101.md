---
eip: 8101
title: Payload Chunking with Chunk Access Lists
description: Semantic block chunking with separated state diffs for streaming validation and reduced latency
author: Toni Wahrstätter (@nerolation), Milos Stankovic (@morph-dev), Jihoon Song (@jihoonsong), Bharath Vedartham (@bharath-123), Raúl Kripalani (@raulk)
discussions-to: https://ethereum-magicians.org/t/eip-8101-payload-chunking/27085
status: Draft
type: Standards Track
category: Core
created: 2025-12-01
requires: 4844, 4895, 7732, 7825, 7928
---

## Abstract

This EIP introduces Payload Chunking, a protocol upgrade that restructures Ethereum block propagation into self-contained execution chunks with separated Chunk Access Lists (CALs). Proposer propagates beacon and execution block headers, followed by CALs and Chunks. CALs propagate separately and contain state diffs that enable independent chunk execution. Chunks are executed and verified separately (as long as CALs `0..N` are available for chunk `N`). After all chunks execute, the CL validates and finalizes the block. This architecture transforms block validation from a monolithic operation into a streaming pipeline while preserving block atomicity. The concept of chunks is used only during block propagation.

## Motivation

As Ethereum's gas limits increase, block sizes and execution complexity grow correspondingly. The current monolithic block structure requires validators to download the entire block before beginning execution, creating a critical bottleneck in the consensus timeline. This latency becomes increasingly problematic as larger blocks take longer to propagate and decompress before execution can begin.

This proposal addresses these issues by:

- Enabling streaming validation where execution begins as chunks arrive
- Supporting independent chunk execution using CALs containing state diffs
- Bounding resource requirements to per-chunk maximums (`2**24` gas)
- Allowing early rejection of invalid blocks without processing all chunks
- Creating natural boundaries for future proving systems

## Specification

### Constants

```python
CHUNK_GAS_LIMIT = 2**24  # From EIP-7825 (16,777,216 gas per chunk)
MAX_CHUNKS_PER_BLOCK = 2**8  # Maximum chunks in a block (256 chunks)
MAX_TRANSACTIONS_PER_CHUNK = 2**16 # Maximum number of transactions in a chunk (65,536 tx per chunk)
```

### Data Structures

#### Execution Layer Structures

```python
# Chunk header containing execution commitments
class ExecutionChunkHeader(Container):
    index: ChunkIndex                # Position in block (0 to MAX_CHUNKS_PER_BLOCK-1)
    chunk_access_list_hash: Root     # The hash of CAL (keccak-256 of the RLP-encoding)
    pre_chunk_tx_count: uint32       # Number of transactions in a block before the chunk
    pre_chunk_gas_used: uint64       # Gas consumed in block before the chunk
    pre_chunk_blob_gas_used: uint64  # Blob gas consumed in block before the chunk
    txs_root: Root                   # Merkle root of transactions
    gas_used: uint64                 # Gas consumed in chunk
    blob_gas_used: uint64            # Blob gas consumed in chunk
    withdrawals_root: Root           # Merkle root of withdrawals (only in last chunk)

# Self-contained execution chunk
class ExecutionChunk(Container):
    chunk_header: ExecutionChunkHeader
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_CHUNK]
    withdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]  # Only in last chunk
```

#### Chunk Access Lists (CALs)

CALs use the same RLP encoding as Block Access Lists from [EIP-7928](./eip-7928.md) but scoped to individual chunks. They contain state diffs from chunk execution:

```python
# Type aliases matching EIP-7928
Address = bytes  # 20-byte Ethereum address
StorageKey = bytes  # 32-byte storage slot key  
StorageValue = bytes  # 32-byte storage value
Balance = uint256  # Post-execution balance
Nonce = uint64  # Account nonce
CodeData = bytes  # Contract bytecode
TxIndex = uint16  # Transaction index within block

# Storage change: [tx_index, new_value]
StorageChange = [TxIndex, StorageValue]

# Balance change: [tx_index, post_balance]
BalanceChange = [TxIndex, Balance]

# Nonce change: [tx_index, new_nonce]
NonceChange = [TxIndex, Nonce]

# Code change: [tx_index, new_code]
CodeChange = [TxIndex, CodeData]

# All changes to a single storage slot
SlotChanges = [StorageKey, List[StorageChange]]

# All changes for a single account within the chunk
AccountChanges = [
    Address,                    # address
    List[SlotChanges],         # storage_changes
    List[StorageKey],          # storage_reads (read-only)
    List[BalanceChange],       # balance_changes
    List[NonceChange],         # nonce_changes
    List[CodeChange]           # code_changes
]

# Chunk Access List: All account changes in the chunk
ChunkAccessList = List[AccountChanges]
```

CALs are independent and incremental. This means that changes and storage reads from earlier chunks are not included in CALs of later chunks.

The first CAL contains pre-execution entries (e.g. [EIP-2935](./eip-2935.md) and [EIP-4788](./eip-4788.md)) and the last CAL contains post-execution access list (e.g. [EIP-4895](./eip-4895.md), [EIP-7002](./eip-7002.md) and [EIP-7251](./eip-7251.md)).

#### Network Sidecars

Chunks and CALs propagate as separate sidecars. They can arrive in any order independent of the beacon block.

```python
# Chunk propagated as sidecar
class ExecutionChunkSidecar(Container):
    root: Root                          # The beacon block root this chunk belongs to
    chunk: ExecutionChunk               # The chunk
    chunk_signature: BLSSignature       # The builder's signature

# CAL propagated as separate sidecar
class ChunkAccessListSidecar(Container):
    root: Root                          # The beacon block root this chunk belongs to
    chunk_index: ChunkIndex             # The index of the chunk in the block
    chunk_access_list: ChunkAccessList  # The chunk access list
    cal_signature: BLSSignature         # The builder's signature
```

### Chunk Construction Rules

Block producers MUST follow these rules when creating chunks:

1. **Gas Limits**: Each chunk MUST NOT exceed `CHUNK_GAS_LIMIT` (16,777,216 gas)
2. **Invalid Merge**: The combined gas used by two consecutive chunks MUST exceed `CHUNK_GAS_LIMIT` (it should be impossible to simply merge two consecutive chunks and make a single valid chunk)
3. **Transaction Integrity**: Transactions MUST NOT be split across chunks
4. **Withdrawal Placement**: Withdrawals MUST only appear in the final chunk
5. **Maximum Chunks**: A block MUST contain at most `MAX_CHUNKS_PER_BLOCK` chunks
6. **Ordering**: Chunks MUST be numbered sequentially from 0 to N-1

### Network Protocol

#### Chunk Propagation

Chunks and CALs are identified by beacon block root and chunk index. They propagate on separate subnets.

- **Chunks**: Published on `execution_chunk_sidecar` subnet
- **CALs**: Published on `chunk_access_list_sidecar` subnet

Nodes MUST subscribe to both subnets to ensure full block availability. Chunks and CALs received before the beacon block are stored as "orphans" and validated when the matching block arrives.

### Consensus Layer Changes

The consensus layer orchestrates chunk execution as beacon block, chunks and CALs become available.

#### Store Extensions

```python
class Store:
    # ... existing fields ...

    # Tracks whether CALs were received
    chunk_access_lists: Dict[Root, Set[ChunkIndex]]
    # Tracks chunk headers 
    chunk_headers: Dict[Root, Dict[ChunkIndex, ExecutionChunkHeader]]
    # Tracks chunk's execution status
    chunk_execution_statuses: Dict[Root, Dict[ChunkIndex, ExecutionStatus]]
    # Tracks block validation
    block_valid: Dict[Root, bool]
```

#### Three-Phase Validation

##### Phase 1: Forward CALs to EL client

Since CALs are required for validating all subsequent chunks, we forward them to the EL client as soon as they arrive. This avoids sending the same CAL multiple times between CL and EL.

```python
def on_chunk_access_list_received(store, cal_sidecar):
    root = cal_sidecar.root
    chunk_index = cal_sidecar.chunk_index

    # Get or wait for beacon block
    block = wait_beacon_block(store, root)
    # Verify sidecar
    assert verify_chunk_access_list_sidecar(block, cal_sidecar)

    # Send CAL to EL client
    execution_engine.new_chunk_access_list(block, chunk_index, cal_sidecar.chunk_access_list)

    # Track that CAL was received and unblock any ongoing validation
    store.chunk_access_lists[root].add(chunk_index)
    notify_cal_available(root, chunk_index) # unblock wait_cal function
```

##### Phase 2: Streaming Chunk Validation

Chunks are validated as soon as they and all required CALs are available. 

```python
def on_chunk_received(store, chunk_sidecar):
    root = chunk_sidecar.root
    chunk = chunk_sidecar.chunk
    chunk_header = chunk.chunk_header

    # Get or wait for beacon block
    block = wait_beacon_block(store, root)
    # Verify sidecar
    assert verify_chunk_sidecar(block, chunk_sidecar)

    # Store chunk header
    store.chunk_headers[root][chunk_header.index] = chunk_header

    # Wait prior and chunk's CALs
    for chunk_index in range(chunk_header.index + 1):
        wait_cal(root, chunk_index)

    # Validate chunk
    execution_status = execution_engine.validate_chunk(block, chunk) # EL should have all CALs available
    store.chunk_execution_statuses[root][chunk_header.index] = execution_status

    # Finalize block if all chunks have been validated
    maybe_finalize_block(store, root)
```

##### Phase 3: Block finalization

If all chunk and CALs have been received and validated, we can finalize the block.

```python
def maybe_finalize_block(store, root):
    if root in store.execution_block_valid:
        # Block was already finalized
        return
    
    block = get_beacon_block(store, root)

    chunk_headers = store.chunk_headers[root]
    chunk_statuses = store.chunk_execution_statuses[root]

    chunk_count = len(chunk_statuses)
    total_gas_used = 0

    # Verify that all chunks are valid
    for chunk_index in range(chunk_count):
        if chunk_index not in chunk_statuses:
            # The chunk with chunk_index was not validated
            return

        # Check execution validity
        if not chunk_statuses[chunk_index].valid:
            # Chunk is invalid => block is invalid
            store.block_valid[root] = False
            return
        
        total_gas_used += chunk_headers[chunk_index].gas_used

    if total_gas_used < block.execution_payload.gas_used:
        # Not all chunks were validated
        return

    # Verify that all chunks are chained correctly, and that together they
    # create expected execution block header.
    # EL already has all chunks and CALs
    store.block_valid[root] = execution_engine.finalize_block(block)
```

#### Attestation Rules

Validators MUST NOT attest to a block until:

1. All chunks have been individually validated (Phase 2)
2. The complete state transition has been verified (Phase 3)

In the context of EIP-7732 (ePBS), the PTC (Payload Timeliness Committee) validator should attest whether all chunks and CALs are available, independent of successful validation.

### Execution Changes

#### Chunk Validation

The execution layer processes chunks independently, where each chunk applies all prior CALs to the parent state:

```python
def el_validate_chunk(header, chunk, cal, prior_cals):
    """EL executes chunk using CALs 0..N-1 applied to parent state"""
    chunk_index = chunk.chunk_header.index
    
    # Validate CAL availability
    if len(prior_cals) != chunk_index:
        # Missing required CALs
        return ChunkExecutionResult(
            status="INSUFFICIENT_INFORMATION",
            chunk_index=chunk_index,
            error=f"Missing prior cals, expected: {chunk_index} received: {len(prior_cals)}"
        )

    # Get parent block state
    parent_state = get_block_state(header.parent_hash)
    if not parent_state:
        return ChunkExecutionResult(
            status="SYNCING",
            chunk_index=chunk_index,
        )
    
    # Apply all prior CALs (0 .. N-1) to parent state
    pre_state = parent_state
    for i in range(chunk_index):
        pre_state = apply_state_diffs(pre_state, prior_cals[i])
    
    # Execute and verify chunk
    execution_result = execute_chunk(header, pre_state, chunk, cal)

    if execution_result.error:
        return ChunkExecutionResult(
            status="INVALID",
            chunk_index=chunk_index,
            error=execution_result.error,
        )
    
    return ChunkExecutionResult(
        status="VALID",
        chunk_index=chunk_index,
    )
```

### Engine API

#### New Methods

The consensus layer drives chunk execution by sending CALs and chunks to the execution layer. The EL processes chunks as they arrive with sufficient prerequisites.

```python
# CL sends CAL to EL that stores them for future chunk verification
engine_newChunkAccessList(
    header: ExecutionBlockHeader,
    chunk_index: ChunkIndex,
    cal: ChunkAccessList,
) -> ChunkAccessListStatusV1

# CL sends chunk to EL for execution and verification
# Should be called if all required CALs were already sent using engine_newChunkAccessList,
# otherwise it returns "INSUFFICIENT_INFORMATION" error.
engine_executeChunk(
    header: ExecutionBlockHeader,
    chunk: ExecutionChunk,
) -> ChunkExecutionStatusV1

# Finalize and verify block after all chunks have been executed
engine_finalizeBlock(
    block_hash: Hash32,
) -> PayloadFinalizeStatusV1
```

#### Response Types

```python
class ChunkAccessListStatusV1(Container):
    status: str  # "ACCEPTED", "INVALID", "SYNCING"
    chunk_index: ChunkIndex
    error: Optional[str]  # Error details if INVALID

class ChunkExecutionStatusV1(Container):
    status: str  # "VALID", "INVALID", "INSUFFICIENT_INFORMATION", "SYNCING"
    chunk_index: ChunkIndex
    error: Optional[str]  # Error details if INVALID

class PayloadFinalizeStatusV1(Container):
    status: str  # "VALID", "INVALID", "SYNCING"
    error: Optional[str]
```

## Rationale

### Why incremental CALs

The incremental CALs approach where chunk N applies CALs 0..N-1 to parent state provides:

1. **Parallel Execution**: Multiple chunks can execute simultaneously once their CALs are available
    - This could be achieved without incremental approach, but CALs would need to contain relevant state diffs from previous chunks. This would lead to very big chunks in the worst case scenario.
2. **Early Validation**: Invalid blocks can be rejected at the first invalid chunk
3. **Bounded Resources**: Each chunk independently bounded to `CHUNK_GAS_LIMIT`

### Why CL-Driven Architecture?

The consensus layer drives the execution layer for several key reasons:

1. **Current design**: Most CL-EL interaction is currently CL driven
2. **CAL Dependency Management**: The CL has the global view of which CALs have been received from the network and can orchestrate chunk execution in the optimal order based on availability
3. **Natural Ordering**: The CL naturally enforces that chunks are executed only when their dependencies are met
4. **Timing**: The CL knows whether chunks arrived timely

### Why Separate CALs from Chunks?

Separating Chunk Access Lists (containing state diffs) from chunks provides several benefits:

1. **Independent Propagation**: CALs are typically much smaller than chunks (containing only state diffs) and propagate faster
2. **Parallel Execution**: Multiple chunks can execute independently by applying prior CALs to reconstruct required pre-states
3. **Modularity**: State diffs are logically separate from transaction data
4. **Future Compatibility**: CALs can be extended with additional metadata without modifying chunk structure
5. **Streaming Validation**: Validators can begin executing chunks as soon as required CALs arrive

### Why Semantic Chunking Over Simple Fragmentation?

Unlike simple byte-level fragmentation, semantic chunking:

1. **Enables Streaming Validation**: Chunks are self-contained execution units that can be validated as they arrive
2. **Bounds Resources**: Each chunk has maximum gas limits, bounding memory and CPU usage

### Choice of Parameters

- **`CHUNK_GAS_LIMIT = 2**24`** (16.7M gas): Balances parallelization benefits with chunk overhead. Large enough for complex transactions, small enough for bounded proving
- **`MAX_CHUNKS_PER_BLOCK = 256`**: Supports up to 2 Ggas blocks (assuming each chunk is half full)
- **`MAX_TRANSACTIONS_PER_CHUNK = 2**16`** (65,536): Chosen as a power of two that is enough when chunk is full of the cheapest transactions (ETH transfer), even if they become even cheaper in the future

## Backwards Compatibility

This EIP introduces breaking changes to:

1. **Block Propagation**: Replaces monolithic execution payload propagation with chunked propagation
2. **Network Protocol**: Adds new gossip topics for chunks and CALs
3. **Engine API**: Requires new validation methods
4. **Fork Choice**: Adds three-phase validation logic

These changes require a coordinated hard fork.

## Security Considerations

### Data Availability

Chunk separation creates new data availability requirements:

1. **Withholding Attacks**: Proposers/Builders could withhold specific chunks or CALs to make blocks unvalidatable
   - **Mitigation**: Attestation rules require full chunk availability before voting
   - **Detection**: Missing chunks are easily identified by commitment mismatches

2. **Partial Withholding**: Withholding CALs (state diffs) while publishing chunks
   - **Impact**: Delays streaming execution but doesn't prevent sequential validation
   - **Mitigation**: CALs can be reconstructed by executing chunks sequentially to capture state diffs

3. **Backward Propagation**: Proposers/Builders could send chunks and CALs in the reverse order
   - **Impact**: No chunks can be executed until the first chunk or CAL arrives
   - **Mitigation**: Attestation rules requires chunks and CALs to be propagated or validated in a timely manner

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
