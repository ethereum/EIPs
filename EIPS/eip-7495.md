---
eip: 7495
title: SSZ ProgressiveContainer
description: SSZ type for forward-compatible containers
author: Etan Kissling (@etan-status), Cayman (@wemeetagain)
discussions-to: https://ethereum-magicians.org/t/eip-7495-ssz-progressivecontainer/15476
status: Draft
type: Standards Track
category: Core
created: 2023-08-18
requires: 7916
---

## Abstract

This EIP introduces a new [Simple Serialize (SSZ)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md) type to represent containers with forward-compatible Merkleization: A given field is always assigned the same stable [generalized index (gindex)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/merkle-proofs.md#generalized-merkle-tree-index) even when different container versions append new fields or drop existing fields.

## Motivation

SSZ containers are frequently versioned, for example across fork boundaries. When the number of fields reaches a new power of two, or a field is removed or replaced with one of a different type, the shape of the underlying Merkle tree changes, breaking verifiers of Merkle proofs for these containers. Deploying a new verifier may involve security councils to upgrade smart contract logic, or require firmware updates for embedded devices. This effort is needed even when no semantic changes apply to the fields that the verifier is interested in.

Further, if multiple versions of an SSZ container coexist at the same time, for example to represent transaction profiles, the same field may be assigned to a different gindex in each version. This unnecessarily complicates verifiers and introduces a maintenance burden, as the verifier has to be kept up to date with version specific field to gindex map.

Progressive containers address these shortcomings by:

- Using the [progressive Merkle tree](./eip-7916.md) structure to progressively grow to the actual field count with minimal overhead, ensuring provers remain valid as the field count changes.
- Assigning stable gindices for each field across all versions by allowing gaps in the Merkle tree where a field is absent.
- Serializing in a compact form where absent fields do not consume space.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### `ProgressiveContainer(active_fields)`

Two new [SSZ composite types)](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types) are defined:

- **progressive container**: ordered heterogeneous collection of values with stable Merkleization
  - python dataclass notation with key-type pairs, e.g.

  ```python
  class Square(ProgressiveContainer(active_fields=[1, 0, 1])):
      side: uint16  # Merkleized at field index #0 (location of first 1 in `active_fields`)
      color: uint8  # Merkleized at field index #2 (location of second 1 in `active_fields`)

  class Circle(ProgressiveContainer(active_fields=[0, 1, 1])):
      radius: uint16  # Merkleized at field index #1 (location of first 1 in `active_fields`)
      color: uint8  # Merkleized at field index #2 (location of second 1 in `active_fields`)
  ```

- **compatible union**: union type containing one of the given subtypes with compatible Merkleization
  - notation `CompatibleUnion[type_1, type_2, ...]`, e.g. `CompatibleUnion[Square, Circle]`

Compatible unions are always considered ["variable-size"](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#variable-size-and-fixed-size), even when all type options share the same fixed length.

The [default value](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#default-values) is defined as:

| Type                                   | Default Value                                              |
| -------------------------------------- | ---------------------------------------------------------- |
| `ProgressiveContainer(active_fields)`  | `[default(type) for type in progressive_container]`        |
| `CompatibleUnion[type_1, type_2, ...]` | n/a (error)                                                |

The following types are considered [illegal](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#illegal-types):

- `ProgressiveContainer` with no fields are illegal.
- `ProgressiveContainer` with an `active_fields` configuration of more than 256 entries are illegal.
- `ProgressiveContainer` with an `active_fields` configuration ending in `0` are illegal.
- `ProgressiveContainer` with an `active_fields` configuration with a different count of `1` than fields are illegal.
- `CompatibleUnion[]` without any type options are illegal.
- `CompatibleUnion[type_1, type_2, ...]` with more than 127 type options are illegal.
- `CompatibleUnion[type_1, type_2, ...]` with a type option that has incompatible Merkleization with another type option are illegal.
- `CompatibleUnion[type_1, type_2, ...]` with a type option that shares the same Merkle tree shape as another type option are illegal.

#### Compatible Merkleization

- Types are compatible with themselves.
- `byte` is compatible with `uint8` and vice versa.
- `Bitlist[N]` are compatible if they share the same capacity `N`.
- `Bitvector[N]` are compatible if they share the same capacity `N`.
- `List[type, N]` are compatible if `type` is compatible and they share the same capacity `N`.
- `Vector[type, N]` are compatible if `type` is compatible and they share the same capacity `N`.
- `ProgressiveList[type]` are compatible if `type` is compatible.
- `Container` are compatible if they share the same field names in the same order, and all field types are compatible.
- `ProgressiveContainer(active_fields)` are compatible if all `1` entries in both type's `active_fields` correspond to fields with shared names and compatible types, and no other field name is shared across both types.
- `CompatibleUnion[type_1, type_2, ...]` and any of the type options `type_1`, `type_2`, ... are compatible and vice versa.
- `CompatibleUnion` are compatible with each other if all type options across both `CompatibleUnion` are compatible.
- All other types are incompatible.

#### Serialization

Serialization of `ProgressiveContainer(active_fields)` are identical to [`Container`](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#vectors-containers-lists).

A `value` as `CompatibleUnion[T...]` type has properties `value.data` with the contained value, and `value.selector` which indexes the selected `CompatibleUnion` type option `T`. The selector index is based at 1.

```python
return value.selector.to_bytes(1, "little") + serialize(value.data)
```

#### Deserialization

Deserialization of `ProgressiveContainer(active_fields)` is identical to [`Container`](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#deserialization).

For `CompatibleUnion`, the deserialization logic is updated:

- In the case of compatible unions, the first byte of the deserialization scope is deserialized as type selector, the remainder of the scope is deserialized as the selected type.

The following invalid input needs to be hardened against:

- An out-of-bounds type selector in a `CompatibleUnion`

#### JSON mapping

The canonical [JSON mapping](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#json-mapping) is updated:

| SSZ                                    | JSON            | Example                                  |
| -------------------------------------- | --------------- | ---------------------------------------- |
| `ProgressiveContainer(active_fields)`  | object          | `{ "field": ... }`                       |
| `CompatibleUnion[type_1, type_2, ...]` | selector-object | `{ "selector": number, "data": type_N }` |

`CompatibleUnion` is encoded as an object with a `selector` and `data` field, where the contents of `data` change according to the selector.

#### Merkleization

The [SSZ Merkleization specification](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#merkleization) is extended with two helper functions:

- `get_active_fields`: Given a `value` of type `ProgressiveContainer(active_fields)` return `value.__class__.active_fields`.
- `mix_in_active_fields`: Given a Merkle root `root` and an `active_fields` configuration return `hash(root, pack_bits(active_fields))`. Note that `active_fields` is restricted to â‰¤ 256 bits.

The Merkleization definitions are extended.

- `mix_in_active_fields(merkleize_progressive([hash_tree_root(element) for element in value]), get_active_fields(value))` if `value` is a progressive container.
- `hash_tree_root(value.data)` if `value` is of compatible union type. Note that the selector is only used for serialization, it is not mixed in when Merkleizing.

## Rationale

### Why `active_fields`?

The `active_fields` commits to the specific tree shape and allows verifiers (e.g., based on [EIP-4788](./eip-4788.md)) to distinguish a removed field from a `0` value.

### Why is `active_fields` limited to 256 bits?

256 bits (1 word) allows the mix-in to be simple, consistent with the length mix-in for lists, and is practically sufficient. An alternate design with a `ProgressiveBitlist` mix-in was explored, however deemed too over-engineered as it it would effectively require introducing caches to pre-compute the mix-in's `hash_tree_root` to avoid repeated computations, and also makes verifier logic more complex than necessary.

Even though the 256 field limit includes all fields (including deprecated ones), it is unlikely that many progressive containers come close to reach 256 fields (`BeaconState` currently reaches around 40 fields). If that happens, one can add a `more` field with a nested `ProgressiveContainer`.

### Why is empty `ProgressiveContainer` an illegal type?

It would result in 0-length serialization, meaning that the length of a list of such a container cannot be determined from the serialization.

### Why `CompatibleUnion`?

Certain types, e.g., transactions, allow multiple variants carving out slightly different feature sets. Merkleization equivalence is still desirable, as it allows verifiers to check common fields across variants. These types should still efficiently deserialize into one of their possible variants corresponding to its known tree shape. In programming languages, this is typically achieved by tagged unions.

An alternative design was explored where the `active_fields` bitvector was emitted. While that works in principle, it becomes very inefficient to parse when `ProgressiveContainer` are nested, as the parser cannot immediately determine the overall tree shape. Further, the bitvector makes every single nesting layer variable-length, adding a lot of overhead to the serialized format.

With `CompatibleUnion`, a tag is emitted that tells the parser early on what to expect, including for nested fields. Note that `CompatibleUnion` is solely a serialization helper, it has no impact on the Merkle tree. This ensures that verifiers (e.g., based on [EIP-4788](./eip-4788.md)) do not break when a future fork wraps a field in a `CompatibleUnion`, or when a type option get dropped or re-ordered.

For APIs that transfer `CompatibleUnion`, it is essential to also transmit the associated fork, e.g., via `Eth-Consensus-Version` in beacon APIs.

### `Optional[type]`?

Introducing `Optional` is not required by any current functionality and is deferred to a future EIP.

The `active_fields` bitvector can be updated to also indicate optionality. Further, serialization for sparse lists should be explored.

## Backwards Compatibility

`ProgressiveContainer(active_fields)` is a new SSZ type and does not conflict with existing types.

`CompatibleUnion[type_1, type_2, ...]` is an alternative to an [earlier union proposal](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/ssz/simple-serialize.md#composite-types). However, it has only been used in [deprecated specifications](https://github.com/ethereum/consensus-specs/blob/ad36024441cf910d428d03f87f331fbbd2b3e5f1/specs/_deprecated/sharding/beacon-chain.md). Portal network also uses a union concept for network types, but does not use `hash_tree_root` on them, and could transition to the new compatible union proposal with a new networking version.

## Test Cases

- `ethereum/remerkleable` contains static tests in `test_impl.py` and `test_typing.py`.
- `ethereum/consensus-spec-tests` contains random tests in `tests/general/phase0/ssz_generic`, generated according to a format defined in `ethereum/consensus-specs` (`tests/format/ssz_generic`)

## Reference Implementation

See `ethereum/remerkleable`.

## Security Considerations

As the `CompatibleUnion` type selector is not committed to in the Merkle tree, if any two type options describe the same Merkle tree shape, objects that differ solely in the type selector may share the same `hash_tree_root`, and an attacker may swap out the type selector without invalidating signatures. While such a `CompatibleUnion` is an illegal type, additional static analyzer tooling should be implemented to enforce type rules.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
