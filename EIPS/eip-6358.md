---
eip: 6358
title: Omniverse Token Protocol
description: The Omniverse Token Protocol defines a new tokens protocol (both FT/NFT) whose states are synchronized over multiple existing public chains
author: Shawn Zheng (@xiyu1984), Jason Cheng <chengjingxx@gmail.com>, George Huang (@virgil2019), Kay Lin (@kay404)
discussions-to: https://ethereum-magicians.org/t/add-eip-6358-omniverse-distributed-ledger-technology/12625
status: Draft
type: Standards Track
category: ERC
created: 2023-01-17
---

## Abstract

This ERC standardizes an interface for contract-layer consensus-agnostic verifiable cross-chain bridging.

![img](../assets/eip-6358/img/o-dlt.png)

O-DLT could be considered as a decentralized global ledger established upon two parts:

- **Abstract Nodes** are smart contracts or similar mechanisms running at the application level over existing blockchains. The states recorded by the **Abstract Nodes** that are deployed on different blockchains respectively could be considered as copies of the global state, and they are ultimately consistent. 
- **Synchronizer** is an off-chain procedure responsible for synchronizing published omniverse transactions from the O-DLT smart contracts on one blockchain to the O-DLT smart contracts of the others.

## Motivation

For projects serving multiple chains, it might be useful that the token is able to be accessed anywhere. Although assets-bridges can more or less make it, we don't think it is enough. And in the process of R&D, we found that the fragmentation of tokens is a common and disturbing problem among chains and L2s. 

- We want our token to be treated as a whole instead of being divided into fragmented parts on different public chains. O-DLT can get it.
- When one chain breaks down, we don't want to lose our assets along with it. Assets-bridge paradigm cannot provide a guarantee for this. O-DLT can provide this guarantee even if there's only one chain that works, for example, we can rely on the stability and robustness of Ethereum.  
- Not just for a certain token, we think the Omniverse Token might be useful for other projects on Ethereum and other chains. O-DLT is actually a new kind of open-source asset paradigm at the application level. 


## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

*The word `Omniverse` in definitions will be substituted with the assigned number.*

### Omniverse Account

The Omniverse account is RECOMMENDED to be expressed as a public key created by the elliptic curve `secp256k1`, which has already been supported by Ethereum tech stacks and can be used to generate an Ethereum address directly. For those who have a different address system, a mapping mechanism is RECOMMENDED.  

### Data Structure

The definations of omniverse transaction data MUST be defined as follows:  

```solidity
/**
 * @notice Omniverse transaction data structure
 * @member nonce: The number of the o-transactions. If the current nonce of an omniverse account is `k`, the valid nonce of this o-account in the next o-transaction is `k+1`. 
 * @member chainId: The chain where the o-transaction is initiated
 * @member initiateSC: The contract address from which the o-transaction is first initiated
 * @member from: The Omniverse account which signs the o-transaction
 * @member payload: The encoded bussiness logic data, which is maintained by the developer
 * @member signature: The signature of the above informations. 
 */
struct ERC6358TransactionData {
    uint128 nonce;
    uint32 chainId;
    bytes initiateSC;
    bytes from;
    bytes payload;
    bytes signature;
}
```

- The data structure `ERC6358TransactionData` MUST be defined as above.
- The member `nonce` MUST be defined as `uint128` due to better compatibility for more tech stacks of blockchains.
- The member `chainId` MUST be defined as `uint32`.
- The member `initiateSC` MUST be defined as `bytes`.
- The member `from` MUST be defined as `bytes`.
- The member `payload` MUST be defined as `bytes`. It is encoded from a user-defined data related to the o-transaction. For example:  
    - For fungible tokens it is RECOMMENDED as follows:  

        ```solidity
        /**
        * @notice Fungible token data structure, from which the field `payload` in `ERC6358TransactionData` will be encoded
        *
        * @member op: The operation type
        * NOTE op: 0-31 are reserved values, 32-255 are custom values
        *           op: 0 - omniverse account `from` transfers `amount` tokens to omniverse account `exData`, `from` have at least `amount` tokens
        *           op: 1 - omniverse account `from` mints `amount` tokens to omniverse account `exData`
        *           op: 2 - omniverse account `from` burns `amount` tokens from his own, `from` have at least `amount` tokens
        * @member exData: The operation data. This sector could be empty and is determined by `op`. For example: 
                    when `op` is 0 and 1, `exData` stores the omniverse account that receives.
                    when `op` is 2, `exData` is empty.
        * @member amount: The amount of tokens being operated
        */
        struct Fungible {
            uint8 op;
            bytes exData;
            uint256 amount;
        }
        ```

        - The related raw data for `signature` in o-transaction is the concatenation of the raw bytes of `op`, `exData`, and `amount`.  
    - For non-fungible tokens it is RECOMMENDED as follows:  

        ```solidity
        /**
        * @notice Non-Fungible token data structure, from which the field `payload` in `ERC6358TransactionData` will be encoded
        *
        * @member op: The operation type
        * NOTE op: 0-31 are reserved values, 32-255 are custom values
        *           op: 0 omniverse account `from` transfers token `tokenId` to omniverse account `exData`, `from` have the token with `tokenId`
        *           op: 1 omniverse account `from` mints token `tokenId` to omniverse account `exData`
        *           op: 2 omniverse account `from` burns token `tokenId`, `from` have the token with `tokenId`
        * @member exData: The operation data. This sector could be empty and is determined by `op`
        *           when `op` is 0 and 1, `exData` stores the omniverse account that receives.
                    when `op` is 2, `exData` is empty.
        * @member tokenId: The tokenId of the non-fungible token being operated
        */
        struct NonFungible {
            uint8 op;
            bytes exData;
            uint256 tokenId;
        }
        ```

        - The related raw data for `signature` in o-transaction is the concatenation of the raw bytes of `op`, `exData`, and `tokenId`. 
- The member `signature` MUST be defined as `bytes`. It is RECOMMENDED to be created as follows, which could be determined by certain omniverse token developers according to their situations:  
    - Concat the sectors in `ERC6358TransactionData` as below (take Fungible token for example) and calculate the hash with `keccak256`: 

        ```solidity
        /**
        * @notice Decode `_data` from bytes to Fungible
        * @return A `Fungible` instance
        */
        function decodeData(bytes memory _data) internal pure returns (Fungible memory) {
            (uint8 op, bytes memory exData, uint256 amount) = abi.decode(_data, (uint8, bytes, uint256));
            return Fungible(op, exData, amount);
        }
        
        /**
        * @notice Get the hash of a transaction
        * @return Hash value of the raw data of an `ERC6358TransactionData` instance
        */
        function getTransactionHash(ERC6358TransactionData memory _data) public pure returns (bytes32) {
            Fungible memory fungible = decodeData(_data.payload);
            bytes memory payload = abi.encodePacked(fungible.op, fungible.exData, fungible.amount);
            bytes memory rawData = abi.encodePacked(_data.nonce, _data.chainId, _data.initiateSC, _data.from, payload);
            return keccak256(rawData);
        }
        ```

    - The signature is about the hash value.

### Smart Contract Interface

- Every ERC-Omniverse Token MUST implement the `IERC6358`  

    ```solidity
    /**
    * @notice Interface of the ERC Omniverse-DLT
    */
    interface IERC6358 {
        /**
        * @notice Emitted when a o-transaction which has nonce `nonce` and was signed by user `pk` is sent by calling {sendOmniverseTransaction}
        */
        event TransactionSent(bytes pk, uint256 nonce);

        /**
        * @notice Sends an omniverse transaction 
        * @dev 
        * Note: MUST implement the validation of the `_data.signature`
        * Note: A map maintaining the omniverse account and the related transaction nonce is RECOMMENDED  
        * Note: MUST implement the validation of the `_data.nonce` according to the current account nonce
        * Note: MUST implement the validation of the `_data. payload`
        * Note: This interface is just for sending an omniverse transaction, and the execution MUST NOT be within this interface 
        * Note: The actual execution of an omniverse transaction is RECOMMENDED to be in another function and MAY be delayed for a time,
        * which is determined all by who publishes an O-DLT token
        * @param _data: the omniverse transaction data with type {ERC6358TransactionData}
        * See more information in the defination of {ERC6358TransactionData}
        *
        * Emit a {TransactionSent} event
        */
        function sendOmniverseTransaction(ERC6358TransactionData calldata _data) external;

        /**
        * @notice Get the number of omniverse transactions sent by user `_pk`, 
        * which is also the valid `nonce` of a new omniverse transactions of user `_pk` 
        * @param _pk: Omniverse account to be queried
        * @return The number of omniverse transactions sent by user `_pk`
        */
        function getTransactionCount(bytes memory _pk) external view returns (uint256);

        /**
        * @notice Get the transaction data `txData` and timestamp `timestamp` of the user `_use` at a specified nonce `_nonce`
        * @param _user Omniverse account to be queried
        * @param _nonce The nonce to be queried
        * @return Returns the transaction data `txData` and timestamp `timestamp` of the user `_use` at a specified nonce `_nonce`
        */
        function getTransactionData(bytes calldata _user, uint256 _nonce) external view returns (ERC6358TransactionData memory, uint256);

        /**
        * @notice Get the chain ID
        * @return Returns the chain ID
        */
        function getChainId() external view returns (uint32);
    }
    ```

    - The `sendOmniverseTransaction` function MAY be implemented as `public` or `external`
    - The `getTransactionCount` function MAY be implemented as `public` or `external`
    - The `getTransactionData` function MAY be implemented as `public` or `external`
    - The `getChainId` function MAY be implemented as `pure` or `view`
    - The `TransactionSent` event MUST be emitted when `sendOmniverseTransaction` function is called
- Optional Extension: Fungible  

    ```solidity
    // import "{IERC6358.sol}";

    /**
    * @notice Interface of the omniverse fungible token, which inherits {IERC6358}
    */
    interface IERC6358Fungible is IERC6358 {
        /**
        * @notice Get the omniverse balance of a user `_pk`
        * @param _pk Omniverse account to be queried
        * @return Returns the omniverse balance of a user `_pk`
        */
        function omniverseBalanceOf(bytes calldata _pk) external view returns (uint256);
    }
    ```

    - The `omniverseBalanceOf` function MAY be implemented as `public` or `external`
- Optional Extension: NonFungible

    ```solidity
    import "{IERC6358.sol}";

    /**
    * @notice Interface of the omniverse non fungible token, which inherits {IERC6358}
    */
    interface IERC6358NonFungible is IERC6358 {
        /**
        * @notice Get the number of tokens in account `_pk`
        * @param _pk Omniverse account to be queried
        * @return Returns the number of tokens in account `_pk`
        */
        function omniverseBalanceOf(bytes calldata _pk) external view returns (uint256);

        /**
        * @notice Get the owner of a token `tokenId`
        * @param _tokenId Omniverse token id to be queried
        * @return Returns the owner of a token `tokenId`
        */
        function omniverseOwnerOf(uint256 _tokenId) external view returns (bytes memory);
    }
    ```

    - The `omniverseBalanceOf` function MAY be implemented as `public` or `external`
    - The `omniverseOwnerOf` function MAY be implemented as `public` or `external`

## Rationale

### Architecture

The key points in O-DLT include `Omniverse Account`, `Omniverse transaction`, `Omniverse Token`, `Omniverse Verification`, and `off-chain synchronizer`

- The implementation of the Omniverse Account is not very hard, and we temporarily choose a common elliptic curve secp256k1 to make it out, which has already been supported by Ethereum tech stacks. For those who donâ€™t support secp256k1 or have a different address system, we can adapt them with a simple mapping mechanism (Flow for example).  
- The Omniverse Transaction guarantees the ultimate consistency of omniverse transactions(o-transaction for short) across all chains. The related data structure is `ERC6358TransactionData` mentioned [above](#data-structure).

    - The `nonce` is very important, which is the key point to synchronize the states globally.
    - The `nonce` appears in two places, the one is `nonce in o-transaction` data as above, and the other is `account nonce` maintained by on-chain O-DLT smart contracts. 
    - The `nonce in o-transaction` data will be verified according to the `account nonce` managed by on-chain O-DLT smart contracts.
- The Omniverse Token could be implemented with the [interfaces mentioned above](#smart-contract-interface). It can also be used with the combination of [ERC-20](./eip-20.md)/[ERC-721](./eip-721.md). 
    - The first thing is verifying the signature of the o-transaction data. 
    - Then the operation will be added to a pre-execution cache, and wait for a fixed time until is executed. The waiting time will be able to be settled by the deployer, for example, 5 minutes. 
    - The off-chain synchronizer will deliver the o-transaction data to other chains. If another o-transaction data with the same nonce and the same sender account is received within the waiting time, and if there's any content in `ERC6358TransactionData` difference, a malicious attack happens and the related sender account will be punished. 
- The Omniverse Verification is mainly about the verification of the signature implemented in different tech stacks according to the blockchain. As the signature is unfakeable and non-deniable, malicious attacks could be found deterministicly.
- The last thing is the off-chain synchronizer. The synchronizer is a very simple off-chain procedure, and it just listens to the Omniverse events happening on-chain and delivers the latest o-transaction events. As everything in the Omniverse paradigm is along with a signature and is verified cryptographically, there's no need to worry about synchronizers doing malicious things, and I will explain it later. The off-chain part of O-DLT is indeed trust-free. Everyone can launch a synchronizer to get rewards by helping synchronize information.  

### Features

The O-DLT has the following features:

- The omniverse token(o-token for short) based on O-DLT  is not fragmented into separated parts by the boundary of blockchains but as a whole. If someone has one o-token on Ethereum, he will have an equivalent one on other chains at the same time.
- The state of the tokens based on O-DLT is synchronous on different chains. If someone sends/receives one token on Ethereum, he will send/receive one token on other chains at the same time.

### Workflow

- Suppose a common user `A` and the related operation `account nonce` is $k$.
- `A` initiate an omniverse transfer operation on Ethereum by calling `omniverse_transfer`. The current `account nonce` of `A` in the O-DLT smart contracts deployed on Ethereum is $k$ so the valid value of `nonce in o-transaction` needs to be $k+1$.  
- The O-DLT smart contracts on Ethereum verify the signature of the o-transaction data at an **application level**. If the verification for the signature and data succeeds, the o-transaction data will be published on the O-DLT smart contracts of the Ethereum side. The verification for the data includes:
    - whether the amount is valid
    - and whether the `nonce in o-transaction` is 1 larger than the `account nonce` maintained by the on-chain O-DLT
- Now, `A`'s newest submitted `nonce in o-transaction` on Ethereum is $k+1$, but still $k$ on other chains.
- The off-chain synchronizers find the newly published o-transaction, and they will find the `nonce in o-transaction` is larger than the related `account nonce` on other chains.
- These synchronizers will rush to deliver this message because whoever submits to the destination chain first will get a reward. There's no will for independent synchronizers to do evil because they just deliver `A`'s o-transaction data. (The reward is coming from the service fee or a mining mechanism according to the average number of o-transactions within a fixed time. The strategy of the reward may not be just for the first one but for the first three with a gradual decrease.) 
- Finally, the O-DLT smart contracts deployed on other chains will all receive the o-transaction data, verify the signature and execute it when the **waiting time is up**. After execution, the underlying `account nonce` will add 1. Now all the `account nonce` of account `A` will be $k+1$, and the state of the balances of the related account will be the same too.  

### Proof of ultimate consistency

Take transferring omniverse tokens for example. A non-rigorous but intuitive proof is as below:  

- At the first beginning, the nonce of an Omniverse account is set to be 0, every chain acts the same. Therefore $n=1$ is established.
- Suppose $n=k$ is established.
- $n=k+1$ happens when a new omniverse transaction first happens on one chain, Etheruem for instance. All the synchronizers will discover the new transaction on O-DLT smart contracts on Etheruem. 
- The synchronizers will carry this transaction along with its signature to other chains in a rush, and the first submitters will be rewarded.
- Very soon the state will be synchronized, and there's no need to worry about the omniverse transaction being fake as there's a signature with it. After executing the transaction on other chains, the balance and the nonce of the related Omniverse accounts will be the same all around. Up to this point, $n=k+1$ holds.  

## Reference Implementation

- An Omniverse Account example: `3092860212ceb90a13e4a288e444b685ae86c63232bcb50a064cb3d25aa2c88a24cd710ea2d553a20b4f2f18d2706b8cc5a9d4ae4a50d475980c2ba83414a796`
    - The Omniverse Account is a public key of the elliptic curve `secp256k1`
    - The related private key of the example is:  `cdfa0e50d672eb73bc5de00cc0799c70f15c5be6b6fca4a1c82c35c7471125b6`

- Omniverse Fungible Token
    - Common Tools

        ```solidity
        // SPDX-License-Identifier: MIT
        pragma solidity >=0.8.0 <0.9.0;

        import "{IERC6358}.sol";

        /**
        * @notice Fungible token data structure, from which the field `payload` in `ERC6358TransactionData` will be encoded
        *
        * @member op: The operation type
        * NOTE op: 0-31 are reserved values, 32-255 are custom values
        *           op: 0 - omniverse account `from` transfers `amount` tokens to omniverse account `exData`, `from` have at least `amount` tokens
        *           op: 1 - omniverse account `from` mints `amount` tokens to omniverse account `exData`
        *           op: 2 - omniverse account `from` burns `amount` tokens from his own, `from` have at least `amount` tokens
        * @member exData: The operation data. This sector could be empty and is determined by `op`. For example: 
                    when `op` is 0 and 1, `exData` stores the omniverse account that receives.
                    when `op` is 2, `exData` is empty.
        * @member amount: The amount of tokens being operated
        */
        struct Fungible {
            uint8 op;
            bytes exData;
            uint256 amount;
        }

        /**
        * @notice Used to record one omniverse transaction data
        * txData: The original omniverse transaction data committed to the contract
        * timestamp: When the omniverse transaction data is committed
        */
        struct OmniverseTx {
            ERC6358TransactionData txData;
            uint256 timestamp;
        }

        /**
        * @notice An malicious omniverse transaction data
        * oData: The recorded omniverse transaction data
        * hisNonce: The nonce of the historical transaction which it conflicts with
        */
        struct EvilTxData {
            OmniverseTx oData;
            uint256 hisNonce;
        }

        /**
        * @notice Used to record the historical omniverse transactions of a user
        * txList: Successful historical omniverse transaction list
        * evilTxList: Malicious historical omniverse transaction list
        */
        struct RecordedCertificate {
            OmniverseTx[] txList;
            EvilTxData[] evilTxList;
        }

        // Result of verification of an omniverse transaction
        enum VerifyResult {
            Success,
            Malicious
        }

        /**
        * @notice The library is mainly responsible for omniverse transaction verification and
        * provides some basic methods.
        * NOTE The verification method is for reference only, and developers can design appropriate
        * verification mechanism based on their bussiness logic.
        */
        library SkywalkerFungibleHelper {
            /**
            * @notice Encode `_fungible` into bytes
            */
            function encodeData(Fungible memory _fungible) internal pure returns (bytes memory) {
                return abi.encode(_fungible.op, _fungible.exData, _fungible.amount);
            }

            /**
            * @notice Decode `_data` from bytes to Fungible
            */
            function decodeData(bytes memory _data) internal pure returns (Fungible memory) {
                (uint8 op, bytes memory exData, uint256 amount) = abi.decode(_data, (uint8, bytes, uint256));
                return Fungible(op, exData, amount);
            }
            
            /**
            * @notice Get the hash of a transaction
            */
            function getTransactionHash(ERC6358TransactionData memory _data) public pure returns (bytes32) {
                Fungible memory fungible = decodeData(_data.payload);
                bytes memory payload = abi.encodePacked(fungible.op, fungible.exData, uint128(fungible.amount));
                bytes memory rawData = abi.encodePacked(_data.nonce, _data.chainId, _data.initiateSC, _data.from, payload);
                return keccak256(rawData);
            }

            /**
            * @notice Recover the address
            */
            function recoverAddress(bytes32 _hash, bytes memory _signature) public pure returns (address) {
                uint8 v;
                bytes32 r;
                bytes32 s;
                assembly {
                    r := mload(add(_signature, 32))
                    s := mload(add(_signature, 64))
                    v := mload(add(_signature, 65))
                }
                address recovered = ecrecover(_hash, v, r, s);
                require(recovered != address(0), "Verify failed");
                return recovered;
            }

            /**
            * @notice Check if the public key matches the recovered address
            */
            function checkPkMatched(bytes memory _pk, address _address) public pure {
                bytes32 hash = keccak256(_pk);
                address pkAddress = address(uint160(uint256(hash)));
                require(_address == pkAddress, "Signer not sender");
            }

            /**
            * @notice Verify an omniverse transaction
            */
            function verifyTransaction(RecordedCertificate storage rc, ERC6358TransactionData memory _data) public returns (VerifyResult) {
                uint256 nonce = rc.txList.length;
                
                bytes32 txHash = getTransactionHash(_data);
                address recoveredAddress = recoverAddress(txHash, _data.signature);
                // Signature verified failed
                checkPkMatched(_data.from, recoveredAddress);

                // Check nonce
                if (nonce == _data.nonce) {
                    return VerifyResult.Success;
                }
                else if (nonce > _data.nonce) {
                    // The message has been received, check conflicts
                    OmniverseTx storage hisTx = rc.txList[_data.nonce];
                    bytes32 hisTxHash = getTransactionHash(hisTx.txData);
                    if (hisTxHash != txHash) {
                        // to be continued, add to evil list, but can not be duplicated
                        EvilTxData storage evilTx = rc.evilTxList.push();
                        evilTx.hisNonce = nonce;
                        evilTx.oData.txData = _data;
                        evilTx.oData.timestamp = block.timestamp;
                        return VerifyResult.Malicious;
                    }
                    else {
                        revert("Duplicated");
                    }
                }
                else {
                    revert("Nonce error");
                }
            }
        }
        ```

    - Fungible token smart contract

        ```solidity
        // SPDX-License-Identifier: MIT
        pragma solidity >=0.8.0 <0.9.0;

        import "@openzeppelin/contracts/access/Ownable.sol";
        import "./ERC20.sol";
        import "./libraries/SkywalkerFungibleHelper.sol";
        import "./interfaces/IERC6358Fungible.sol";

        /**
        * @notice Implementation of the {IERC6358Fungible} interface
        */
        contract SkywalkerFungible is ERC20, Ownable, IERC6358Fungible {
            uint8 constant TRANSFER = 0;
            uint8 constant MINT = 1;
            uint8 constant BURN = 2;

            /** @notice Used to index a delayed transaction
            * sender: The account which sent the transaction
            * nonce: The nonce of the delayed transaction
            */
            struct DelayedTx {
                bytes sender;
                uint256 nonce;
            }

            /**
            * @notice The member information
            * chainId: The chain which the member belongs to
            * contractAddr: The contract address on the member chain
            */
            struct Member {
                uint32 chainId;
                bytes contractAddr;
            }

            // Chain id used to distinguish different chains
            uint32 chainId;
            // O-transaction cooling down time
            uint256 public cdTime;
            // Omniverse accounts record
            mapping(bytes => RecordedCertificate) transactionRecorder;
            // Transactions to be executed
            mapping(bytes => OmniverseTx) public transactionCache;

            // All information of chains on which the token is deployed
            Member[] members;
            // Omniverse balances
            mapping(bytes => uint256) omniverseBalances;
            // Delay-executing transactions
            DelayedTx[] delayedTxs;
            // Account map from evm address to public key
            mapping(address => bytes) accountsMap;

            event OmniverseTokenTransfer(bytes from, bytes to, uint256 value);

            /**
            * @notice Initiates the contract
            * @param _chainId The chain which the contract is deployed on
            * @param _name The name of the token
            * @param _symbol The symbol of the token
            */
            constructor(uint8 _chainId, string memory _name, string memory _symbol) ERC20(_name, _symbol) {
                chainId = _chainId;
            }

            /**
            * @notice See {IERC6358Fungible-sendOmniverseTransaction}
            * Send an omniverse transaction
            */
            function sendOmniverseTransaction(ERC6358TransactionData calldata _data) external override {
                _omniverseTransaction(_data);
            }

            /**
            * @notice See {IERC6358Fungible-triggerExecution}
            */
            function triggerExecution() external {
                require(delayedTxs.length > 0, "No delayed tx");

                OmniverseTx storage cache = transactionCache[delayedTxs[0].sender];
                require(cache.timestamp != 0, "Not cached");
                require(cache.txData.nonce == delayedTxs[0].nonce, "Nonce error");
                (ERC6358TransactionData storage txData, uint256 timestamp) = (cache.txData, cache.timestamp);
                require(block.timestamp >= timestamp + cdTime, "Not executable");
                delayedTxs[0] = delayedTxs[delayedTxs.length - 1];
                delayedTxs.pop();
                cache.timestamp = 0;
                // Add to transaction recorder
                RecordedCertificate storage rc = transactionRecorder[txData.from];
                rc.txList.push(cache);

                Fungible memory fungible = SkywalkerFungibleHelper.decodeData(txData.payload);
                if (fungible.op == TRANSFER) {
                    _omniverseTransfer(txData.from, fungible.exData, fungible.amount);
                }
                else if (fungible.op == MINT) {
                    _checkOwner(txData.from);
                    _omniverseMint(fungible.exData, fungible.amount);
                }
                else if (fungible.op == BURN) {
                    _checkOwner(txData.from);
                    _checkOmniverseBurn(fungible.exData, fungible.amount);
                    _omniverseBurn(fungible.exData, fungible.amount);
                }
            }
            
            /**
            * @notice Check if the transaction can be executed successfully
            */
            function _checkExecution(ERC6358TransactionData memory txData) internal view {
                Fungible memory fungible = SkywalkerFungibleHelper.decodeData(txData.payload);
                if (fungible.op == TRANSFER) {
                    _checkOmniverseTransfer(txData.from, fungible.amount);
                }
                else if (fungible.op == MINT) {
                    _checkOwner(txData.from);
                }
                else if (fungible.op == BURN) {
                    _checkOwner(txData.from);
                    _checkOmniverseBurn(fungible.exData, fungible.amount);
                }
                else {
                    revert("OP code error");
                }
            }

            /**
            * @notice Returns the nearest exexutable delayed transaction info
            * or returns default if not found
            */
            function getExecutableDelayedTx() external view returns (DelayedTx memory ret) {
                if (delayedTxs.length > 0) {
                    OmniverseTx storage cache = transactionCache[delayedTxs[0].sender];
                    if (block.timestamp >= cache.timestamp + cdTime) {
                        ret = delayedTxs[0];
                    }
                }
            }

            /**
            * @notice Returns the count of delayed transactions
            */
            function getDelayedTxCount() external view returns (uint256) {
                return delayedTxs.length;
            }

            /**
            * @notice See {IERC6358Fungible-omniverseBalanceOf}
            * Returns the omniverse balance of a user
            */
            function omniverseBalanceOf(bytes calldata _pk) external view override returns (uint256) {
                return omniverseBalances[_pk];
            }

            /**
            * @notice See {IERC20-balanceOf}.
            */
            function balanceOf(address account) public view virtual override returns (uint256) {
                bytes storage pk = accountsMap[account];
                if (pk.length == 0) {
                    return 0;
                }
                else {
                    return omniverseBalances[pk];
                }
            }

            /**
            * @notice Receive and check an omniverse transaction
            */
            function _omniverseTransaction(ERC6358TransactionData memory _data) internal {
                // Check if the tx initiateSC is correct
                bool found = false;
                for (uint256 i = 0; i < members.length; i++) {
                    if (members[i].chainId == _data.chainId) {
                        require(keccak256(members[i].contractAddr) == keccak256(_data.initiateSC), "Wrong initiateSC");
                        found = true;
                    }
                }
                require(found, "Wrong initiateSC");

                // Check if the sender is honest
                // to be continued, we can use block list instead of `isMalicious`
                require(!isMalicious(_data.from), "User malicious");

                // Verify the signature
                VerifyResult verifyRet = SkywalkerFungibleHelper.verifyTransaction(transactionRecorder[_data.from], _data);

                if (verifyRet == VerifyResult.Success) {
                    // Check cache
                    OmniverseTx storage cache = transactionCache[_data.from];
                    require(cache.timestamp == 0, "Transaction cached");
                    // Logic verification
                    _checkExecution(_data);
                    // Delays in executing
                    cache.txData = _data;
                    cache.timestamp = block.timestamp;
                    delayedTxs.push(DelayedTx(_data.from, _data.nonce));
                    if (_data.chainId == chainId) {
                        emit TransactionSent(_data.from, _data.nonce);
                    }
                }
                else if (verifyRet == VerifyResult.Malicious) {
                    // Slash
                }
            }

            /**
            * @notice Check if an omniverse transfer operation can be executed successfully
            */
            function _checkOmniverseTransfer(bytes memory _from, uint256 _amount) internal view {
                uint256 fromBalance = omniverseBalances[_from];
                require(fromBalance >= _amount, "Exceed balance");
            }

            /**
            * @notice Exucute an omniverse transfer operation
            */
            function _omniverseTransfer(bytes memory _from, bytes memory _to, uint256 _amount) internal {
                _checkOmniverseTransfer(_from, _amount);
                
                uint256 fromBalance = omniverseBalances[_from];
                
                unchecked {
                    omniverseBalances[_from] = fromBalance - _amount;
                }
                omniverseBalances[_to] += _amount;

                emit OmniverseTokenTransfer(_from, _to, _amount);

                address toAddr = _pkToAddress(_to);
                accountsMap[toAddr] = _to;
            }
            
            /**
            * @notice Check if the public key is the owner
            */
            function _checkOwner(bytes memory _pk) internal view {
                address fromAddr = _pkToAddress(_pk);
                require(fromAddr == owner(), "Not owner");
            }

            /**
            * @notice Execute an omniverse mint operation
            */
            function _omniverseMint(bytes memory _to, uint256 _amount) internal {
                omniverseBalances[_to] += _amount;
                emit OmniverseTokenTransfer("", _to, _amount);

                address toAddr = _pkToAddress(_to);
                accountsMap[toAddr] = _to;
            }

            /**
            * @notice Check if an omniverse burn operation can be executed successfully
            */
            function _checkOmniverseBurn(bytes memory _from, uint256 _amount) internal view {
                uint256 fromBalance = omniverseBalances[_from];
                require(fromBalance >= _amount, "Exceed balance");
            }

            /**
            * @notice Execute an omniverse burn operation
            */
            function _omniverseBurn(bytes memory _from, uint256 _amount) internal {
                omniverseBalances[_from] -= _amount;
                emit OmniverseTokenTransfer(_from, "", _amount);
            }

            /**
            * @notice Convert the public key to evm address
            */
            function _pkToAddress(bytes memory _pk) internal pure returns (address) {
                bytes32 hash = keccak256(_pk);
                return address(uint160(uint256(hash)));
            }

            /**
            * @notice Add new chain members to the token
            */
            function setMembers(Member[] calldata _members) external onlyOwner {
                for (uint256 i = 0; i < _members.length; i++) {
                    if (i < members.length) {
                        members[i] = _members[i];
                    }
                    else {
                        members.push(_members[i]);
                    }
                }

                for (uint256 i = _members.length; i < members.length; i++) {
                    delete members[i];
                }
            }

            /**
            * @notice Returns chain members of the token
            */
            function getMembers() external view returns (Member[] memory) {
                return members;
            }
            
            /**
            @notice See {IERC20-decimals}.
            */
            function decimals() public view virtual override returns (uint8) {
                return 12;
            }

            /**
            * @notice See IERC6358Fungible
            */
            function getTransactionCount(bytes memory _pk) external override view returns (uint256) {
                return transactionRecorder[_pk].txList.length;
            }

            /**
            * @notice See IERC6358Fungible
            */
            function getTransactionData(bytes calldata _user, uint256 _nonce) external override view returns (ERC6358TransactionData memory txData, uint256 timestamp) {
                RecordedCertificate storage rc = transactionRecorder[_user];
                OmniverseTx storage omniTx = rc.txList[_nonce];
                txData = omniTx.txData;
                timestamp = omniTx.timestamp;
            }

            /**
            * @notice Set the cooling down time of an omniverse transaction
            */
            function setCooingDownTime(uint256 _time) external {
                cdTime = _time;
            }

            /**
            * @notice Index the user is malicious or not
            */
            function isMalicious(bytes memory _pk) public view returns (bool) {
                RecordedCertificate storage rc = transactionRecorder[_pk];
                return (rc.evilTxList.length > 0);
            }

            /**
            * @notice See IERC6358Fungible
            */
            function getChainId() external view returns (uint32) {
                return chainId;
            }
        }
        ```

- The implememtation of Omniverse Non-Fungible Token is similiar with the Omniverse Fungible Token.  

## Security Considerations

### Attack Vector Analysis

According to the above, there are two roles:

- **common users** who initiate a o-transaction (at the application level)
- and **synchronizers** who just carry the o-transaction data if they find differences between different chains.  

The two roles might be where the attack happens:  

#### **Will the *synchronizers* cheat?**  

- Simply speaking, it's none of the **synchronizer**'s business as **they cannot create other users' signatures** unless some **common users** tell him, but at this point, we think it's a problem with the role **common user**.  
- The **synchronizer** has no will and cannot do evil because the transaction data that they deliver is verified by the related **signature** of others(a **common user**).  
- The **synchronizers** will be rewarded as long as they submit valid o-transaction data, and *valid* only means that the signature and the amount are both valid. This will be detailed and explained later when analyzing the role of **common user**.  
- The **synchronizers** will do the delivery once they find differences between different chains:
    - If the current `account nonce` on one chain is smaller than a published `nonce in o-transaction` on another chain
    - If the transaction data related to a specific `nonce in o-transaction` on one chain is different from another published o-transaction data with the same `nonce in o-transaction` on another chain

- **Conclusion: The *synchronizers* won't cheat because there are no benefits and no way for them to do so.**

#### **Will the *common user* cheat?**

- Simply speaking, **maybe they will**, but fortunately, **they can't succeed**.  
- Suppose the current `account nonce` of a **common user** `A` is $k$ on all chains.  
- Common user `A` initiates an o-transaction on a Parachain of Polkadot first, in which `A` transfers `10` o-tokens to an o-account of a **common user** `B`. The `nonce in o-transaction` needs to be $k+1$. After signature and data verification, the o-transaction data(`ot-P-ab` for short) will be published on Polkadot.
- At the same time, `A` initiates an o-transaction with the same nonce $k+1$ but different data(transfer `10` o-tokens to another o-account `C`) on Ethereum. This o-transaction(named `ot-E-ac`) will pass the verification on Ethereum first, and be published.  
- At this point, it seems `A` finished a ***double spend attack*** and the O-DLT states on Polkadot and Ethereum are different.  
- **Response strategy**:
    - As we mentioned above, the synchronizers will deliver `ot-P-ab` to the O-DLT on Ethereum and deliver `ot-E-ac` to the O-DLT on Polkadot because they are different although with the same nonce. The synchronizer who submits the o-transaction first will be rewarded as the signature is valid.
    - Both the O-DLTs on Polkadot and Ethereum will find that `A` did cheating after they received `ot-E-ac` and `ot-P-ab` respectively as the signature of `A` is non-deniable.  
    - We mentioned above that the execution of an o-transaction will not be done immediately and instead there needs to be a fixed waiting time. So the `double spend attack` caused by `A` won't succeed.
    - There will be many synchronizers waiting for delivering o-transactions to get rewards. So although it's almost impossible that a **common user** can submit two o-transactions to two chains, none of the synchronizers deliver the o-transactions successfully because of a network problem or something else, we still provide a solution:  
        - The synchronizers will connect to several native nodes of every public chain to avoid the malicious native nodes.
        - If it indeed happened that all synchronizers' network break, the o-transaction will be synchronized when the network recovered. If the waiting time is up and the cheating o-transaction has been executed, we will revert it from where the cheating happens according to the `nonce in o-transaction` and `account nonce`.
- `A` will be punished(lock his account or something else, and this is about the certain tokenomics determined by developers according to their own situation).  

- **Conclusion: The *common user* maybe cheat but won't succeed.**

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
