---
eip: 867
title: Ethereum Recovery Proposals
description: Process to safely recover stuck funds in Ethereum smart contracts.
author: Dan Phifer <dp@musiconomi.com>, James Levy <james@taptrust.com>, Reuben Youngblom <reuben@taptrust.com>, Reynaldo Rodriguez (@ReyRod)
discussions-to: https://ethereum-magicians.org/t/eip-867-standardized-ethereum-recovery-proposals-erps/139
status: Draft
type: Meta
created: 2018-02-02
---

## Abstract

This proposal identifies a common solution method for addressing certain classes of lost funds on the Ethereum blockchain. It focuses on cases where directly affected parties agree on the desired outcome, enabling timely and low-risk solutions to issues that have occurred or may occur as Ethereum grows. The solution method includes: (1) standards for follow-on Ethereum Recovery Proposals (ERPs), (2) recommendations for a common format to specify corrective actions, and (3) guidelines for client implementation that minimize risk by limiting possible corrective actions.

## Motivation

Fund recovery on the Ethereum blockchain is often controversial. Frozen fund recovery proposals rarely succeed due to the ad-hoc nature of such requests and the subjectivity required to evaluate them. This EIP aims to remove these barriers by providing both a standardized format for fund recovery EIPs and an objective standard for evaluating future proposals.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

This EIP describes a common format for a subclass of EIPs, referred to as Ethereum Recovery Proposals (ERPs), that propose irregular state changes to address fund recovery scenarios that cannot be addressed using the standard protocol. Each ERP will reference this EIP and follow the guidelines set out here.

The purpose of each ERP is to:

1. Clearly describe the issue to be corrected
2. Describe why an irregular state change is both necessary and justified
3. Demonstrate that the proposed actions will achieve the ERP's objectives

Each ERP MUST use a standard format to represent the proposed state changes and MUST include a verification script that can reliably generate those changes. ERPs that do not meet (at least) these requirements will not be considered for approval.

Each ERP SHOULD contain the following items:

- **Preamble**: EIP (RFC 822) header containing metadata about the ERP, including the EIP number, a short title (44 character maximum), and the real names (and optional contact information) for each author.
- **Abstract**: A simplified and layman-accessible explanation of the ERP.
- **Detailed description**: A human-readable description of the proposed corrective actions and the criteria used to determine the proposed actions.
- **Justification**: A concise description of why the corrective actions are both reasonable and unlikely to be challenged by any directly affected party.
- **Verification script**: A machine-readable script that outputs one State Change Object. The script SHOULD clearly implement the selection and action generating logic outlined in the description such that reviewers can independently re-generate an identical State Change Object.
- **State Change Object**: The output of the verification script and the input to the ethereum clients. It specifies the complete set of proposed state change actions.
- **Appendix (optional)**: Supporting evidence. Attachments in the appendix MAY include documents verifying details specified as part of the recovery proposal description.

The following are considered out of scope from this EIP:

- Which fund recovery proposals, if any, should be accepted for implementation.
- How common classes of recovery proposal plaintiff may organize ERPs representing a collective group of individual parties.

### Justification

A concise description of why this action is both reasonable (cannot be accomplished without an irregular state change) and unlikely to be challenged by a *directly* affected party.

**Considerable example** (concise, includes supporting evidence, no negative impact):
*A crowdsale run by XYZ incorrectly published the testnet address of their crowdsale contract to their public website at the start of their crowdsale on Jan 19, 2018. 501 ETH was sent by 328 users on the mainnet to the incorrect address between block 4,235,987 and 4,236,050. See here for the testnet contract, and see here for the transactions to the same address on the mainnet. See here for a statement made by XYZ on their website. Because there is a contract at this address on the testnet and the corresponding nonce for the creator address has already been used on the mainnet, it is considered effectively impossible that anyone coincidentally holds the private key. We have verified that all transactions came from addresses with no associated code, so there should be no issue returning eth to the senders.*

**Insufficient example** (not enough detail, no supporting evidence):
*We accidentally put the wrong contract address up on our website. Can you please refund any eth sent to 0x1234 back to the senders. Thanks.*

**Unacceptable example** (not objective, one person's word against another):
*I sent tokens to X for services and he did a lousy job. I want my money back, but he won't refund me. Please help!!*

### Verification Script

A machine-readable script that outputs a single State Change Object. This script SHOULD be implemented so that it is easily audited by a reviewer. Verification scripts SHOULD be javascript files that MAY use the web3.js library.

Guidelines for verification scripts:

- Scripts SHOULD always be written to be as concise as reasonably possible, and anyone executing the verification script SHOULD review it first to verify that it does not contain any unsafe operations.
- No verification script SHOULD ever require an unlocked ethereum wallet.
- The script SHOULD hardcode the highest block included during execution (otherwise the results may differ between runs).

### State Change Object

The State Change Object is a standard format that will be interpretable by all Ethereum clients.

It is a single JSON object containing the following fields:

- **erpId**: A string identifier for this ERP (likely the associated EIP number, e.g. "EIP-1234"). This will be converted from ascii to a hex string, then added as extra data on the target block.
- **targetBlock**: The block at which the stateChange should be applied. Clients would use this to determine when a set of state changes should occur.
- **actions**: An array of State Change Actions.
- **metadata**
  - **sourceBlock**: The highest block considered by the script when it was run.
  - **version**: The version of the verification script when it was run.

### State Change Actions

A State Change action is a JSON object that includes a "type" field and a set of "data" fields, where the contents of the data fields are dependent on the type and MUST follow the schema defined for that type. This allows clients to support a limited set of operations initially and add more based on a subsequent EIP if needed. Support for the following action types SHOULD be implemented by clients upon adoption of this EIP:

#### weiTransfer

The `weiTransfer` action transfers ETH from one address to another.

*Data fields*

- **type** (*string*): `weiTransfer`
- **fromAddress** (*hex string*): The address from which ETH should be transferred
- **toAddress** (*hex string*): The address to which ETH should be sent
- **value** (*decimal string*): The amount of ETH to be transferred, in units of wei. The value MUST be a whole number greater than zero.

#### storeCode

The `storeCode` action stores the given code at the given address.

*Data fields*

- **type** (*string*): `storeCode`
- **toAddress** (*hex string*): The address to which the contract should be restored.
- **expectedCodeHash** (*hex string*): The expected hash of the code already at the toAddress. The empty string SHOULD be used if no code is expected at the toAddress. In all other cases, the "0x" prefix is optional.
- **code** (*hex string*): The new bytecode associated with the contract

### Appendix (Optional)

The appendix MAY include additional supporting evidence or attachments that will help reviewers understand or verify the claims made in the ERP.

For the storeCode operation, it SHOULD include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It SHOULD also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes SHOULD be noted. If they are identical, the author SHOULD indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases SHOULD be included to the extent that they address the issues encountered with the original contract.

If accepted, an ERP could easily compile the block at which the changes are to take place, and the source of the actions (which would be the output of the script, in a standardized object output). These can be bundled with the client for seamless execution.

## Rationale

The primary consideration for the approach described above was to minimize the amount of risk associated with recovery actions that would otherwise not have a viable solution. A secondary consideration was to standardize the format used in the proposals for recovery actions.

First, including a verification script guarantees that the way in which the recovery actions were determined is unambiguous. This does not mean that the recovery actions are necessarily correct, only that the logic used to determine them is fully specified and auditable.

Second, requiring that the output of the verification script is directly interpretable by client programs minimizes the work necessary for each client to adopt a particular ERP. It also reduces the risk that two clients will make different decisions about the implementation of a particular ERP.

Third, action types are intentionally limited and inflexible, which reduces the likelihood of unintended consequences or maliciously constructed files affecting the blockchain state. The format is easily extensible with new actions types if needed but that would require a separate EIP.

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

*The ERP authors are currently seeking feedback from client teams about the proper testing procedures*

## Reference Implementation

A reference implementation has been written for the EthereumJ platform.

## Security Considerations

This EIP by itself does not modify the Ethereum protocol or state; however, it provides a framework for standardized state modifications. The following security considerations should be noted:

1. Each ERP must be carefully vetted by the community to ensure that the proposed state changes do not create unintended consequences.
2. Clients implementing this EIP must ensure proper validation of all State Change Objects before applying them.
3. The limited set of allowed state change actions helps constrain potential security risks.
4. The verification script requirement ensures transparency and auditability of the logic used to determine recovery actions.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
