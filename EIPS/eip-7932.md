---
eip: 7932
title: Secondary Signature Algorithms
description: Introduces a precompile and registry for handling alternative signature algorithms
author: James Kempton (@SirSpudlington)
discussions-to: https://ethereum-magicians.org/t/eip-7932-secondary-signature-algorithms/23514
status: Draft
type: Standards Track
category: Core
created: 2025-04-12
requires: 155, 2718, 7702
---

## Abstract

This EIP:
 - Creates a unified registry & standardized interface for introducing additional signature algorithms for the use of deriving account addresses.
 - Introduces a precompile at address `SIGRECOVER_PRECOMPILE_ADDRESS` for decoding these newly introduced algorithms.

## Motivation

As quantum computers become more advanced, several new post-quantum (PQ) algorithms have been designed. These algorithms all have certain issues, such as large key sizes (>1KiB), large signature sizes, or long verification times. These issues make them more expensive to compute and store than the currently used secp256k1 curve.

This EIP provides a solution to the diversity by introducing a standardized registry for storing and verifying several different transactions.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Unless explicitly noted, integer encoding MUST be in big-endian format.

### Parameters

| Constant | Value |
| - | - |
| `GAS_PER_ADDITIONAL_VERIFICATION_BYTE`| `16` |
| `SIGRECOVER_PRECOMPILE_ADDRESS`| `Bytes20(0x12)` |
| `SIGRECOVER_PRECOMPILE_BASE_GAS` | `3000` |
| `SECP256K1_SIGNATURE_SIZE` | `65` |


### Algorithm specification

This EIP only provides the `secp256k1` algorithm. Further algorithms MUST be specified via a distinct EIP.

Each type of algorithm MUST specify the following fields:

| Field Name | Description |
|-|-|
|`ALG_TYPE`| The uint8 that would be present at `signature_info[0]` |
|`GAS_PENALTY`| The additional gas penalty from verification of the signature |

The `GAS_PENALTY` field MUST be assumed to be the worst-case scenario and MUST only account for verification costs, not storage nor signing.

A verification function must be present per algorithm. The verification function MUST have the following signature:

`def verify(signature_info: Bytes, payload_hash: Hash32) -> Bytes`

The verify function MUST either return an error or return the full public key of the sender.

Specifications MUST include some form of security analysis on the provided algorithm and basic benchmarks justifying gas costs. Additionally, algorithms MUST ensure that variations of signatures cannot be made without the private key. 

An example of this specification can be found [here](../assets/eip-7932/template-eip.md).

### Deriving address from public keys

The function below MUST be used when deriving an address from a public key:

```python
def pubkey_to_address(public_key: Bytes, algorithm_id: uint8) -> ExecutionAddress:
    if algorithm_id == 0xFF: # Compatibility shim to ensure backwards compatibility
        return ExecutionAddress(keccak(public_key[1:])[12:])

    # || is binary concatenation
    return ExecutionAddress(keccak(algorithm_id || public_key)[12:])
```

### Algorithm Registry

This EIP uses the `algorithm_registry` object to signify algorithms that have been included within a hard fork.

The structure of the registry can be represented as the pythonic object `dict[uint8, callable[[Bytes, Hash32], Bytes]]`.

A living EIP MAY be created on finalization of this EIP to track currently active algorithms across forks. 

### Gas calculation

All signatures that use more resources than the secp256k1 curve suffer an additional penalty which MUST be calculated
as specified in the `calculate_penalty` function.

```python
def calculate_penalty(signature_info: bytes) -> int:
  gas_penalty_base = max(len(signature_info) - (SECP256K1_SIGNATURE_SIZE + 1), 0) * GAS_PER_ADDITIONAL_VERIFICATION_BYTE
  total_gas_penalty = gas_penalty_base + algorithm_registry[signature_info[0]].GAS_PENALTY
  return total_gas_penalty
```

### `secp256k1` algorithm

| Field | Value |
|-|-|
|`ALG_TYPE`| `0xFF` |
|`GAS_PENALTY`| `0` |


```python
def secp256k1_unpack(signature: ByteVector[SECP256K1_SIGNATURE_SIZE]) -> tuple[uint256, uint256, uint8]:
    r = uint256.from_bytes(signature[0:32], 'big')
    s = uint256.from_bytes(signature[32:64], 'big')
    y_parity = signature[64]
    return (r, s, y_parity)

def secp256k1_validate(signature: ByteVector[SECP256K1_SIGNATURE_SIZE]):
    SECP256K1N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
    r, s, y_parity = secp256k1_unpack(signature)
    assert 0 < r < SECP256K1N
    assert 0 < s <= SECP256K1N // 2
    assert y_parity in (0, 1)

def verify(signature_info: Bytes, payload_hash: Hash32) -> Bytes
  assert len(signature_info) == (SECP256K1_SIGNATURE_SIZE + 1)
  secp256k1_validate(signature_info[1:])

  ecdsa = ECDSA()
  recover_sig = ecdsa.ecdsa_recoverable_deserialize(signature_info[1:65], signature_info[65])
  public_key = PublicKey(ecdsa.ecdsa_recover(payload_hash, recover_sig, raw=True))
  uncompressed = public_key.serialize(compressed=False)
  return uncompressed
```

This algorithm MUST ONLY be used if the transaction's signature is secp256k1 but the `additional_signatures` field contains one or more entries. It MUST NOT be present if the transaction does not contain additional signatures. `secp256k1` MUST NOT be present in any `additional_signatures` entry.

### `sigrecover` precompile

This EIP also introduces a new precompile located at `SIGRECOVER_PRECOMPILE_ADDRESS`.

This precompile MUST cost `SIGRECOVER_PRECOMPILE_BASE_GAS` when called regardless of validity. This cost MUST be aggregated with `calculate_penalty(signature_info)` and charged before the `sigrecover` precompile executes.

The precompile MUST output the 20-byte address of the signer provided. Callers MUST assume all zero bytes as a failure.

The precompile logic contains the following logic:

```python
def sigrecover_precompile(input: Bytes) -> Bytes:
  # Recover signature, hash and type
  assert(len(input) >= 33)
  hash: Hash32 = input[:32]
  signature_info: Bytes = input[32:]
  algorithm_type = signature_info[0]
  
  # Ensure the algorithm exists
  if algorithm_type not in algorithm_registry:
    return ExecutionAddress(0x0)

  alg = algorithm_registry[algorithm_type]

  # Run verify function
  try:
    pubkey = alg.verify(signature_info, hash)
    return pubkey_to_address(pubkey, algorithm_type)
  except:
    return ExecutionAddress(0x0)
```

## Rationale

### Opaque `signature_info` type

As each algorithm has unique properties, e.g. signature recovery and key sizes, the object needs to hold every permutation of every possible signature and potentially additional recovery information. A bytearray of a dynamic size would be able to achieve this goal. However, this leads to a DoS vector which the [Gas penalties](#gas-penalties) section solves.

### Gas penalties

Having multiple different algorithms results in multiple different signature sizes and verification costs. Hence, every signature algorithm that is more expensive than the default ECDSA secp256k1 curve incurs an additional gas penalty. This is to discourage the use of overly expensive algorithms for no specific reason.

The `GAS_PER_ADDITIONAL_VERIFICATION_BYTE` value being `16` was taken from the calldata cost of a transaction, as it is a similar data type and must persist indefinitely to ensure later verification.

## Backwards Compatibility

Non-EIP-7932 transactions will still be processed as the default secp256k1 curve. Therefore, there would be no backwards compatibility issues in processing other transactions.

## Test Cases

<!-- TODO add test cases -->

## Security Considerations

Allowing more ways to derive addresses for a single account may decrease overall security for that specific account. However, this is partially mitigated by the increase in processing power required to trial all algorithms. Even still, adding additional algorithms may need further discussion to ensure that the security of the network would not be compromised.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
