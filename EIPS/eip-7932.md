---
eip: 7932
title: Secondary Signature Algorithms
description: Introduces a new transaction type and precompile for handling alternative signature algorithms
author: James Kempton (@SirSpudlington)
discussions-to: https://ethereum-magicians.org/t/eip-7932-secondary-signature-algorithms/23514
status: Draft
type: Standards Track
category: Core
created: 2025-04-12
requires: 155, 6404, 6466, 7495, 7702
---

## Abstract

This EIP does 3 things:

 - Standardizes the introduction of several new algorithms for signing data.
 - Introduces a new [EIP-7495](./eip-7495.md) transaction profile that can modify the signature data of a contained transaction to a different signature algorithm.
 - Introduces a precompile at address `0x12` for decoding these new introduced algorithms.

## Motivation

As quantum computers are getting more advanced, several new post-quantum (PQ) algorithms have been designed. These algorithms all contain drawbacks such as large key sizes (>1KiB), large signature sizes or long verification times. These issues make them more expensive to compute and store than the current secp256k1 curve in use (as of 2025-04-12).

This EIP provides a future-proof solution to these algorithms by adding a standardized way to represent alternative algorithms within a transaction.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

If not explicitly noted, integer encoding is always big-endian.

### Parameters

| Constant | Value |
| - | - |
| `MAX_VERIFICATION_SIZE` | `8192` (8 KiB) |
| `MAX_ADDITIONAL_INFO` | `255` |
| `GAS_PER_ADDITIONAL_VERIFICATION_BYTE`| `16` |
| `SIGRECOVER_PRECOMPILE_ADDRESS`| `Bytes20(0x12)` |
| `SIGRECOVER_PRECOMPILE_BASE_GAS` | `3000` |

`SECP256K1_SIGNATURE_SIZE` and `TransactionPayload` are defined from [EIP-6404](./eip-6404.md) and `ExecutionAddress` is defined from [EIP-6466](./eip-6466.md).

### Algorithmic Transaction


New  Profile definitions are introduced to represent native SSZ transactions:

This EIP introduces a new [EIP-7495](./eip-7495.md) transaction profile of SSZ type `AlgorithmicTransaction` defined below:

```python

class AdditionalSignature(Container):
  algorithm_type: uint8,
  signature_info: ByteList[MAX_VERIFICATION_SIZE]

class AlgorithmicTransaction(Container):
  algorithm_type: uint8,
  signature_info: ByteList[MAX_VERIFICATION_SIZE]
  payload: TransactionPayload,
  additional_signatures: List[AdditionalSignature, MAX_ADDITIONAL_INFO]

```

The field `algorithm_type` represents the algorithm used to sign the transaction in the `payload` field. This EIP does not define algorithms for use with this transaction type apart from the generic `secp256k1` which may only be used under specific circumstances.

The hash of the payload MUST be calculated using the `compute_ssz_sig_hash` function below:

```python
def compute_ssz_sig_hash(payload: TransactionPayload) -> Hash32:
    return Hash32(ExecutionSigningData(
        object_root=payload.hash_tree_root(),
        domain=DOMAIN_TX_SSZ,
    ).hash_tree_root())
```

The transaction signature MUST be verified using the `verify` function for the algorithm denoted via `algorithm_type`.

The `additional_signature` field only needs to be populated if additional protocol level signatures are required such as [EIP-7702](./eip-7702.md)'s `authorization_list`. 

If the signature is being overridden via an `additional_signature` entry, the `Secp256k1ExecutionSignature` should be set to `keccak256(algorithm_type + signature_info + index)` and right-padded with 33 zero bytes. `index` is a `uint8` of the index of which the `AdditionalSignature` is present in the `additional_signatures` list. Each entry MUST also be checked to ensure that `algorithm_type` is known, is NOT `secp256k1` and `len(signature_info) <= alg.MAX_SIZE`. This MUST also be verified using the `verify` function of the algorithm denoted via `algorithm_type`.

The Algorithmic Transaction MUST ONLY generate a [EIP-6466](./eip-6466.md) receipt of the transaction it is wrapping (the tx in the `payload` field). Implementations MUST not be able to differentiate between an unwrapped and wrapped transaction by receipts alone.

When clients receive an Algorithmic Transaction via gossip or RPC they MUST validate both the Algorithmic Transaction and the transaction in the `payload` field. The tx order calculation (e.g. based on gas price) MUST be done on the transaction in the `payload` field. If either the transaction or the payload is invalid, the entire transaction is invalid.

### `identify_transaction_profile` modifications

An additional section is added to the `identify_transaction_profile` helper from [EIP-6404](./eip-6404.md):

```python

def identify_transaction_profile(tx: Transaction) -> Type[Profile]:
    if tx.algorithm_type is not None:
        return AlgorithmicTransaction
    
    # ... The remaining parts of the function should remain
```

### Algorithm specification

Further algorithms MUST be specified via an additional EIP.

Each type of algorithm MUST specify the following fields:
| Field Name | Description |
|-|-|
|`ALG_TYPE`| The uint8 of the algorithm unique ID |
|`MAX_SIZE`| The maximum size of `signature_info` field in a transaction |
|`GAS_PENALTY`| The additional gas penalty from verification of the signature |

The `GAS_PENALTY` field MUST only account for verification costs, not storage nor signing. `GAS_PENALTY` MUST be assumed to be worst-case scenario.

New algorithms MUST also specify how to recover and verify a valid address (`ExecutionAddress`) from the `signature_info` field inside the transaction, the verification function MUST follow the following signature:

`def verify(signature_info: bytes, payload_hash: Hash32) -> ExecutionAddress`

The verify function MUST return either an error or return the address of the signer.

Specifications MUST include the following when specifying new algorithms:

- Some form of security analysis on the algorithm.
- A benchmark justifying gas costs.

An example of this specification can be found [here](../assets/eip-7932/template-eip.md).

### Algorithm Living EIP

This EIP uses the `Algorithms` object to signify final and active algorithms. These are selected via the EIP process and hard-fork inclusion.

A new living EIP SHOULD be created on the finalization of this EIP to track currently supported algorithms across forks, this EIP MUST contain a formal definition of the `Algorithms` object.

### Verification

Implementations MUST consider transactions invalid where `len(tx.signature_info) > alg.MAX_SIZE`, this also applies for objects inside `additional_signature`.

The following checks MUST always be made against any type of `signature_info` and `alg_type`. If the result of these checks do not pass then one of the following apply:

1. The transaction is invalid
2. If called from the precompile, the precompile MUST return 0x0 as the address.

```python
assert(Algorithms[alg_type] != None)  # `Algorithms` is a dictionary containing every defined algorithm
assert(len(signature_info) <= alg.MAX_SIZE)
```

Transactions MUST also follow all rules outlined in the [Specification section](#algorithmic-transaction).

### Gas calculation

All transactions that use more resources than the secp256k1 curve suffer an additional penalty. This penalty MUST be calculated as follows:

```python
def calculate_penalty(signature_info: bytes, algorithm: int) -> int:
  gas_penalty_base = max(len(signature_info) - SECP256K1_SIGNATURE_SIZE, 0) * GAS_PER_ADDITIONAL_VERIFICATION_BYTE
  total_gas_penalty = gas_penalty_base + ALGORITHMS[algorithm].GAS_PENALTY
  return total_gas_penalty
```

The penalty MUST be added onto the `21000` base gas of each transaction BEFORE the transaction is processed. If the wrapped tx's `gas_limit` is less than `21000 + calculate_penalty(signature_info, algorithm)` then the transaction MUST be considered invalid and MUST NOT be included within blocks. This transaction also MUST inherit the intrinsics of the wrapped tx's fee structure (e.g. a wrapped EIP-1559 tx would behave as a EIP-1559 tx).

The penalty MUST be applied to every instance of an `additional_signature` object, which then MUST be added onto the transaction's initial gas. This is done irrespective of whether the signature is used or not.

### `secp256k1` algorithm

| Field | Value |
|-|-|
|`ALG_TYPE`| `0xFF` |
|`MAX_SIZE`| `SECP256K1_SIGNATURE_SIZE` |
|`GAS_PENALTY`| The additional gas penalty from verification of the signature |

`secp256k1_validate`, `SECP256K1_SIGNATURE_SIZE` and `secp256k1_recover_signer` are defined from [EIP-6404](./eip-6404.md).

```python
def verify(signature_info: bytes, payload_hash: Hash32) -> ExecutionAddress
  assert len(signature_info) == SECP256K1_SIGNATURE_SIZE
  secp256k1_validate(signature_info)
  return secp256k1_recover_signer(signature_info, payload_hash)
```

This algorithm MUST ONLY be used if the base signer is secp256k1 but the `additional_signatures` field contains entries. It MUST NOT be present if the transaction does not contain additional signatures. `secp256k1` MUST NOT be present in the `additional_signatures` field.

### `sigrecover` precompile

This EIP also introduces a new precompile located at `SIGRECOVER_PRECOMPILE_ADDRESS`.

This precompile MUST NOT be called when verifying transaction parameters, instead this call should be verified as specified above.

This precompile MUST cost `SIGRECOVER_PRECOMPILE_BASE_GAS` when calling even if algorithm does not exist, this price MUST be aggregated with algorithm specific `GAS_PENALTY` and the output of `calculate_penalty` for the signature data, this penalty is charged once the `sigrecover` precompile executes.

The precompile MUST output the 20-byte address of the signer provided. Callers MUST assume that all zero bytes are a failure.

The precompile logic executes the following logic:

```python

def sigrecover_precompile(input: Bytes) -> Bytes:
  # Recover signature length and type
  assert(len(input) >= 64)
  hash: Hash32 = input[:32]
  alg_type: uint8 = input[32]
  sig_length: uint248 = int.from_bytes(input[33:64], "big")

  # Ensure the algorithm exists and signature is correct size
  if alg_type not in Algorithms:
    return ExecutionAddress(0x0)

  alg = Algorithms[alg_type]

  # Sig length must be smaller than alg.MAX_SIZE and
  # equal to the remaining call data
  if sig_length > alg.MAX_SIZE or sig_length != (len(input) - 64):
    return ExecutionAddress(0x0)

  # Run verify function
  try:
      alg.verify(input[64:64 + sig_length], hash)
  except:
      return ExecutionAddress(0x0)
  
```

## Rationale

### Opaque `signature_info` type

As each algorithm has unique properties, i.e. signature recovery and key sizes, a object is needed to hold every permutation of every possible key and signature. A bytearray of dynamic size would be able to achieve this goal, this does lead to a DoS vector which the [Gas penalties](#gas-penalties) section solves along with the `MAX_SIZE` parameter.

### Gas penalties

Having multiple different algorithms results in multiple different signature sizes, and verification costs. Hence, every signature algorithm that is more expensive than the default ECDSA secp256k1 curve, incurs an additional gas penalty, this is to discourage the use of overly expensive algorithms for no specific reason.

The `GAS_PER_ADDITIONAL_VERIFICATION_BYTE` value being `16` was taken from the calldata cost of a transaction, as it is a similar datatype and must persist indefinitely to ensure later verification.


### Not specifying account key-sharing / migration

Allowing a single account to share multiple keys creates a security risk as it reduces the security to the weakest algorithm. This is also out of scope for this EIP and could be implemented via a future EIP.

### Keeping a similar address rather than introducing a new address format

While adding a new address format for every new algorithm would ensure that collisions never happen, and that security would not be bound by the lowest common denominator, the amount of changes that would have to be made and the backwards compatibility issues would be too vast to warrant this.

### New precompile over modifying the `ecrecover` precompile

Initially, modifying the `ecrecover` precompile was going to be selected over creating a new precompile, however, this was ruled out after it took too much complexity to implement or may break backwards compatibility.

### Hard fork over [EIP‑4337](./eip-4337.md) Account Abstraction

This EIP allows for [EIP‑4337](./eip-4337.md) `Bundler`s to settle `UserOperation`s onchain using a different algorithm which in the future may be the only option if post-quantum issues cause the secp256k1 curve to be phased out.

## Backwards Compatibility

Non-EIP-7932 transactions will still be included within blocks and will be treated as the default secp256k1 curve. Therefore there would be no backwards compatibility issues will processing other transactions.

## Test Cases

<!-- TODO add test cases -->

## Security Considerations

Allowing more ways to potentially create transactions for a single account may decrease overall security for that specific account, however this is partially mitigated by the increase in processing power required to trial all algorithms. Even still, adding additional algorithms may need further discussing to ensure that the security of the network would not be compromised.

Having `signature_info` be of no concrete type creates a chance that an algorithms logic could be specified or implemented incorrectly, which could lead to, in the best case, invalid blocks, or at worst, the ability for anyone to sign a fraudulent transaction for any account. This security consideration is delegated to the algorithms specification, therefore care must be taken when writing these algorithm specifications to avoid critical security flaws.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
