---
eip: 7979
title: Call and Return Opcodes for the EVM
description: A minimal spec for new EVM opcodes to support calls and returns.
author: Greg Colvin (@gcolvin), Martin Holst Swende (@holiman), Brooklyn Zelenka (@expede), John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip-7951-call-and-return-opcodes-for-the-evm/24615
status: Draft
type: Standards Track
category: Core
created: 2025-12-17
requires: 3541
---

## Abstract

This is the smallest possible change to the EVM to support calls and returns.

This proposal introduces two new control-flow opcodes

* `JUMPSUB` — jump to the `PC` on top of the stack
* `RETURNSUB` — return to the `PC` after the most recent `JUMPSUB`

and restricts `valid` control flow to static uses of `JUMP`, `JUMPI`, and `JUMPSUB`.

`Valid` code will not execute invalid instructions, jump to invalid locations, underflow stack, or use unbounded stack in the absence of recursion.

## Motivation

### The original control-flow facility

IN 1945 Alan Turing proposed jumps, conditional jumps, calls, and returns as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:
> A simple form of logical control would be a list of operations to be carried out in the order in which these are given.  Such a scheme can be made to cover quite a number of jobs... and has been used in more than one machine... However, it lacks flexibility.  We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date...  We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note of where we left off the major operation and then apply the first instruction of the subsidiary.  When the subsidiary is over we look up the note and continue with the major operation.
> 
> — _The other Turing machine._  _B. E. Carpenter , R. W. Doran.  The Computer Journal, Volume 20, Issue 3, January 1977_
>
The ACE was designed as a 32-bit RISC machine with integer and floating point operations, 32 registers, a 1024-slot return stack, and 64K of RAM on a 1-MHz bus.

The details vary, but similar facilities have proven their worth across a long line of important machines over the last 75 years, including most all of the machines we have programmed or implemented — physical machines including the Burroughs 5000, CDC 7600, IBM 360, DEC PDP-11 and VAX, Motorola 68000, Sun SPARC, and Intel x86s, as well as virtual machines for Scheme, Forth, Pascal, Java, Wasm, and others.

### The EVM control-flow facility

Unlike these machines, the Ethereum Virtual Machine _does not_ provide operations for calls and returns. Instead, they must be synthesized using the dynamic `JUMP` instruction, which takes its argument on the stack. Further, the EVM provides _only_ dynamic jumps.  The EVM's dynamic jumps cause two big problems. First, the need to synthesize static jumps and calls with dynamic jumps wastes some space and gas, as we will show below.  Much worse, jumps that can dynamically branch to any destination in the program can be a denial-of-service vulnerability — they can cause quadratic "path explosions" when traversing the program's flow of control.

#### Tracing control flow

Many static analyses of computer programs require tracing the complete flow of control in a minimal number of steps.  To illustrate — Among other approaches this can be done via symbolic execution — starting at the first instruction, tracing instruction by instruction until a jump is encountered, and recursively tracing the possible destinations of each jump; when a previously encountered jump destination is reached the recursion returns.  When all jumps are static the number of steps is linear in the number of instructions — only one or two paths must be explored at each jump.  With dynamic jumps every possible path must be explored at each jump, leading to possible "path explosions" — the number of steps can be quadratic in the number of instructions.

#### Denial of service

For Ethereum, quadratic tracing times are an online denial-of-service vulnerability that prevents us from validating the safe use of EVM code, or transforming it for faster execution, whether by optimized interpreter, JIT, or AOT compiler.

Even offline, many static analyses can become impractically slow in depth and at scale.  This includes verifying code against formal specifications and other proofs of program invariants — and with so much at stake on the blockchain correct contracts are crucial.  These analyses must first get past the difficulties of tracing control flow, as explained here, _Analyzing Smart Contracts: From EVM to a sound Control-Flow Graph._ (DOI link available at 10.48550/arXiv.2301.12695).  From there problem gets so difficult that one proposal goes so far as using neural networks to recover structure from code, _Neural-FEBI: Accurate Function Identification in Ethereum Virtual Machine Bytecode._ (DOI link available at 10.48550/arXiv.2004.14437)  This proposal renders these problems trivial.

#### Taming the EVM

To prevent control-flow tracing from "going quadratic" we must prevent the dynamic use of jumps.  Onchain, most all uses JUMP and JUMPI instructions in EVM code are preceded by a `PUSH` — that is, they are static.  This proposal ensures that in `valid` code `JUMP` and `JUMPI` are used always statically.   The only places that jumps _must_ be used dynamically are to support calls to Turing's _subsidiary operations._  For that purpose we propose `JUMPSUB` and `RETURNSUB` opcodes as replacements. 

## Specification

### `JUMPSUB (0x..)`

Transfers control to a subsidiary operation.

1. Pop the `destination` from the `data stack`.
2. Push the current `PC + 1` to the `return stack`.
3. Set `PC` to `destination`.

The gas cost is _mid_ (`8`).

### `RETURNSUB (0x..)`

Returns control to the caller of a subsidiary operation.

1. Pop the `return stack` to `PC`.

The gas cost is _verylow_ (`3`).

### `MAGIC (0xEF....)`

After this EIP has been activated code beginning with the `MAGIC` bytes MUST be the leading bytes of a `valid` program.  Execution begins immediately after the MAGIC bytes.

_Notes:_

* _Values popped off the `return stack` do not need to be validated, since they are alterable only by `JUMPSUB` and `RETURNSUB`._
* _The description above lays out the semantics of these instructions in terms of a `return stack`.  But the actual state of the `return stack` is not observable by EVM code or consensus-critical to the protocol.  (For example, a node implementer may code `JUMPSUB` to unobservably push `PC` on the `return stack` rather than `PC + 1`, which is allowed so long as `RETURNSUB` observably returns control to the `PC + 1` location.)_
* _Opcode and magic values are still to be determined._

### Validity

Execution is defined in the Yellow Paper as a sequence of changes in the EVM state. The conditions on valid code are preserved by state changes. At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state and cannot continue. The Yellow Paper defines six such states.

* Insufficient gas
* More than 1024 stack items
* State modification during a static call
* Insufficient stack items
* Invalid jump destination
* Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state. In practice, we must test at runtime for the first three conditions. We don’t know how much gas there will be, we don’t know how deep a recursion may go, analysis of stack depth even for non-recursive programs is nontrivial, and we don’t know whether a call will be static. All of the remaining conditions MUST be validated statically, in time and space linear in the size of the code.  To allow for _O(n)_ algorithms our validation does not consider the code’s data and computations, only its control flow and stack use. This means we will reject programs with invalid code paths, even if those paths are not reachable. 

#### Constraints on `valid` EVM code

Code beginning with `MAGIC` MUST be `valid`.  Constraints on `valid` code MUST be validated at `CREATE` time, in time and space linear in the size of the code.  The constraints on `valid` code are as follows.

* Every executable instruction MUST be `valid`:
  * All opcode values must be `valid`:
    * they must have been defined in the Yellow Paper or an EIP and not since deprecated by an EIP;
    * the `INVALID` opcode is defined.
  * The `JUMP`, `JUMPI` and `JUMPSUB` instructions MUST NOT address immediate data, and MUST address `JUMPDEST`.
  * The `JUMP`, `JUMPI` and `JUMPSUB` instructions MUST be preceded by a `PUSH` instruction.
* The stacks MUST be `valid`:
  * The number of items on the `data stack` MUST always be positive and less than or equal to 1024.
  * The number of items on the `return stack` MUST always be positive and less than or equal to 1024.
  * The `stack height` is the absolute difference between the current `stack pointer` and the `stack pointer` on entry to the current subsidiary.
    * The `stack height` MUST be _the same_ for every `PC`.
 
The guarantee of constant stack height prevents stack underflow, and also breaks cycles in tracing algorithms, bounds stack use in non-recursive programs, and allows virtual stack code to be directly serialized into virtual register code for faster interpretation and compilation to optimized machine code.  It does prevent optimizations like having error handlers that are jumped to at different stack heights.  These will either need to clear stack (a useful instruction in its own right) before jumping or use `JUMPSUB` instead of `JUMP` (at the same cost).

_Note: The JVM and Wasm enforce similar constraints for similar reasons._

#### Validation

The above is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data.  Subsidiary operations are not contiguous sequences of bytecode — they are subgraphs of the bytecode's full control-flow graph.  The EVM is a simple state machine, where every instruction advances the state one more notch — we only promise that `valid` code will not, as it were, jam up the gears of the machine.

Rather than enforce semantic constraints via syntax, (that is a job for higher-level languages) this proposal enforces them via a symbolic execution that traces the code's flow of control, checking constraints as it goes.  A reference implementation is given below.  Other algorithms are of course allowable, so long as they enforce the same constraints and use time and space linear in the size of code.

With no syntactic constraints and minimal semantic constraints we maximize opportunities for optimizations, include tail call elimination, multiple-entry calls, common exit handlers, arranging blocks for optimal caching and variables for efficient register allocation, and more.  Since we want to support online compilation of EVM code to native code it is crucial that the EVM code be as well optimized as possible offline.

## Rationale

Why choose this mechanism?  There really is little other choice — return addresses have to get stacked somewhere.  In general, the stack machines we know of have separate computation and return stacks, whereas the register machines have a general purpose stack, registers to support computation, and special-purpose registers to support subroutines in coordination with the stack.  The EVM is a stack machine, not a register machine.

### A well-understood mechanism

As an industry and a team we have substantial experience with the return-stack mechanism proposed here.  It has been effectively used in many machines over the last eight decades, and has been implemented, tested, and even ready to ship in most of our clients at least once over the last ten years.

### An efficient mechanism

We illustrate here how these simple instructions can be used to modestly reduce the complexity and the gas costs of calls and returns compared to using `JUMP`.

#### **Leaf Call**

Consider these examples of a fairly minimal leaf call, including the overhead of calling it.

##### Using `JUMPSUB`:

```

CALL_SQUARE:
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jumpsub         ; 8 gas
    returnsub       ; 3 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 29

```

##### Using `JUMP`:

```

CALL_SQUARE:
    push RTN_CALL   ; 3 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    swap1           ; 3 gas
    jump            ; 8 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 48

```

Using `JUMPSUB` versus `JUMP` saves _48 - 29 = 19 gas_ — a _40%_ improvement.

#### **Tail Call**

Of course in cases like this one we can optimize away the tail call, so that the return from `SQUARE` actually returns from `CALL_SQUARE`.

##### Tail call optimization, using only `RETURNSUB`:

```

CALL_SQUARE:
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 15

```

##### Tail call optimization, using `JUMP`:

```

CALL_SQUARE:
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 23

```

Using `JUMPSUB` versus `JUMP` saves _23 - 15 = 8 gas_ — a 35% improvement.

#### Caveats

We can see that these instructions provide a simpler, more gas-efficient mechanism than using `JUMP`.  The benefits are of course greater for programs that have been factored into smaller calls — the overhead for calling and returning with `JUMPSUB` and `RETURNSUB` is 14 gas versus the overhead using `JUMP` of 30 gas.  The benefits may also be smaller after optimization.  So gains will generally be modest, but code using `JUMPSUB` always takes less space and gas than equivalent code without it.

Maximum performance (as opposed to gas) gains will come from generating machine code from EVM code, which these changes enable — recovering the control-flow graph is an early stage of most compilers.

### Costs

The _mid_ cost of `JUMPSUB` is justified by it taking very little more work than the _mid_ cost of `JUMP` — just pushing an integer to the `return stack` 

The _verylow_ cost of `RETURNSUB` is justified by needing only to pop the `return stack` into the `PC`.  Benchmarking will be needed to tell if the costs are well-balanced.

## Backwards Compatibility

These changes are backwards compatible — the semantics of EVM code _is not_ affected by whether the contract begins with `MAGIC` and execution of code _does not_ require maintaining two interpreters.

These changes do not affect the semantics of existing EVM code, with the caveat that bytes that might have been interpreted as valid jump destinations may now be interpreted as immediate data, and bytecode that might have halted may now execute and vice versa.  Such code was always broken.

These changes do not foreclose EOF, RISC-V, or other changes.  New `MAGIC` numbers would flag EVM changes, and future EIPs could choose whether to retain or deprecate `JUMPSUB` and `RETURNSUB`.  Neither do these changes preclude running the EVM in zero knowledge; they would more likely help.

## Test Cases

### Simple routine

This should jump into a subroutine, back out and stop.

Bytecode: `0x60045e005b5d` (`PUSH1 0x04, JUMPSUB, STOP, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |    JUMPSUB  |   10 |       [4] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |      [ 2] |
|    3  |       STOP  |    0 |        [] |        [] |

_Output: 0x_
_Consumed gas: `18`_

### Two levels of subroutines

This should execute fine, going into two depths of subroutines

Bytecode: `0x6800000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x00000000000000000c, JUMPSUB, STOP, JUMPDEST, PUSH1 0x11, JUMPSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    JUMPSUB  |   10 |      [12] |        [] |
|   13  |      PUSH1  |    3 |        [] |      [10] |
|   15  |    JUMPSUB  |   10 |      [17] |      [10] |
|   18  |  RETURNSUB  |    5 |        [] |   [10,15] |
|   16  |  RETURNSUB  |    5 |        [] |      [10] |
|   11  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `36`_

### Failure 1: invalid jump

This should fail, since the given location is outside of the code-range. The code is the same as previous example, 
except that the pushed location is `0x01000000000000000c` instead of `0x0c`.

Bytecode: `0x6801000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x01000000000000000c, JUMPSUB, STOP, JUMPDEST, PUSH1 0x11, JUMPSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    JUMPSUB  |   10 |[18446744073709551628] |        [] |

```
Error: at pc=10, op=JUMPSUB: invalid jump destination
```

### Failure 2: shallow `return stack`

This should fail at first opcode, due to shallow `return_stack`

Bytecode: `0x5d5858` (`RETURNSUB, PC, PC`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

### Subroutine at end of code

In this example. the JUMPSUB is on the last byte of code. When the subroutine returns, it should hit the 'virtual stop' _after_ the bytecode, and not exit with error

Bytecode: `0x6005565b5d5b60035e` (`PUSH1 0x05, JUMP, BEGINSUB, RETURNSUB, JUMPDEST, PUSH1 0x03, JUMPSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |       JUMP  |    8 |       [5] |        [] |
|    5  |   JUMPDEST  |    1 |        [] |        [] |
|    6  |      PUSH1  |    3 |        [] |        [] |
|    8  |    JUMPSUB  |   10 |       [3] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |      [ 8] |
|    9  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `30`_

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

## Reference Implementation

The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.

This algorithm performs a symbolic execution of the program that recursively traces the _code_, emulating its control flow and stack use and checking for violations of the rules above.

It runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_ — thus the algorithm takes time proportional to the size of the _code_. It maintains a stack of continuations for conditional jumps, the size of which is at most proportional to the size of the _code_.

### Validation Function

** Note: this function is known to be incomplete and incorrect. **

We also assume some helper functions.

* `is_valid(opcode)` returns true iff opcode is valid.
* `is_terminator(opcode)` returns true iff opcode is terminator.
* `is_valid_jumpdest(pc)` returns true iff `pc` is a valid jump destination.
* `previous_data(pc)` returns the immediate data for the instruction before `pc` (typically a PUSH).
* `immediate_size(opcode)` returns the size of the immediate data for an opcode.
* `removed_items(opcode)` returns the number of items removed from the `data_stack` by the `opcode`.
* `added_items(opcode)` returns the number of items added to the `data_stack` by the `opcode`.

```
# returns true iff code is valid
def validate_code(code: bytes, pc: int, sp: int, bp: int) -> boolean:
    continuations = []
    do
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return false
            if is_terminator(opcode):
                return true

            # check stack height and return if we have been here before
            stack_height = sp - bp
            if stack_height > 1024
                return false
            if pos in stack_heights:
                if stack_height != stack_heights[pos]:
                    return false
                return true
            else:
                stack_heights[pos] = stack_height

            if opcode == JUMP:

                # reset pc to destination of jump
                jumpdest = previous_data(pc)
                pc += jumpdest
                if !is`valid`jumpdest(pc)
                    return false

            elif opcode == JUMPI:

                jumpdest = pc + previous_data(pc)
                if !is`valid`jumpdest(pc)
                    return false

                # continue true side of conditional later
                continuations.push((jumpdest, sp, bp))

                # continue false side of conditional now

            elif opcode == JUMPSUB:

                # will enter call at destination
                bp = sp

                # push return address and reset pc to destination
                jumpdest = pc + previous_data(pc)
                if !is`valid`jumpdest(pc)
                    return false
                push(return_stack, pc + 3)
                pc = jumpdest
                continue

            elif opcode == RETURNSUB:

                # will return to call at destination
                bp = sp

                # pop return address and check for preceding call
                pc = pop(return_stack)
                if code[pc - 3] != JUMPSUB:
                   return false

            # apply instructions to stack
            sp -= removed_items(opcode)
            if sp < 0
                return false
            sp += added_items(opcode)

            # Skip opcode and immediate data
            pc += 1 + immediate_size(opcode)

        while (pc, sp, bp) = continuations.pop()

    return true
```

## Security Considerations

These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be linear in time and space to not be a denial of service vulnerability.  The algorithm here makes one linear-time pass of the bytecode, and uses a stack of continuations that cannot exceed the number of `JUMP` and `JUMPI` instructions in the code.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
