---
eip: 7979
title: Call and Return Opcodes for the EVM
description: A minimal spec for new EVM opcodes to support calls and returns.
author: Greg Colvin (@gcolvin), Martin Holst Swende (@holiman), Brooklyn Zelenka (@expede), John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip-7951-call-and-return-opcodes-for-the-evm/24615
status: Draft
type: Standards Track
category: Core
created: 2025-12-17
requires: 3541
---

## Abstract

This is the smallest possible change to the EVM to support calls and returns.

This proposal introduces two new control-flow opcodes

* `JUMPSUB` — jump to the `PC` on top of the stack
* `RETURNSUB` — return to the `PC` after the most recent `JUMPSUB`

and restricts `valid` control flow to static uses of JUMP, JUMPI, and JUMPSUB.

`Valid` code will not execute invalid instructions, jump to invalid locations, underflow stack, or use unbounded stack in the absence of recursion.

## Motivation

### The original control-flow facility

IN 1945 Alan Turing proposed jumps, conditional jumps, calls, and returns as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:
> A simple form of logical control would be a list of operations to be carried out in the order in which these are given.  Such a scheme can be made to cover quite a number of jobs... and has been used in more than one machine... However, it lacks flexibility.  We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date...  We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note of where we left off the major operation and then apply the first instruction of the subsidiary.  When the subsidiary is over we look up the note and continue with the major operation.
> 
> — _The other Turing machine._  _B. E. Carpenter , R. W. Doran.  The Computer Journal, Volume 20, Issue 3, January 1977_
>
The ACE was designed as a 32-bit RISC machine with integer and floating point operations, 32 registers, a 1024-slot return stack, and 64K of RAM on a 1-MHz bus.

The details vary, but similar facilities have proven their worth across a long line of important machines over the last 75 years, including most all of the machines we have programmed or implemented — physical machines including the Burroughs 5000, CDC 7600, IBM 360, DEC PDP-11 and VAX, Motorola 68000, Sun SPARC, and Intel x86s, as well as virtual machines for Scheme, Forth, Pascal, Java, Wasm, and others.

### The EVM control-flow facility

Unlike these machines, the Ethereum Virtual Machine _does not_ provide operations for calls and returns. Instead, they must be synthesized using the dynamic `JUMP` instruction, which takes its argument on the stack. Further, the EVM provides _only_ dynamic jumps.  The EVM's dynamic jumps cause two major problems. First, the need to synthesize static jumps and calls with dynamic jumps wastes some space and gas, as we will show below.

Worse, jumps that can dynamically branch to any destination in the program can be a denial-of-service vulnerability — they can cause quadratic "path explosions" when traversing the program's flow of control.

#### Tracing control flow

A fundamental operation on computer programs is to trace the complete flow of control of code sequences in a minimal number of steps.  This can be done by starting at the first instruction, tracing instruction by instruction until a jump is encountered, and recursively tracing the possible destinations of each jump; when a previously encountered jump destination is reached the recursion returns.  When all jumps are static the number of steps is linear in the number of instructions — only one or two paths must be explored at each jump.  With dynamic jumps every possible path must be explored at each jump, leading to possible "path explosions" — the number of steps can be quadratic in the number of instructions.

#### Denial of service

For Ethereum, quadratic tracing times are an online denial-of-service vulnerability that prevents us — in time and space linear in the size of the code — from validating the safe use of EVM code, or transforming it for faster execution, whether by an interpreter, JIT, or AOT compiler.

Even offline, many static analyses can become impractically slow in depth and at scale.  This include verifying code against formal specifications and other proofs of program invariants —  with so much at stake on the blockchain correct contracts are crucial.  These analyses must first get past the difficulties of tracing control flow (_Analyzing Smart Contracts: From EVM to a sound Control-Flow Graph._) and one proposal goes so far as using neural networks to recover structure from code, _Neural-FEBI: Accurate Function Identification in Ethereum Virtual Machine Bytecode._  This proposal renders these problems trivial.

#### Taming the EVM

To prevent tracing from "going quadratic" we must prevent the dynamic use of jumps.  Most JUMP and JUMPI instructions in EVM code are preceded by a `PUSH` — that is, they are static.  So this proposal can validate that `JUMP` and `JUMPI` are used statically.   The only places that jumps _must_ be used dynamically are to support calls to Turing's _subsidiary operations._  For that purpose we propose `JUMPSUB` and `RETURNSUB` opcodes as replacements. 

## Specification

### `JUMPSUB (0x5f)`

Transfers control to a subsidiary operation.

1. Pop the `destination` from the `data stack`.
2. Push the current `PC + 1` to the `return stack`.
3. Set `PC` to `destination`.

The gas cost is _low_.

### `RETURNSUB (0x5e)`

Returns control to the caller of a subsidiary operation.

1. Pop the `return stack` to `PC`.

The gas cost is _verylow_.

### `MAGIC (0xEF0000)`

After the EIP as been activated code beginning with `MAGIC` MUST be the leading bytes of a `valid` program.  Execution begins after these leading bytes.

_Notes:_

* _Values popped off the `return stack` do not need to be validated, since they are alterable only by `JUMPSUB` and `RETURNSUB`._
* _The description above lays out the semantics of these instructions in terms of a `return stack`.  But the actual state of the `return stack` is not observable by EVM code or consensus-critical to the protocol.  (For example, a node implementer may code `JUMPSUB` to unobservably push `PC` on the `return stack` rather than `PC + 1`, which is allowed so long as `RETURNSUB` observably returns control to the `PC + 3` location.)_

### Validity

Code beginning with `MAGIC` MUST be `valid` Conditions on `valid` code MUST be validated statically, at `CREATE` time, in time and space linear in the size of the code.

#### Constraints on `valid` EVM code

* Every executable instruction MUST be `valid`:
  * All opcode values must be `valid`.
  * The `JUMP`, `JUMPI` and `JUMPSUB` instructions MUST NOT address immediate or implementation data, and MUST address `JUMPDEST`.
  * The `JUMP`, `JUMPI` and `JUMPSUB` instructions MUST be preceded by a `PUSH` instruction.
  * The `CODECOPY` and `EXTCODECOPY` instructions MUST zero-fill implementation data.
* The stacks MUST be `valid`:
  * The number of items on the `data stack` MUST always be positive and less than or equal to 1024.
  * The number of items on the `return stack` MUST always be positive and less than or equal to 1024.
  * The `stack height` is the absolute difference between the current `stack pointer` and the `stack pointer` on entry to the current subsidiary.
    * The `stack height` MUST be _the same_ for every `PC`.
 
The guarantee of constant stack height also breaks cycles in tracing algorithms, bounds stack use in non-recursive programs, and allows virtual stack code to be directly serialized into virtual register code for faster interpretation and compilation to optimized machine code.

_Note: The JVM and Wasm enforce similar constraints for similar reasons._

#### Validation

The above is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data.  Subsidiary operations are not contiguous sequences of bytecode — they are subgraphs of the bytecode's full control-flow graph.  The EVM is a simple state machine — we only promise that `valid` code will not, as it were, jam up the gears of the machine.

Rather than enforce semantic constraints via syntax, (that is a job for higher-level languages) this proposal enforces them via a validation algorithm that traces the code's flow of control, checking conditions as it goes.  One implementation is given below.  With no syntactic constraints and minimal semantic constraints we maximize opportunities for optimizations, include tail call elimination, multiple-entry calls, common exit handlers, arranging blocks for optimal caching and variables for efficient register allocation, and more.  Since we want to support online compilation of EVM code to native code it is crucial that the EVM code be as well optimized as possible offline.

## Rationale

Why choose this mechanism?

### A well-understood mechanism

As an industry and a team we have substantial experience with the return-stack mechanism proposed here.  It has been effectively used in many machines over the last eight decades, and has been implemented, tested, and ready to ship in most of our clients at least once over the last ten years.

### An efficient mechanism

This mechanism does not hurt the size or gas use of code that uses it.  Rahter, we illustrate here how these simple instructions can be used to modesly reduce the complexity and the gas costs of calls and returrns compared to using `JUMP`.

#### **Leaf Call**

Consider these examples of a fairly minimal leaf call, including the overhead of calling it.

##### Using `JUMPSUB`:

```

CALL_SQUARE:
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jumpsub         ; 8 gas
    returnsub       ; 3 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

```

   _Consumed gas: `29`_

##### Using `JUMP`:

```

CALL_SQUARE:
    push RTN_CALL   ; 3 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    swap1           ; 3 gas
    jump            ; 8 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

```

   _Consumed gas: `48`_

Using `JUMPSUB` versus `JUMP` saves _48 - 29 = 19 gas_ — a _40%_ improvement.

#### **Tail Call**

Of course in cases like this one we can optimize the tail call, so that the return from `SQUARE` actually returns from `CALL_SQUARE`.

##### Tail call optimization, using `JUMPSUB` and `RETURNSUB`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

```

  _Consumed gas: `16`_

##### Tail call optimization, using `JUMP`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

```

  _Consumed gas: `24`_

Using `JUMPSUB` versus `JUMP` saves _24 - 16 = 8 gas_ — a 33% improvement.

#### Caveats

We can see that these instructions provide a simpler, more gas-efficient mechanism than using `JUMP`.  The benefits are of course greater for programs that have been factored into smaller calls — the overhead for calling and returning from a call with `JUMPSUB` and `RETURNSUB` is 11 gas versus the overhead for `JUMP` of 28 gas.  The benefits may also be smaller after optimization.  So gains will generally be modest, but code using `JUMPSUB` always takes less space and gas than equivalent code without it.

Maximum performance (as opposed to gas) gains will come from generating machine code from EVM code, which these changes allow — recovering the control-flow graph is an early stage of many compilers.

### Costs

The _mid_ cost of `JUMPSUB` is justified by it taking very little more work than the _mid_ cost of `JUMP` — pushing to the `return stack` rather than writing over the PC.

The _verylow_ cost of `RETURNSUB` is justified by needing only to pop the `return stack` into the `PC`.  Benchmarking will be needed to tell if the ceosts are well-balanced.

## Backwards Compatibility

These changes are backwards compatible -- the semantics of EVM code _is not_ affected by whether the contract begins with `MAGIC` and excution of `MAGIC` code _does not_ require a second interpreter.

These changes do not affect the semantics of existing EVM code, with the caveat that bytes that might have been interpreted as valid jump destinations may now be interpreted as immediate data, and bytecode that might have halted may now execute and vice versa.  Such code was always broken.

These changes do not foreclose EOF, RISC-V, or other changes.  New `MAGIC` numbers would flag EVM changes, and future EVMs could choose whether to retain or deprecate `JUMPSUB` and `RETURNSUB`.  Neither do these changes preclude running the EVM in zero knowledge; they would more likely help.

## Test Cases

### Simple routine

This should jump into a subroutine, back out and stop.

Bytecode: `0x60045e005b5d` (`PUSH1 0x04, JUMPSUB, STOP, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |    JUMPSUB  |   10 |       [4] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |      [ 2] |
|    3  |       STOP  |    0 |        [] |        [] |

_Output: 0x_
_Consumed gas: `18`_

### Two levels of subroutines

This should execute fine, going into two depths of subroutines

Bytecode: `0x6800000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x00000000000000000c, JUMPSUB, STOP, JUMPDEST, PUSH1 0x11, JUMPSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    JUMPSUB  |   10 |      [12] |        [] |
|   13  |      PUSH1  |    3 |        [] |      [10] |
|   15  |    JUMPSUB  |   10 |      [17] |      [10] |
|   18  |  RETURNSUB  |    5 |        [] |   [10,15] |
|   16  |  RETURNSUB  |    5 |        [] |      [10] |
|   11  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `36`_

### Failure 1: invalid jump

This should fail, since the given location is outside of the code-range. The code is the same as previous example, 
except that the pushed location is `0x01000000000000000c` instead of `0x0c`.

Bytecode: `0x6801000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x01000000000000000c, JUMPSUB, STOP, JUMPDEST, PUSH1 0x11, JUMPSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    JUMPSUB  |   10 |[18446744073709551628] |        [] |

```
Error: at pc=10, op=JUMPSUB: invalid jump destination
```

### Failure 2: shallow `return stack`

This should fail at first opcode, due to shallow `return_stack`

Bytecode: `0x5d5858` (`RETURNSUB, PC, PC`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

### Subroutine at end of code

In this example. the JUMPSUB is on the last byte of code. When the subroutine returns, it should hit the 'virtual stop' _after_ the bytecode, and not exit with error

Bytecode: `0x6005565b5d5b60035e` (`PUSH1 0x05, JUMP, BEGINSUB, RETURNSUB, JUMPDEST, PUSH1 0x03, JUMPSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |       JUMP  |    8 |       [5] |        [] |
|    5  |   JUMPDEST  |    1 |        [] |        [] |
|    6  |      PUSH1  |    3 |        [] |        [] |
|    8  |    JUMPSUB  |   10 |       [3] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |      [ 8] |
|    9  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `30`_

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

## Reference Implementation

The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.

This algorithm performs a symbolic execution of the program that recursively traces the _code_, emulating its control flow and stack use and checking for violations of the rules above.

It runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_ — thus the algorithm takes time proportional to the size of the _code_. It maintains a stack of continuations for conditional jumps, the size of which is at most proportional to the size of the _code_.

### Validation Function

** Note: this function is known to be incomplete and incorrect. **

For simplicity's sake we assume that all jumpdest analysis and prior validation has been done, including EIP-3540, EIP-3670, and EIP-4200, so EOF headers and sections are well-formed, and there are no invalid instructions or jumps.  In practice, all passes of validation can be folded into a single loop with no recursion.

We also assume some helper functions.

* `is_valid(opcode)` returns true iff opcode is valid.
* `is_terminator(opcode)` returns true iff opcode is terminator.
* `is`valid`jumpdest(pc)` returns true iff `pc` is a valid jump destination.
* `previous_data(pc)` returns the immediate data for the instruction before `pc` (typically a PUSH).
* `immediate_size(opcode)` returns the size of the immediate data for an opcode.
* `removed_items(opcode)` returns the number of items removed from the `data_stack` by the `opcode`.
* `added_items(opcode)` returns the number of items added to the `data_stack` by the `opcode`.

```
# returns true iff code is valid
def validate_code(code: bytes, pc: int, sp: int, bp: int) -> boolean:
    continuations = []
    do
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return false
            if is_terminator(opcode):
                return true

            # check stack height and return if we have been here before
            stack_height = sp - bp
            if stack_height > 1024
                return false
            if pos in stack_heights:
                if stack_height != stack_heights[pos]:
                    return false
                return true
            else:
                stack_heights[pos] = stack_height

            if opcode == JUMP:

                # reset pc to destination of jump
                jumpdest = previous_data(pc)
                pc += jumpdest
                if !is`valid`jumpdest(pc)
                    return false

            elif opcode == JUMPI:

                jumpdest = pc + previous_data(pc)
                if !is`valid`jumpdest(pc)
                    return false

                # continue true side of conditional later
                continuations.push((jumpdest, sp, bp))

                # continue false side of conditional now

            elif opcode == JUMPSUB:

                # will enter call at destination
                bp = sp

                # push return address and reset pc to destination
                jumpdest = pc + previous_data(pc)
                if !is`valid`jumpdest(pc)
                    return false
                push(return_stack, pc + 3)
                pc = jumpdest
                continue

            elif opcode == RETURNSUB:

                # will return to call at destination
                bp = sp

                # pop return address and check for preceding call
                pc = pop(return_stack)
                if code[pc - 3] != JUMPSUB:
                   return false

            # apply instructions to stack
            sp -= removed_items(opcode)
            if sp < 0
                return false
            sp += added_items(opcode)

            # Skip opcode and immediate data
            pc += 1 + immediate_size(opcode)

        while (pc, sp, bp) = continuations.pop()

    return true
```

## Security Considerations

These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be linear in time and space to not be a denial of service vulnerability.  The algorithm here makes one linear-time pass of the bytecode, and uses a stack of continuations that cannot exceed the number of `JUMP` and `JUMPI` instructions in the code.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
