---
eip: 7979
title: Call and Return Opcodes for the EVM
description: A minimal specification for new EVM opcodes to support calls and returns.
author: Greg Colvin (@gcolvin), Martin Holst Swende (@holiman), Brooklyn Zelenka (@expede), John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip-7951-call-and-return-opcodes-for-the-evm/24615
status: Draft
type: Standards Track
category: Core
created: 2025-12-17
requires: 3541
---

## Abstract

This is the smallest possible change to the EVM to support calls and returns.

This proposal introduces three new control-flow opcodes to the EVM:

* `CALLSUB` — transfer conrol to the `PC` on top of the stack
* `ENTERSUB` — marks a `CALLSUB` destination 
* `RETURNSUB` — return to the `PC` after the most recent `CALLSUB`

In addition, code prefixed with `MAGIC` bytes is validated to ensure that `valid` code will not execute invalid instructions, jump to invalid locations, underflow stack, or, in the absence of recursion, overflow stack -- the complete control flow of `valid` code can be traversed in time and space linear in the size of the code. 

These changes are backwards-compatible: the new instructions behave as specified whether or not they appear in `MAGIC` code.

## Motivation

### The original control-flow facility

In 1945 Alan Turing proposed jumps, conditional jumps, calls, and returns as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:
> A simple form of logical control would be a list of operations to be carried out in the order in which these are given.  Such a scheme can be made to cover quite a number of jobs... and has been used in more than one machine... However, it lacks flexibility.  We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date...  We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note of where we left off the major operation and then apply the first instruction of the subsidiary.  When the subsidiary is over we look up the note and continue with the major operation.
> 
> — _The other Turing machine._  _B. E. Carpenter , R. W. Doran.  The Computer Journal, Volume 20, Issue 3, January 1977_
>
The ACE was designed as a 32-bit RISC machine with integer and floating point operations, 32 registers, a 1024-slot return stack, and 64K of RAM on a 1-MHz bus.

The details vary, but similar facilities have proven their worth across a long line of important machines over the last 80 years, including most all of the machines we have programmed or implemented — physical machines including the Burroughs 5000, CDC 7600, IBM 360, DEC PDP-11 and VAX, Motorola 68000, Sun SPARC, and Intel x86s, as well as virtual machines for Scheme, Forth, Pascal, Java, Wasm, and others.

### The EVM control-flow facility

Unlike these machines, the Ethereum Virtual Machine _does not_ provide operations for calls and returns. Instead, they must be synthesized using the dynamic `JUMP` instruction, which takes its argument on the stack. Further, the EVM provides _only_ dynamic jumps.  The EVM's dynamic jumps cause big problems. First, the need to synthesize static jumps and calls with dynamic jumps wastes some space and gas, as we will show below.  Much worse, jumps that can dynamically branch to any destination in the program can be a denial-of-service vulnerability — they can cause quadratic "path explosions" when traversing the program's flow of control.

#### Static analysis

Static analysis is any analysis that does not require running the code.  This includes validating program invariants and proving that programs meet their formal specifications.  And it includes transforming code into other representations, such as control flow graphs, code for faster interpreters, and code for physical machines.

##### The flow of control

Representing the flow of control is a fundamentmental first step for many other static analyses, including the validations, proofs, and transformations that matter to us.  The standard representation is the control flow graph (CFG) -- a directed cyclic graph where vertices represent instructions and direct edges represent transfers of control.  And a fundamental problem in graph theory is to transform a directed cyclic graph into a directed acyclic graph in one pass, visiting each vertex only once.

##### Dynamic jumps

Among other approaches this can be done via a symbolic execution: starting at the first instruction, stepping instruction by instruction until a jump is encountered, and recursively following the possible destinations of each jump; when a previously encountered jump destination is reached the recursion returns, thus breaking the cycle.  When all jumps are static the number of steps is linear in the number of instructions — only one or two paths must be explored at each jump.  With dynamic jumps every possible destination must be explored at each jump — the number of steps can be quadratic in the number of instructions.

##### Onchain denial of service

For Ethereum, quadratic analysis times are an online denial-of-service vulnerability that prevents us from ensuring the `valid` use of EVM code.  This futher prevents transforming EVM code for further analysis and faster execution, whether by faster interpreters, JITs, or AOT compilers.

##### Offchain impediments

Even offline, dynamic jumps cause many static analyses to become impractically slow, difficult or even impossible — and with so much at stake on the blockchain correct contracts are imperative.

These analyses must first get past the difficulties that dynamic jumps cause of recovering the control flow of EVM programs from their bytecode, as explained here, _Analyzing Smart Contracts: From EVM to a sound Control-Flow Graph._ (available at DOI arXiv:2004.14437v3,) here, _The Good, the Bad and the Ugly: Pitfalls and Best Practices in Automated Sound Static Analysis of Ethereum Smart Contracts_ (available at DOI arXiv:2101.05735) here, _EtherSolve: Computing an Accurate Control-Flow Graph from Ethereum Bytecode_ (available at DOI arXiv:2103.09113) and in many other publications.  There is an entire academic literature presenting complex approaches to partial solutions to problems that this proposal renders trivial.

#### Taming the EVM

To prevent control-flow traversal from "going quadratic" we must prevent the dynamic use of jumps.  On-chain, most all uses of JUMP and JUMPI instructions in EVM code are preceded by a `PUSH` — that is, they are static.  This proposal ensures that in `valid` code `JUMP` and `JUMPI` are always used statically.  Currently, the only places that jumps must be used dynamically are to support calls and returns.  For that purpose we propose `CALLSUB` and `RETURNSUB` opcodes as replacements. 

## Specification

### `CALLSUB (0x..)`

Transfers control to a subsidiary operation.

1. Pop the `destination` from the `data stack`.
2. Push the current `PC + 1` to the `return stack`.
3. Set `PC` to `destination`.

The gas cost is _mid_ (`8`).

### `ENTERSUB (0x..)

The `destination` of every `CALLSUB` MUST be an `ENTERSUB`.

### `RETURNSUB (0x..)`

Returns control to the caller of a subsidiary operation.

1. Pop the `return stack` to `PC`.

The gas cost is _verylow_ (`3`).

### `MAGIC (0xEF....)`

After this EIP has been activated code beginning with the `MAGIC` bytes MUST a `valid` program.  Execution begins immediately after the MAGIC bytes.

_Notes:_

* _Values popped off the `return stack` do not need to be validated, since they are alterable only by `CALLSUB` and `RETURNSUB`._
* _The description above lays out the semantics of these instructions in terms of a `return stack`.  But the actual state of the `return stack` is not observable by EVM code or consensus-critical to the protocol.  (For example, a node implementer may code `CALLSUB` to unobservably push `PC` on the `return stack` rather than `PC + 1`, which is allowed so long as `RETURNSUB` observably returns control to the `PC + 1` location.)_
* _Opcode and magic values are still to be determined._

### Validity

Execution is defined in the Yellow Paper as a sequence of changes in the EVM state. The conditions on valid code are preserved by state changes. At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state and cannot continue. The Yellow Paper defines six such states.

* Insufficient gas
* More than 1024 stack items
* State modification during a static call
* Insufficient stack items
* Invalid jump destination
* Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state. In practice, we must usual test at runtime for the first four conditions. We don’t know how much gas there will be, and we don’t know how deep a recursion may go, and we don’t know whether a call will be static.  However, we can validate that non-recursive programs do not overflow stack.  All of the remaining conditions MUST be validated statically, in time and space linear in the size of the code.  To allow for _O(n)_ algorithms our validation does not consider the code’s data and computations, only its control flow and stack use. This means we will reject programs with invalid code paths, even if those paths are not reachable. 

#### Constraints on `valid` EVM code

Code beginning with `MAGIC` MUST be `valid`.  Constraints on `valid` code MUST be validated at `CREATE` time, in time and space linear in the size of the code.  The constraints on `valid` code are as follows.

* Every executable instruction MUST be `valid`:
  * All opcode values must be `valid`:
    * they MUST have been defined in the Yellow Paper or an EIP and not since deprecated by an EIP;
    * the `INVALID` opcode is `valid`.
  * `JUMP` and `JUMPI` instructions MUST NOT address immediate data, and MUST address a `JUMPDEST`.
  * `CALLSUB` instructions MUST NOT address immediate data, and MUST address an `ENTERSUB`.
  * The `JUMP`, `JUMPI` and `CALLSUB` instructions MUST be preceded by a `PUSH` instruction.
* The stacks MUST be `valid`:
  * The number of items on the `data stack` MUST always be positive and less than or equal to 1024.
  * The number of items on the `return stack` MUST always be positive and less than or equal to 1024.
  * The `stack depth` is the absolute difference between the current `stack pointer` and the `stack pointer` at the most recent `ENTERSUB`.
    * The `stack depth` MUST be _the same_ for every `PC`.
 
The guarantee of constant stack depth prevents stack underflow, and also breaks cycles in tracing algorithms, ensures finite stack use for non-recursive programs, and allows virtual stack code to be directly serialized into virtual register code for faster interpretation and compilation to optimized machine code.  It does prevent optimizations like having error handlers that are jumped to at different stack depths.  These will either need to clear stack before jumping or use `CALLSUB` instead of `JUMP` (at the same cost).

_Note: The JVM and Wasm enforce similar constraints for similar reasons._

#### Validation

The above is a purely semantic specification, placing no constraints on the syntax of bytecode beyond being an array of opcodes and immediate data.  Subsidiary operations are not contiguous sequences of bytecode — they are subgraphs of the bytecode's full control-flow graph.  The EVM is a simple state machine, where every instruction advances the state one more notch — it has no syntatic structure.  We only promise that `valid` code will not, as it were, jam up the gears of the machine.

Rather than enforce semantic constraints via syntax, (that is a job for higher-level languages) this proposal enforces them via a validation algorithm.  A reference implementation is given below.  Other algorithms are of course allowable, so long as they enforce the same constraints and use time and space linear in the size of code.

With no syntactic constraints and minimal semantic constraints we maximize opportunities for optimizations, include tail call elimination, multiple-entry calls, common exit handlers, arranging blocks for optimal caching and variables for efficient register allocation, and others.  Since we want to support online compilation of EVM code to native code it is crucial that the EVM code be as well optimized as possible offline.

## Rationale

### Why choose this mechanism?

#### An appropriate mechanism

Return addresses have to get stacked somewhere.  In general, most stack machines we know of have separate computation and return stacks, whereas most register machines have a general purpose stack, registers to support computation, and special-purpose registers to support subroutines in coordination with the stack.  The EVM is a stack machine, not a register machine.

#### A well-understood mechanism

As an industry and a team we have substantial experience with the return-stack mechanism proposed here.  It has been effectively used in many machines over the last eight decades, and has been implemented, tested, and even ready to ship in most of our clients at least once over the last nine years.

#### A simple and efficient mechanism

The difference these instructions make can be seen in this do-nothing example.  The separate opcodes make it easier for both people and tools to understand the code, and there are modest savings in size and gas costs as well.

```

CALL_ZIP:                         |       CALL_ZIP:                 
    jumpdest       ; 1 gas        |           entersub       ; 1 gas
    push RTN_CALL  ; 3 gas        |           <push args>           
    <push args>                   |           push ZIP       ; 3 gas
    push SUB       ; 3 gas        |           callsub        ; 8 gas
    jump           ; 8 gas        |           returnsub      ; 3 gas
RTN_CALL:                         |                                 
    swap1          ; 3 gas        |                                 
    jump           ; 8 gas        |                                 
                                  |                                 
ZIP:                              |       ZIP:                      
    jumpdest       ; 1 gas        |           entersub       ; 1 gas
    <use args>                    |           <use args>            
    swap1          ; 3 gas        |           returnsub      ; 3 gas
    jump           ; 8 gas        |                                 
                                  |                                 
Consumed gas: 40 + <...>          |       Consumed gas: 18 + <...>   
```

So at the limit the savings is over 38% less size and over 50% less gas.  In the Appendix we break down some more realistic examples.

### Why no immediate arguments?

This would of course break the promise of "the smallest possible change."  [EIP-4200: EOF - Static relative jumps](https://eips.ethereum.org/EIPS/eip-4200) and [EIP-4750: EOF - Functions](https://eips.ethereum.org/EIPS/eip-4750) remain available.  If backwards compatibility is to be maintained this proposal will be still be needed.

### Why no object format?

Again, this would break the promise of "the smallest possible change."  Validation already provides for most of the semantic guarantees that EOF Functions provide,  and [EIP-3540: EOF - EVM Object Format](https://eips.ethereum.org/EIPS/eip-3540) remains available. In the presence of EOF code sections `CALL_SUB` could be restricted to section boundaries.

### Costs

The _mid_ cost of `CALLSUB` is justified by it taking very little more work than the _mid_ cost of `JUMP` — just pushing an integer to the `return stack` 

The _verylow_ cost of `RETURNSUB` is justified by needing only to pop the `return stack` into the `PC`.  Benchmarking will be needed to tell if the costs are well-balanced.

## Backwards Compatibility

These changes are backwards compatible — the semantics of EVM code _is not_ affected by whether the contract begins with `MAGIC` and execution of code _does not_ require maintaining two interpreters.

These changes do not affect the semantics of existing EVM code, with the caveat that bytes that might have been interpreted as valid jump destinations may now be interpreted as immediate data, and bytecode that might have halted may now execute and vice versa.  Such code was always broken.

These changes do not foreclose EOF, RISC-V, or other changes.  New `MAGIC` numbers would flag EVM changes, and future EIPs could choose whether to retain or deprecate `CALLSUB` and `RETURNSUB`.  Neither do these changes preclude running the EVM in zero knowledge; they would more likely help.

## Test Cases

** Note: these tests do not yet incorporate `ENTERSUB`. **

### Simple routine

This should jump into a subroutine, back out and stop.

Bytecode: `0x60045e005b5d` (`PUSH1 0x04, CALLSUB, STOP, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |    CALLSUB  |   10 |       [4] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |      [ 2] |
|    3  |       STOP  |    0 |        [] |        [] |

_Output: 0x_
_Consumed gas: `18`_

### Two levels of subroutines

This should execute fine, going into two depths of subroutines.

Bytecode: `0x6800000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x00000000000000000c, CALLSUB, STOP, JUMPDEST, PUSH1 0x11, CALLSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    CALLSUB  |   10 |      [12] |        [] |
|   13  |      PUSH1  |    3 |        [] |      [10] |
|   15  |    CALLSUB  |   10 |      [17] |      [10] |
|   18  |  RETURNSUB  |    5 |        [] |   [10,15] |
|   16  |  RETURNSUB  |    5 |        [] |      [10] |
|   11  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `36`_

### Failure 1: invalid jump

This should fail, since the given location is outside of the code-range. The code is the same as previous example, except that the pushed location is `0x01000000000000000c` instead of `0x0c`.

Bytecode: `0x6801000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x01000000000000000c, CALLSUB, STOP, JUMPDEST, PUSH1 0x11, CALLSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    CALLSUB  |   10 |[18446744073709551628] |        [] |

```
Error: at pc=10, op=CALLSUB: invalid jump destination
```

### Failure 2: shallow `return stack`

This should fail at first opcode, due to shallow `return_stack`

Bytecode: `0x5d5858` (`RETURNSUB, PC, PC`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

### Subroutine at end of code

In this example. the CALLSUB is on the last byte of code. When the subroutine returns, it should hit the 'virtual stop' _after_ the bytecode, and not exit with error

Bytecode: `0x6005565b5d5b60035e` (`PUSH1 0x05, JUMP, BEGINSUB, RETURNSUB, JUMPDEST, PUSH1 0x03, CALLSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |       JUMP  |    8 |       [5] |        [] |
|    5  |   JUMPDEST  |    1 |        [] |        [] |
|    6  |      PUSH1  |    3 |        [] |        [] |
|    8  |    CALLSUB  |   10 |       [3] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |      [ 8] |
|    9  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `30`_

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

## Reference Implementation

The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.

This algorithm performs a symbolic execution of the program that recursively traces the _code_, emulating its control flow and stack use and checking for violations of the rules above.

It runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_ — thus the algorithm takes time proportional to the size of the _code_. It maintains a stack of continuations for conditional jumps, the size of which is at most proportional to the size of the _code_.

### Validation Function

** Note: this function is known to be incomplete and incorrect. **
 
We assume that jumpdest analysis has been done and that we some constant-time helper functions.

* `is_valid(opcode)`        returns true iff opcode is valid.
* `is_terminator(opcode)`   returns true iff opcode is terminator.
* `is_imm_data(pc)`         returns true iff `pc` adresses immediate data.
* `previous_data(pc)`       returns the immediate data for the instruction before `pc`.
* `immediate_size(opcode)`  returns the size of the immediate data for an opcode.
* `removed_items(opcode)`   returns the number of items removed from the `data_stack` by the `opcode`.
* `added_items(opcode)`     returns the number of items added to the `data_stack` by the `opcode`.

```
    # returns true iff code is valid
    int []stack_depths
    int []max_depths
    def validate_code(code: bytes, pc: int, sp: int, bp: int, max: int) -> int, boolean:
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return 0, false

            # check stack depth and return if we have been here before
            stack_depth = sp - bp
            max_depth = max + stack_depth
            if max_depth > 1024
                return max_depth, false
            if stack_depths[pc] {
                if stack_depth != stack_depths[pc]:
                    return 0, false
                if opcode == ENTERSUB:
                    return max_depths[pc], true
                else
                    return max_depth, true
                else:
                    stack_depths[pc] = stack_depth

            if is_terminator(opcode):
                return max_depth, true

            elif opcode == CALLSUB:

                # push return address and set pc to destination
                jumpdest = previous_data(pc)
                if is_imm_data(jumpdest)
                    return 0, false
                if code[jumpdest] != ENTERSUB
                    return 0, false
                push(return_stack, pc)

                # validate and track maximum depth
                max_depth, valid = validate_code(jumpdest, 0, sp - bp, max)
                if !valid:
                   return max_depth, false
                max_depths[jumpdest] = max_depth;
               
            elif opcode == RETURNSUB:

                # pop return address and check for preceding call
                pc = pop(return_stack)
                if code[pc] != CALLSUB:
                   return 0, false
                max_depth = max + stack_depth
                return max_depth, true

            if opcode == JUMP:

                # set pc to destination of jump
                pc = previous_data(pc)
                if is_imm_data(pc)
                    return 0, false
                if code[pc] != JUMPDEST
                    return 0, false

            elif opcode == JUMPI:

                jumpdest = previous_data(pc)
                if !is_imm_data(jumpdest)
                    return 0, false
                if code[jumpdest] != JUMPDEST
                    return 0, false

                # recurse to validate true side of conditional
                max_depth, valid = validate_code(jumpdest, sp, bp)
                if !valid:
                    return max_depth, false

            # apply instructions to stack
            sp -= removed_items(opcode)
            if sp < 0
                return so, false
            sp += added_items(opcode)

            # Skip opcode and any immediate data 
            pc += 1 + immediate_size(opcode)

        max_depth = max + stack_depth
        if (max_depth > 1024)
            return max_depth, false
        return max_depth, true
```

## Security Considerations

These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be linear in time and space in the size of the code so as not be a denial of service vulnerability.  The algorithm here makes one linear-time, recursive pass of the bytecode, whose depth cannot exceed the number of `CALLSUB` and `JUMPI` instructions in the code.

## Appendix: Performace analusis of some simple sxamples

We illustrate here how these simple instructions can be used to modestly reduce the complexity, size, and gas costs of some calls and returns compared to using `JUMP`.

### **Leaf Call**

Consider these examples of a fairly minimal leaf function, including the overhead of calling it.

#### Using `CALLSUB`:

```

CALL_SQUARE:
    entersub        ; 1 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    callsub         ; 8 gas
    returnsub       ; 3 gas

SQUARE:
    entersub        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 30

```

#### Using `JUMP`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push RTN_CALL   ; 3 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    swap1           ; 3 gas
    jump            ; 8 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 49

```

Using `CALLSUB` versus `JUMP` saves _49 - 30 = 19 gas_ — a _40%_ improvement.

### **Tail Call**

Of course in cases like this one we can optimize away the tail call, so that the return from `SQUARE` actually returns from `CALL_SQUARE`.

#### Tail call optimization, using only `RETURNSUB`:

```

CALL_SQUARE:
    entersub        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 16

```

#### Tail call optimization, using `JUMP`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 23=4

```

Using `CALLSUB` versus `JUMP` saves _24 - 16 = 8 gas_ — a 35% improvement.

### Caveats

We can see that these instructions provide a simpler, more gas-efficient mechanism than using `JUMP`.  The benefits are of course greater for programs that have been factored into smaller calls — the overhead for calling and returning with `CALLSUB` and `RETURNSUB` is 15 gas versus the overhead using `JUMP` of 31 gas.  The benefits may also be smaller after optimization.  So gains will generally be modest, but code using `CALLSUB` always takes less space and gas than equivalent code without it.

### Actual performance

Maximum performance (as opposed to gas) gains will come from generating more efficient code from EVM code, which these changes enable — recovering the control-flow graph is an early stage of most compilers.  EVM code is stack code, but real machines are register machines.  So compiling EVM code into interpreted register code can already improve performace.  (I have seen 4X improvements in JVM code.)  Compiling to machine code gives even greater gains.  

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
