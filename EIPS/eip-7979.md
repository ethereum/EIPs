---
eip: 7979
title: Call and Return Opcodes for the EVM
description: A minimal specification for new EVM opcodes to support calls and returns.
author: Greg Colvin (@gcolvin), Martin Holst Swende (@holiman), Brooklyn Zelenka (@expede), John Max Skaller <skaller@internode.on.net>
discussions-to: https://ethereum-magicians.org/t/eip-7951-call-and-return-opcodes-for-the-evm/24615
status: Draft
type: Standards Track
category: Core
created: 2025-12-17
requires: 3541
---

## Abstract

This is the smallest possible change to the EVM to support calls and returns.

This proposal introduces three new control-flow opcodes to the EVM:

* `CALLSUB`  transfer conrol to the `PC` on top of the stack
* `ENTERSUB`  marks a `CALLSUB` destination 
* `RETURNSUB`  return to the `PC` after the most recent `CALLSUB`

In addition, code prefixed with `MAGIC` bytes is validated in linear to ensure that `valid` code will not execute invalid instructions, jump to invalid locations, underflow stack, or, in the absence of recursion, overflow stack.  The complete control flow of `valid` code can be traversed in time and space linear in the size of the code, enabling validation, static analysis, and JIT and AOT compilers.

These changes are backwards-compatible: the new instructions behave as specified whether or not they appear in `MAGIC` code.

## Motivation

### The original control-flow facility

In 1945 Alan Turing proposed jumps, conditional jumps, calls, and returns as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:
> A simple form of logical control would be a list of operations to be carried out in the order in which these are given.  Such a scheme can be made to cover quite a number of jobs... and has been used in more than one machine... However, it lacks flexibility.  We wish to be able to arrange that sequences of orders can divide at various points, continuing in different ways according to the outcome of the calculations to date...  We also wish to be able to arrange for the splitting up of operations into subsidiary operations... To start on a subsidiary operation we need only make a note of where we left off the major operation and then apply the first instruction of the subsidiary.  When the subsidiary is over we look up the note and continue with the major operation.
> 
>  _The other Turing machine._  _B. E. Carpenter , R. W. Doran.  The Computer Journal, Volume 20, Issue 3, January 1977_
>
The ACE was designed as a 32-bit RISC machine with integer and floating point operations, 32 registers, a 1024-slot return stack, and 64K of RAM on a 1-MHz bus.

Call and return facilities of various levels of complexity -- from the Burroughs' detailed ALGOL support to the ARM's `bl` --  have proven their worth across a long line of important machines over the last 80 years.  This includes most all of the machines we have programmed or implemented: physical machines including the Burroughs 5000, CDC 7600, IBM 360, DEC PDP-11 and VAX, Motorola 68000, Sun SPARC, Intel x86s, and others, as well as virtual machines for Scheme, Forth, Pascal, Java, Wasm, and others.

### The EVM control-flow facility

Unlike these machines, the Ethereum Virtual Machine _does not_ provide operations for calls and returns. Instead, they must be synthesized using the dynamic `JUMP` instruction, which takes its argument on the stack. Further, the EVM provides _only_ dynamic jumps.  The EVM's dynamic jumps cause problems. First, the need to synthesize static jumps and calls with dynamic jumps wastes some space and gas, as we will show below.  Much the big problem is this: jumps that can dynamically branch to any destination in the program are a denial-of-service vulnerability  that cause quadratic "path explosions" when traversing the program's flow of control.

Traversing the flow of control is a fundamentmental first step for many static analyses, including validating the flow of control, proving that programs maintain given invariants, avoid known bugs and meet their formal specifications, and, for these purposes and others, transforming code into other representations, such as control flow graphs, code for faster interpreters, and code for physical machines.

Among other possibilities, progam control flow can be traversed via the standard "depth-first search" (DFS) algorithm:

* start at the first instruction
* step instruction by instruction until a jump or call is encountered
* recursively follow the possible destinations of each jump
   * when a previously encountered destination is reached the recursion returns, thus breaking cycles.

When all jumps are static the number of steps is linear in the number of instructions: only one or two paths must be explored for each jump.  With dynamic jumps every possible destination must be explored at each jump: the number of steps can be quadratic in the number of instructions.

For Ethereum, quadratic analysis times are an online denial-of-service vulnerability that prevents us from ensuring the `valid` use of EVM code and from transforming EVM code for faster execution.

Even offline, dynamic jumps cause many static analyses to become impractically slow, difficult or even impossible: and with so much at stake on the blockchain correct contracts are imperative.  There is a entire academic literature[^1][^2][^3][^4] publishing complex approaches to partial solutions to problems that this proposal renders trivial.

#### Taming the EVM

To prevent control-flow traversal from "going quadratic" we must prevent the dynamic use of jumps.  Onchain, most all uses of JUMP and JUMPI instructions in EVM code are preceded by a `PUSH`  that is, they are effectively static.  This proposal ensures that in `valid` code `JUMP` and `JUMPI` are always used statically.  Currently, the only places that jumps _must_ be used dynamically are to support calls and returns.  For that purpose we propose `CALLSUB` and `RETURNSUB` opcodes as replacements. 

## Specification

> _The key word “MUST” in this Specification is to be interpreted as described in RFC 2119 and RFC 8174._

### `CALLSUB (0x..)`

Transfers control to a subsidiary operation.

1. Pop the `destination` from the `data stack`.
2. Push the current `PC + 1` to the `return stack`.
3. Set `PC` to `destination`.

The gas cost is _mid_ (`8`).

### `ENTERSUB (0x..)`

The `destination` of every `CALLSUB` MUST be an `ENTERSUB`.

### `RETURNSUB (0x..)`

Returns control to the caller of a subsidiary operation.

1. Pop the `return stack` to `PC`.

The gas cost is _verylow_ (`3`).

### `MAGIC (0xEF....)`

After this EIP has been activated code beginning with the `MAGIC` bytes MUST a `valid` program.  Execution begins immediately after the MAGIC bytes.

_Notes:_

* _Values popped off the `return stack` do not need to be validated, since they are alterable only by `CALLSUB` and `RETURNSUB`._
* _The description above lays out the semantics of these instructions in terms of a `return stack`.  But the actual state of the `return stack` is not observable by EVM code or consensus-critical to the protocol.  (For example, a node implementer may code `CALLSUB` to unobservably push `PC` on the `return stack` rather than `PC + 1`, which is allowed so long as `RETURNSUB` observably returns control to the `PC + 1` location.)_

* _Opcode and magic values are still to be determined._


### Costs

A _mid_ cost for `CALLSUB` is justified by it taking very little more work than the _mid_ cost of `JUMP`  just pushing an integer to the `return stack`

A _jumpdest_ cost for `ENTERSUB` is justified by ut being, like `JUMPDEST`, a mere label.

A _verylow_ cost for `RETURNSUB` is justified by needing only to pop the narrow `return stack` into the `PC`.

Benchmarking will be needed to tell if the costs are well-balanced.

### Validity

Execution is defined in the Yellow Paper as a sequence of changes in the EVM state. The conditions on valid code are preserved by state changes. At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state and cannot continue. The Yellow Paper defines six such states.

* Insufficient gas
* More than 1024 stack items
* State modification during a static call
* Insufficient stack items
* Invalid jump destination
* Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state. In practice, we must usually test at runtime for the first three conditions. We dont know how much gas there will be, we dont know how deep a recursion may go, and we dont know whether a call will be static.  However, we can validate that non-recursive programs do not overflow stack.  All of the remaining conditions MUST be validated statically, in time and space linear in the size of the code.  To allow for efficient algorithms our validation does not consider the codes data and computations, only its control flow and stack use. This means we will reject programs with invalid code paths, even if those paths are not reachable. 

#### Constraints on `valid` EVM code

Code beginning with `MAGIC` MUST be `valid`.  Constraints on `valid` code MUST be validated at `CREATE` time, in time and space linear in the size of the code.  The constraints on `valid` code are as follows.

* Every instruction MUST be `valid`:
  * All opcode values must be `valid`:
    * they MUST have been defined in the Yellow Paper or an EIP and not since deprecated by an EIP;
    * the `INVALID` opcode is `valid`.
  * `JUMP` and `JUMPI` instructions MUST NOT address immediate data, and MUST address a `JUMPDEST`.
  * `CALLSUB` instructions MUST NOT address immediate data, and MUST address an `ENTERSUB`.
  * The `JUMP`, `JUMPI` and `CALLSUB` instructions MUST be preceded by a `PUSH` instruction.
* The stacks MUST be `valid`:
  * The number of items on the `data stack` MUST always be positive and less than or equal to 1024.
  * The number of items on the `return stack` MUST always be positive and less than or equal to 1024.
  * The `stack depth` is the absolute difference between the current `stack pointer` and the `stack pointer` at the most recent `ENTERSUB`.
    * The `stack depth` MUST be _the same_ for every `PC`.
 
The guarantee of constant stack depth prevents stack underflow, and also breaks cycles in tracing algorithms, ensures finite stack use for non-recursive programs, and allows virtual stack code to be directly serialized into virtual register code for faster interpretation and compilation to optimized machine code.  It does prevent optimizations like having error handlers that are jumped to at different stack depths.  These will either need to clear stack before jumping or use `CALLSUB` instead of `JUMP` (at the same cost).

_Note: The JVM and Wasm enforce similar constraints for similar reasons._

#### Validation

The above is a purely semantic specification, placing no constraints on the syntax of bytecode beyond being an array of opcodes and immediate data.  Subsidiary operations are not contiguous sequences of bytecode  they are subgraphs of the bytecode's full control-flow graph.  The EVM is a simple state machine, where every instruction advances the state one more notch  it has no syntatic structure.  We only promise that `valid` code will not, as it were, jam up the gears of the machine.

Rather than enforce semantic constraints via syntax, this proposal enforces them via a validation algorithm.  A reference implementation is given below.  Other algorithms are of course allowable, so long as they enforce the same constraints and use time and space linear in the size of code.

With no syntactic constraints and minimal semantic constraints we maximize opportunities for optimizations, include tail call elimination, multiple-entry calls, common exit handlers, arranging blocks for optimal caching and variables for efficient register allocation, and others.  Since we want to support online compilation of EVM code to native code it is crucial that the EVM code be as well optimized as possible offline.

## Rationale

### Why no immediate arguments?

This would of course break the promise of "the smallest possible change."  [EIP-4200: EOF - Static relative jumps](./eip-4200) and [EIP-4750: EOF - Functions](./eip-4750) remain available.  If backwards compatibility is to be maintained this proposal will be still be needed.

### Why no object format?

Again, this would break the promise of "the smallest possible change."  Validation already provides for most of the semantic guarantees that EOF Functions provide,  and [EIP-3540: EOF - EVM Object Format](./eip-3540) remains available. In the presence of EOF code sections `CALL_SUB` could be restricted to section boundaries.

### Why choose the return-stack mechanism?

#### An appropriate mechanism

Return addresses have to get stacked somewhere.  In general, most stack machines we know of have separate computation and return stacks, whereas most register machines have a general purpose stack, registers to support computation, and special-purpose registers to support subroutines in coordination with the stack.  The EVM is a stack machine, not a register machine.

#### A well-understood mechanism

As an industry and a team we have substantial experience with the return-stack mechanism proposed here.  It has been effectively used in many machines over the last eight decades, and has been implemented, tested, and even ready to ship in many of our clients over the last nine years.

#### A simple and efficient mechanism

The difference these instructions make can be seen in this very simple code for squaring a number.  The separate opcodes make it easier for both people and tools to understand the code, and there are modest savings in size and gas costs as well.  Consider a simple routine that squares a number

```
CALL_SQUARE:                      |       CALL_SQUARE:                 
    jumpdest       ; 1 gas        |           entersub       ; 1 gas
    push RTN_CALL  ; 3 gas        |           push 2         ; 3 gas          
    push 2         ; 3 gas        |           push SUB       ; 3 gas
    push SUB       ; 3 gas        |           callsub        ; 8 gas
    jump           ; 8 gas        |           returnsub      ; 3 gas
RTN_CALL:                         |                                 
    swap1          ; 3 gas        |                                 
    jump           ; 8 gas        |                                 
                                  |                                 
SQUARE:                           |       SQUARE:                      
    jumpdest       ; 1 gas        |           entersub       ; 1 gas
    dup            ; 3 gas        |           dup            : 3 gas
    mul            ; 5 gas        |           mul            ; 5 gas
    swap1          ; 3 gas        |           returnsub      ; 3 gas
    jump           ; 8 gas        |                                 
                                  |                                 
Size in bytes: 13 +  5 = 18       |       Size in bytes:  8 +  5 = 13 
Consumed gas:  40 + 11 = 51       |       Consumed gas:  19 + 11 = 30
```

* The overhead for a call and return is at most 8 bytes and 19 gas using `CALLSUB` and `RETURNSUB`versus 40 gas using `JUMP` so a routine that does nothing saves 38% in size and 53% in gas using `CALLSUB` versus using `JUMP`.
* The computation to square a number takes 3 bytes and 11 gas, so this routine that squares a number save less: 28% in size and 41% in gas using `CALLSUB` versus using `JUMP`.

So we can see that these instructions provide a simpler, more gas-efficient mechanism than using `JUMP`. As subroutines grow in size the efficiency gains become more modest, but code using `CALLSUB` always takes less space and gas than equivalent code without it.

### Real time performance

Real time performance gains (as opposed to gas) will come from a AOT and JIT compilers.  Crucially, the constraint that stack depths be constan means that in `MAGIc` code a very simple, very fast compiler can traverse the control flow of the EVM code in one pass, generating machine code as it goes. (Wasm, the JVM and  .NET share that property.)  The EVM is a stack machine, but real machines are register machines.  So generating virtual register code for an interpreter can aready improve performace. (I have seen 4X speepups on JVM code.)  Generating machine code gives even greater gains. But for most transactions storage dominates execution time, and gas counting and other overhead take their toll.  So these gains would be most visible in contexts where this overhead is absent, such as for L1 precompiles and on some EVM-compatible chains.

## Backwards Compatibility

These changes are backwards compatible.

* The semantics of EVM code _is not_ affected by whether the contract begins with `MAGIC`.
* There are no changes to the semantics of existing EVM code, with the caveat that code that might have halted could execute and vice versa.  Such code was always broken.
* This proposal _does not_ require maintaining two interpreters.

These changes do not foreclose EOF, RISC-V, or other changes.  New `MAGIC` numbers would flag EVM changes, and future EIPs could choose whether to retain or deprecate `CALLSUB` and `RETURNSUB`.  Neither do these changes preclude running the EVM in zero knowledge; they would more likely help.

## Test Cases

** Note: these tests do not yet incorporate `ENTERSUB` and otherwise no longer match the spec. **

### Simple routine

This should jump into a subroutine, back out and stop.

Bytecode: `0x60045e005b5d` (`PUSH1 0x04, CALLSUB, STOP, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |    CALLSUB  |   10 |       [4] |        [] |
|    5  |  RETURNSUB  |    5 |        [] |      [ 2] |
|    3  |       STOP  |    0 |        [] |        [] |

_Output: 0x_
_Consumed gas: `18`_

### Two levels of subroutines

This should execute fine, going into two depths of subroutines.

Bytecode: `0x6800000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x00000000000000000c, CALLSUB, STOP, JUMPDEST, PUSH1 0x11, CALLSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    CALLSUB  |   10 |      [12] |        [] |
|   13  |      PUSH1  |    3 |        [] |      [10] |
|   15  |    CALLSUB  |   10 |      [17] |      [10] |
|   18  |  RETURNSUB  |    5 |        [] |   [10,15] |
|   16  |  RETURNSUB  |    5 |        [] |      [10] |
|   11  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `36`_

### Failure 1: invalid jump

This should fail, since the given location is outside of the code-range. The code is the same as previous example, except that the pushed location is `0x01000000000000000c` instead of `0x0c`.

Bytecode: `0x6801000000000000000c5e005b60115e5d5b5d` (`PUSH9 0x01000000000000000c, CALLSUB, STOP, JUMPDEST, PUSH1 0x11, CALLSUB, RETURNSUB, JUMPDEST, RETURNSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH9  |    3 |        [] |        [] |
|   10  |    CALLSUB  |   10 |[18446744073709551628] |        [] |

```
Error: at pc=10, op=CALLSUB: invalid jump destination
```

### Failure 2: shallow `return stack`

This should fail at first opcode, due to shallow `return_stack`

Bytecode: `0x5d5858` (`RETURNSUB, PC, PC`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |  RETURNSUB  |    5 |        [] |        [] |

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

### Subroutine at end of code

In this example. the CALLSUB is on the last byte of code. When the subroutine returns, it should hit the 'virtual stop' _after_ the bytecode, and not exit with error

Bytecode: `0x6005565b5d5b60035e` (`PUSH1 0x05, JUMP, BEGINSUB, RETURNSUB, JUMPDEST, PUSH1 0x03, CALLSUB`)

|  Pc   |      Op     | Cost |   Stack   |   RStack  |
|-------|-------------|------|-----------|-----------|
|    0  |      PUSH1  |    3 |        [] |        [] |
|    2  |       JUMP  |    8 |       [5] |        [] |
|    5  |   JUMPDEST  |    1 |        [] |        [] |
|    6  |      PUSH1  |    3 |        [] |        [] |
|    8  |    CALLSUB  |   10 |       [3] |        [] |
|    4  |  RETURNSUB  |    5 |        [] |      [ 8] |
|    9  |       STOP  |    0 |        [] |        [] |

_Consumed gas: `30`_

```
Error: at pc=0, op=RETURNSUB: invalid retsub
```

## Reference Implementation

The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.

This algorithm performs a symbolic execution of the program that recursively traces the _code_, emulating its control flow and stack use and checking for violations of the rules above.

It runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where edges represent control flow and the vertices represent _basic blocks_  thus the algorithm takes time proportional to the size of the _code_. It maintains a stack of continuations for conditional jumps, the size of which is at most proportional to the size of the _code_.

### Validation Function

** Note: this function is known to be incomplete and incorrect. **
 
We assume that jumpdest analysis has been done and that we some constant-time helper functions.

* `is_valid(opcode)`        returns true iff opcode is valid.
* `is_terminator(opcode)`   returns true iff opcode is terminator.
* `is_imm_data(pc)`         returns true iff `pc` adresses immediate data.
* `previous_data(pc)`       returns the immediate data for the instruction before `pc`.
* `immediate_size(opcode)`  returns the size of the immediate data for an opcode.
* `removed_items(opcode)`   returns the number of items removed from the `data_stack` by the `opcode`.
* `added_items(opcode)`     returns the number of items added to the `data_stack` by the `opcode`.

```
    # returns true iff code is valid
    int []stack_depths
    int []max_depths
    def validate_code(code: bytes, pc: int, sp: int, bp: int, max: int) -> int, boolean:
        while pc < len(code):
            opcode = code[pc]
            if !is_valid(opcode):
                return 0, false

            # check stack depth and return if we have been here before
            stack_depth = sp - bp
            max_depth = max + stack_depth
            if max_depth > 1024
                return max_depth, false
            if stack_depths[pc] {
                if stack_depth != stack_depths[pc]:
                    return 0, false
                if opcode == ENTERSUB:
                    return max_depths[pc], true
                else
                    return max_depth, true
                else:
                    stack_depths[pc] = stack_depth

            if is_terminator(opcode):
                return max_depth, true

            elif opcode == CALLSUB:

                # push return address and set pc to destination
                jumpdest = previous_data(pc)
                if is_imm_data(jumpdest)
                    return 0, false
                if code[jumpdest] != ENTERSUB
                    return 0, false
                push(return_stack, pc)

                # validate and track maximum depth
                max_depth, valid = validate_code(jumpdest, 0, sp - bp, max)
                if !valid:
                   return max_depth, false
                max_depths[jumpdest] = max_depth;
               
            elif opcode == RETURNSUB:

                # pop return address and check for preceding call
                pc = pop(return_stack)
                if code[pc] != CALLSUB:
                   return 0, false
                max_depth = max + stack_depth
                return max_depth, true

            if opcode == JUMP:

                # set pc to destination of jump
                pc = previous_data(pc)
                if is_imm_data(pc)
                    return 0, false
                if code[pc] != JUMPDEST
                    return 0, false

            elif opcode == JUMPI:

                jumpdest = previous_data(pc)
                if !is_imm_data(jumpdest)
                    return 0, false
                if code[jumpdest] != JUMPDEST
                    return 0, false

                # recurse to validate true side of conditional
                max_depth, valid = validate_code(jumpdest, sp, bp)
                if !valid:
                    return max_depth, false

            # apply instructions to stack
            sp -= removed_items(opcode)
            if sp < 0
                return so, false
            sp += added_items(opcode)

            # Skip opcode and any immediate data 
            pc += 1 + immediate_size(opcode)

        max_depth = max + stack_depth
        if (max_depth > 1024)
            return max_depth, false
        return max_depth, true
```

## Security Considerations

These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be linear in time and space in the size of the code so as not be a denial of service vulnerability.  The algorithm here makes one linear-time, recursive pass of the bytecode, whose depth cannot exceed the number of `CALLSUB` and `JUMPI` instructions in the code.

## Appendix: Performace analysis of some simple examples

We illustrate here how these simple instructions can be used to modestly reduce the complexity, size, and gas costs of some calls and returns compared to using `JUMP`.

### **Leaf Call**

Consider these examples of a fairly minimal leaf function, including the overhead of calling it.

#### Using `CALLSUB`:

```

CALL_SQUARE:
    entersub        ; 1 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    callsub         ; 8 gas
    returnsub       ; 3 gas

SQUARE:
    entersub        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 30

```

#### Using `JUMP`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push RTN_CALL   ; 3 gas
    push 0x02       ; 3 gas
    push SQUARE     ; 3 gas
    jump            ; 8 gas
RTN_CALL:
    swap1           ; 3 gas
    jump            ; 8 gas

SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 49

```

Using `CALLSUB` versus `JUMP` saves _49 - 30 = 19 gas_  a _40%_ improvement.

### **Tail Call**

Of course in cases like this one we can optimize away the tail call, so that the return from `SQUARE` actually returns from `CALL_SQUARE`.

#### Tail call optimization, using only `RETURNSUB`:

```

CALL_SQUARE:
    entersub        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    returnsub       ; 3 gas

Consumed gas: 16

```

#### Tail call optimization, using `JUMP`:

```

CALL_SQUARE:
    jumpdest        ; 1 gas
    push 0x02       ; 3 gas
SQUARE:
    jumpdest        ; 1 gas
    dup1            ; 3 gas
    mul             ; 5 gas
    swap1           ; 3 gas
    jump            ; 8 gas

Consumed gas: 23=4

```

Using `CALLSUB` versus `JUMP` saves _24 - 16 = 8 gas_  a 35% improvement.



## Copyright

Copyright and related rights waived via [CC0](./LICENSE.md).

[^1]:
```csl-json
{
  "type": "article",
  "id": 1,
  "author": [
    {
      "family": "Albert",
      "given": "Elvira"
    }
  ],
  "DOI": "arXiv:2004.14437",
  "title": "Analyzing Smart Contracts: From EVM to a sound Control-Flow Graph.,
  "original-date": {
    "date-parts": [
      [2020, 4, 29]
    ]
  },
  "URL": "https://arxiv.org/abs/2004.14437"
}
```

[^2]:
```csl-json
{
  "type": "article",
  "id": 2,
  "author": [
    {
      "family": "Schneidewind",
      "given": "Clara"
    }
  ],
  "DOI": "arXiv:2101.05735",
  "title": "The Good, the Bad and the Ugly: Pitfalls and Best Practices in Automated Sound Static Analysis of Ethereum Smart Contracts.,
  "original-date": {
    "date-parts": [
      [2021, 1, 14]
    ]
  },
  "URL": "https://arxiv.org/abs/2101.05735"
}
```

[^3]:
```csl-json
{
  "type": "article",
  "id": 3,
  "author": [
    {
      "family": "Contro",
      "given": "Filippo"
    }
  ],
  "DOI": "arXiv:2103.09113",
  "title": "EtherSolve: Computing an Accurate Control-Flow Graph from Ethereum Bytecode.",
  "original-date": {
    "date-parts": [
      [2021, 3, 16]
    ]
  },
  "URL": "https://arxiv.org/abs/2103.09113"
}
```

[^4]:
```csl-json
{
  "type": "article",
  "id": 4,
  "author": [
    {
      "family": "He",
      "given": "Jiahao"
    }
  ],
  "DOI": "arXiv:2301.12695",
  "title": "Neural-FEBI: Accurate Function Identification in Ethereum Virtual Machine Bytecode.",
  "original-date": {
    "date-parts": [
      [2023, 1, 30]
    ]
  },
  "URL": "https://arxiv.org/abs/2301.12695"
}
```
