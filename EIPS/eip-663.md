---
eip: 663
title: SWAPN, DUPN and EXCHANGE instructions
description: Introduce additional instructions for manipulating the stack which allow accessing the stack at higher depths
author: Alex Beregszaszi (@axic), Charles Cooper (@charles-cooper), Francisco Giordano (@frangio)
discussions-to: https://ethereum-magicians.org/t/eip-663-unlimited-swap-and-dup-instructions/3346
status: Review
type: Standards Track
category: Core
created: 2017-07-03
---

## Abstract

Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce three new instructions, `SWAPN`, `DUPN` and `EXCHANGE` which lift this limitation and allow accessing the stack at higher depths.

## Motivation

While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code.

Furthermore, implementing higher level constructs, such as functions, on top of EVM will result in a list of input and output parameters as well as an instruction offset to return to.

The number of these arguments (or stack items) can easily exceed 16 and thus will require extra care from a compiler to lay them out in a way that all of them are still accessible.

Lastly, swapping items besides the 1st and Nth items in the stack is very important for compilers implementing stack scheduling algorithms (the analog of register allocation for stack machines), which try to minimize stack traffic given a set of variables and usage analysis.

Introducing `SWAPN`, `DUPN`, and `EXCHANGE` will provide an option to compilers to simplify accessing deep stack items.

## Specification

We introduce three new instructions:

| Mnemonic   | Opcode |
|------------|--------|
| `DUPN`     | `0xe6` |
| `SWAPN`    | `0xe7` |
| `EXCHANGE` | `0xe8` |

Each instruction carries one or two immediate operands. Operands have a semantic domain, and their encoding in bytecode will differ from a simple binary representation of their value.

The operand domains for these instructions are the integers that satisfy the following:

- `DUPN n`, `SWAPN n`: `17 <= n <= 235`
- `EXCHANGE n m`: `2 <= n <= 14 and n < m <= 30 and n + m <= 32`

Unless stated otherwise, "operand", `n`, and `m` refer to values in the semantic domain. In assembly written using mnemonics, operands must be written and interpreted as values in the semantic domain. For example, the assembly `DUPN 20` represents the instruction `DUPN` with operand `n = 20`.

### Encoding: `DUPN`, `SWAPN`

A `DUPN` or `SWAPN` instruction with an operand `n` is encoded as the corresponding opcode `0xe6` or `0xe7` followed by the byte given by `encode_single(n)`:

```python
def encode_single(n: int) -> int:
    assert 17 <= n <= 235
    if n <= 107:
        return n - 17
    else:
        return n + 20
```

This function maps the integer range `[17, 107]` onto `[0, 90]` and `[108, 235]` onto `[128, 255]`.

> Example: `DUPN 20` is `e603`

### Encoding: `EXCHANGE`

An `EXCHANGE` instruction with operands `n`, `m` is encoded as the opcode `0xe8` followed by the byte given by `encode_pair(n, m)`:

```python
def encode_pair(n: int, m: int) -> int:
    assert 2 <= n <= 14 and n < m <= 30 and n + m <= 32
    if m <= 17:
        q, r = n - 2, m - 2
    else:
        q, r = 30 - m, n - 2
    k = 16 * q + r
    return k if k <= 79 else k + 48
```

This function maps pairs in the domain onto `[0, 79] âˆª [128, 255]`.

> Example: `EXCHANGE 4 20` is `e8d2`

### Decoding: Invalid Instructions

A valid bytecode encoding of any of these instructions spans 2 bytes, where the first byte is the opcode and the second byte is the encoding of the immediate operand. The next instruction begins after the immediate.

For any of these opcodes to mark the start of a 2-byte instruction, its subsequent byte must be in the _range_ of the corresponding encoding function (characterized below). If it isn't, the opcode is decoded as an invalid instruction **spanning a single byte**. Instruction decoding continues at the byte that follows the opcode, the _"false immediate"_; in particular, the subsequent byte may be a `JUMPDEST` opcode and mark a valid jump target.

The presence of an invalid instruction of this kind is not forbidden, and no validation needs to happen at contract creation time.

> Example: `e65b` is 2 instructions `INVALID, JUMPDEST`

### Decoding: `DUPN`, `SWAPN`

A `DUPN` or `SWAPN` opcode followed by a byte `x` such that `0 <= x <= 90` or `128 <= x <= 255` is decoded as the respective instruction with operand `n = decode_single(x)`, where `decode_single` is the inverse of `encode_single` and is given by:

```python
def decode_single(x: int) -> int:
    assert 0 <= x <= 90 or 128 <= x <= 255
    if x <= 90:
        return x + 17
    else:
        return x - 20
```

> Example: `e696` is `DUPN 130`

### Decoding: `EXCHANGE`

An `EXCHANGE` opcode followed by a byte `x` such that `0 <= x <= 79` or `128 <= x <= 255` is decoded as the `EXCHANGE` instruction with operands `n, m = decode_pair(x)`, where `decode_pair` is the inverse of `encode_pair` and is given by:

```python
def decode_pair(x: int) -> tuple[int, int]:
    assert 0 <= x <= 79 or 128 <= x <= 255
    k = x if x <= 79 else x - 48
    q, r = divmod(k, 16)
    if q < r:
        return q + 2, r + 2
    else:
        return r + 2, 30 - q
```

> Example: `e8d0` is `EXCHANGE 2 20`

### Execution

Expressed using 1-based indexing:

- `DUPN n`: The `n`'th stack item is duplicated at the top of the stack.
- `SWAPN n`: The `n + 1`'th stack item is swapped with the top of the stack.
- `EXCHANGE n m`: The `n + 1`'th stack item is swapped with the `m + 1`'th stack item.

The gas cost for the three instructions is set at 3.

Note that the 1st to 16th stack items are unreachable by `DUPN` but reachable by `DUP1` to `DUP16`. Similarly, the 2nd to 17th stack items are unreachable by `SWAPN` but reachable by `SWAP1` to `SWAP16`.

Invalid `DUPN`, `SWAPN`, and `EXCHANGE` instructions halt with the same behavior as `INVALID` (`0xfe`).

## Rationale

### Use of an immediate operand

Allowing dynamic selection of the arguments to swap or dup could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate operand that is not dynamic in nature. 

### Restricted range and specialized immediate encoding

Allowing the encoding of the immediate operand to take the values `0x5b` or `0x60` to `0x7f` would create a backwards incompatibility. These values correspond to the `JUMPDEST` and `PUSH1` to `PUSH32` opcodes. Consider the bytecode sequence `e6 5b` that currently decodes to `INVALID JUMPDEST`. If the `DUPN` opcode accepted any subsequent byte as an immediate, once the instruction is introduced to the EVM the same bytecode sequence would then decode to `DUPN 0x5b`, eliminating a previously present `JUMPDEST` and possibly invalidating jumps necessary for the functioning of the contract. A similar thing can happen with push opcodes, for example, `e6 60 5b` would transform from `INVALID PUSH1 0x5b` to `DUPN 0x60 JUMPDEST` upon introduction of such an instruction, creating a new valid jump target. Furthermore, this may have a cascading effect on arbitrarily many subsequent instructions.

Since the EVM doesn't offer a dedicated section for data, arbitrary data may be embedded in code and serve as immutable data storage accessed via `CODECOPY`. Therefore, we must assume that arbitrary byte sequences may be found in contracts that have been deployed or are "counterfactual" deployments-in-waiting.

The current version of the EIP is designed to uphold the following backwards compatibility guarantee: every possible execution trace on a given bytecode that does not attempt to execute an undefined opcode must continue to produce the same effect after the introduction of an instruction. No new `JUMPDEST`s must be created in a given bytecode by the introduction of an instruction and none may be removed.

While it would be safe to allow the values `0x5c` to `0x5f`, these were also omitted to simplify decoding, and wouldn't significantly increase the reachable stack items.

### Size of immediate operand

For `DUPN` and `SWAPN` a 16-bit size was considered to accommodate the full stack space of 1024 items, however:

1. that would require an additional restriction/check (`n < 1024`)
2. the 256 depth is a large improvement over the current 16 and the overhead of an extra byte would make it less useful

Similarly for `EXCHANGE`, the proposed scheme allows addressing of 30 items.

### Gas cost

The gas cost for these operations is the same as for existing `DUP*` and `SWAP*` instructions, because they are just implemented as pointer swaps.

### `EXCHANGE` vs `SWAPN`

As mentioned before, `EXCHANGE` is important to compilers implementing stack scheduling algorithms. Specifically, in the case that a stack item is scheduled to be consumed deeper in the stack (for instance, the 3rd item in the stack needs to be moved into 2nd position in order to be consumed by the next operation), that currently takes three instructions, `SWAP2 SWAP3 SWAP2`. However, in the EVM implementation, the implementation is just a pointer swap, so it could be implemented in a single instruction at no extra runtime cost to the client.

### `EXCHANGE` valid operands

A previous formulation of `EXCHANGE` allowed swapping stack elements only if they were within some distance. As a result, it would be possible to swap the elements at indices 30 and 29, but not possible to move an element from index 30 to 2 with a single instruction. The current formulation prioritizes the latter, on the assumption that it is more valuable to move elements closer to the top of the stack than it is to rearrange elements deeper in the stack.

In addition, the exact formulation was chosen to make `decode_pair` a simple function using only basic arithmetic, bitwise operations (division by 16), and few branches. A small trade-off in the number of addressable pairs was made to reduce the number of necessary branches; this implies some of the immediate range is not allocated, and it could be used to add a dozen more addressable pairs at the cost of more decoding complexity, potentially in a future network upgrade.

## Backwards Compatibility

This has no effect on contracts that would never attempt to execute the opcodes allocated by this EIP. The jump targets of existing contracts are preserved.

## Test Cases

### Decoding

- `e600` is `[DUPN 17]`
- `e780` is `[SWAPN 108]`
- `e6005b` is `[DUPN 17, JUMPDEST]`
- `e75b` is `[INVALID, JUMPDEST]`
- `e6605b` is `[INVALID, PUSH1 0x5b]`
- `e7610000` is `[INVALID, PUSH2 0x0000]`
- `e65f` is `[INVALID, PUSH0]`

### Execution

- `60016000808080808080808080808080808080e600` results in 18 stack items, the top of the stack valued 1, the bottom of the stack valued 1, the rest valued 0
- `600160008080808080808080808080808080806002e700` results in 18 stack items, the top of the stack valued 1, the bottom of the stack valued 2, the rest valued 0

## Security Considerations

The authors are not aware of any additional risks introduced here. The EVM stack is fixed at 1024 items and most implementations keep that in memory at all times. This change will increase the number of stack items accessible via single instruction.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
