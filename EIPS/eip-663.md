---
eip: 663
title: SWAPN and DUPN instructions
description: Introduce additional instructions for manipulating the stack which allow accessing the stack at higher depths
author: Alex Beregszaszi (@axic), Charles Cooper (@charles-cooper), Danno Ferrin (@shemnon), Francisco Giordano (@frangio)
discussions-to: https://ethereum-magicians.org/t/eip-663-unlimited-swap-and-dup-instructions/3346
status: Review
type: Standards Track
category: Core
created: 2017-07-03
---

## Abstract

Currently, `SWAP*` and `DUP*` instructions are limited to a stack depth of 16. Introduce two new instructions, `SWAPN` and `DUPN` which lift this limitation and allow accessing the stack at higher depths.

## Motivation

While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a "stack to memory elevation" in a compiler. This can result in complex and inefficient code.

Furthermore, implementing higher level constructs, such as functions, on top of EVM will result in a list of input and output parameters as well as an instruction offset to return to.

The number of these arguments (or stack items) can easily exceed 16 and thus will require extra care from a compiler to lay them out in a way that all of them are still accessible.

Introducing `SWAPN` and `DUPN` will provide an option to compilers to simplify accessing deep stack items.

## Specification

We introduce two new instructions:

1. `DUPN` (`0xe6`)
2. `SWAPN` (`0xe7`)

Each instruction takes an immediate operand. Semantically, the operand is an integer `n` with `17 ≤ n ≤ 235`.

The encoding of the operand in bytecode will differ from a simple binary representation of its semantic value. Unless stated otherwise, "operand" and `n` refer to the value in the semantic domain. In assembly written using mnemonics, the operand must also be interpeted as the value in the semantic domain. For example, the mnemonic `DUPN 20` represents the instruction `DUPN` with operand `n = 20`.

### Encoding

A `DUPN` or `SWAPN` instruction with an operand `n` is encoded as the corresponding opcode `0xe6` or `0xe7` followed by the byte `f(n)`, where `f` is given by the following Python code:

```python
def f(n: int) -> int:
    assert 17 <= n <= 235
    y = n - 17
    if y < 0x5B:
        return y
    else:
        return y - 0x5B + 0x80
```

### Decoding

A valid encoding of these instructions spans 2 bytes and consists of the opcode followed by 1 byte `x` such that `x < 0x5b` or `x > 0x7f`.

Specifically, a `DUPN` or `SWAPN` opcode (byte `0xe6` or `0xe7`) followed by a byte `x` in the valid range (i.e., such that `x < 0x5b` or `x > 0x7f`) is decoded as the corresponding instruction `DUPN` or `SWAPN` with operand `n = f_inv(x)`, where `f_inv` is the inverse of `f` and is given by the following Python code:

```python
def f_inv(x: int) -> int:
    assert 0 <= z < 0x5B or 0x80 <= z <= 0xFF
    if z < 0x5B:
        return z + 17
    else:
        return z - 0x80 + 0x5B
```

On the other hand, a `DUPN` or `SWAPN` opcode is decoded as an invalid instruction if it is followed by a byte `x` in the invalid range (i.e., such that `0x5b ≤ x ≤ 0x7f`). Note that this invalid instruction **spans a single byte**. Execution halts upon encountering this instruction exactly as `INVALID` (`0xfe`). No validation happens at contract creation time.

### Execution

`DUPN n`: The `n`'th stack item (1-based indexing) is duplicated at the top of the stack.

`SWAPN n`: The `n + 1`'th stack item (1-based indexing) is swapped with the top of the stack.

The gas cost for the two instructions is set at 3.

Note that the 1st to 16th stack items are unreachable by `DUPN` but reachable by `DUP1` to `DUP16`. Similarly, the 2nd to 17th stack items are unreachable by `SWAPN` but reachable by `SWAP1` to `SWAP16`.

## Rationale

### Use of an immediate operand

Allowing dynamic selection of the arguments to swap or dup could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate operand that is not dynamic in nature. 

### Restricted range and specialized immediate encoding

Allowing the encoding of the immediate operand to take the values `0x5b` or `0x60` to `0x7f` would create a backwards incompatibility. These values correspond to the `JUMPDEST` and `PUSH1` to `PUSH32` opcodes. Consider the bytecode sequence `e6 5b` that currently decodes to `INVALID JUMPDEST`. If the `DUPN` opcode accepted any subsequent byte as an immediate, once the instruction is introduced to the EVM the same bytecode sequence would then decode to `DUPN 0x5b`, eliminating a previously present `JUMPDEST` and possibly invalidating jumps necessary for the functioning of the contract. A similar thing can happen with push opcodes, for example, `e6 60 5b` would transform from `INVALID PUSH1 0x5b` to `DUPN 0x60 JUMPDEST` upon introduction of such an instruction, creating a new valid jump target. Furthermore, this may have a cascading effect on arbitrarily many subsequent instructions.

Since the EVM doesn't offer a dedicated section for data, arbitrary data may be embedded in code and serve as immutable data storage accessed via `CODECOPY`. Therefore, we must assume that arbitrary byte sequences may be found in contracts that have been deployed or are "counterfactual" deployments-in-waiting.

The current version of the EIP is designed to uphold the following backwards compatibility guarantee: every possible execution trace on a given bytecode that does not attempt to execute an undefined opcode must continue to produce the same effect after the introduction of an instruction. No new `JUMPDEST`s must be created in a given bytecode by the introduction of an instruction and none may be removed.

While it would be safe to allow the values `0x5c` to `0x5f`, these were also omitted to simplify decoding, and wouldn't significantly increase the reachable stack items.

### Size of immediate operand

For `DUPN` and `SWAPN` a 16-bit size was considered to accommodate the full stack space of 1024 items, however:

1. that would require an additional restriction/check (`n < 1024`)
2. the 256 depth is a large improvement over the current 16 and the overhead of an extra byte would make it less useful

### Gas cost

The gas cost for these operations is the same as for existing `DUP*` and `SWAP*` instructions, because they are just implemented as pointer swaps.

### `EXCHANGE`

A previous version of this EIP included an `EXCHANGE` instruction to swap two non-top stack items in a single instruction as opposed to three. This instruction has been removed to simplify the EIP specification and focus it on increasing reachable stack height.

## Backwards Compatibility

This has no effect on backwards compatibility because the opcodes were not previously allocated and the feature is only enabled in EOF.

## Test Cases

<!-- TODO -->

## Security Considerations

The authors are not aware of any additional risks introduced here. The EVM stack is fixed at 1024 items and most implementations keep that in memory at all times. This change will increase the number of stack items accessible via single instruction.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
