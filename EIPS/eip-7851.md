---
eip: 7851
title: Deactivate a Delegated EOA's Key
description: Introduce a system contract for EIP-7702 delegated EOAs to irreversibly deactivate their ECDSA key after a time delay.
author: Liyi Guo (@colinlyguo), Nicolas Consigny (@nconsigny)
discussions-to: https://ethereum-magicians.org/t/eip-7851-deactivate-reactivate-a-delegated-eoas-key/22344
status: Draft
type: Standards Track
category: Core
created: 2024-12-27
requires: 7702
---

## Abstract

This EIP introduces a system contract that enables an [EIP-7702](./eip-7702) delegated EOA to schedule an irreversible deactivation of its ECDSA private key for ECDSA-authenticated transaction sending and [EIP-7702](./eip-7702) authorizations. Deactivation uses a 7-day delay (cancellation window). After finalization, the key is permanently deactivated in-protocol. The system contract mapping serves as the single source of truth for key status.

## Motivation

[EIP-7702](./eip-7702) enables EOAs to gain smart contract wallet behavior, but the EOA's ECDSA key retains unrestricted signing authority that can override any delegated contract logic. This EIP provides a one-way migration path toward smart contract control, including post-quantum migration strategies, by allowing a delegated EOA to permanently disable its ECDSA transaction-signing authority after a safety delay.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Parameters

| Constant                          | Value                        |
|-----------------------------------|------------------------------|
| `SYSTEM_CONTRACT_ADDRESS`         | `0xTBD`                      |
| `DEACTIVATION_DELAY`              | `604800` (7 days in seconds) |

### System Contract

The system contract is deployed at `SYSTEM_CONTRACT_ADDRESS` following the same mechanism as [EIP-4788](./eip-4788) and [EIP-2935](./eip-2935): a pre-signed deployment transaction using Nick's method is included at fork activation. Deployment parameters TBD.

#### Status Semantics

Let `ts = finalizationTimestamp[account]`:

| Condition                            | Status          | `status()` Return Value |
|--------------------------------------|-----------------|-------------------------|
| `ts == 0`                            | **ACTIVE**      | `0`                     |
| `ts > 0 AND block.timestamp < ts`    | **PENDING**     | `1`                     |
| `ts > 0 AND block.timestamp >= ts`   | **DEACTIVATED** | `2`                     |

#### deactivate()

- MUST revert if `msg.sender` is not an [EIP-7702](./eip-7702) delegated EOA (code does not start with `0xef0100`).
- MUST revert if `finalizationTimestamp[msg.sender] != 0`.
- MUST set `finalizationTimestamp[msg.sender] = uint64(block.timestamp) + DEACTIVATION_DELAY`.

#### cancel()

- MUST revert if `finalizationTimestamp[msg.sender] == 0`.
- MUST revert if `block.timestamp >= finalizationTimestamp[msg.sender]` (already finalized).
- MUST set `finalizationTimestamp[msg.sender] = 0`.

Note: `cancel()` intentionally omits the delegation check. This ensures an EOA that has revoked its delegation can still cancel a pending deactivation during the delay period, preventing accidental lockout.

### Storage Layout

The `finalizationTimestamp` mapping is at storage slot `0`. The storage key for a given `account` is:

```solidity
keccak256(abi.encode(account, uint256(0)))
```

The value is interpreted as a `uint64` timestamp.

### Transaction Validation (Block Processing)

During block validation, for each transaction with recovered sender `S`:

- Clients MUST read `ts = finalizationTimestamp[S]` from the system contract state.
- If `ts != 0` AND `block.timestamp >= ts`, the transaction MUST be treated as invalid.

### Transaction Pool Rules

- The transaction pool MUST reject new transactions from a sender that is deactivated at the current head.
- The transaction pool SHOULD evict already-pooled transactions once the sender is observed deactivated.
- After a reorg that undoes deactivation, previously dropped transactions MAY be re-accepted if re-gossiped; implementations are NOT REQUIRED to retain them.

### EIP-7702 Authorizations

During [EIP-7702](./eip-7702) authorization validation, if the authority address `A` has `finalizationTimestamp[A] != 0` AND `block.timestamp >= finalizationTimestamp[A]`, the authorization MUST be treated as invalid and skipped.

## Rationale

Following the system contract pattern of [EIP-4788](./eip-4788), [EIP-2935](./eip-2935), and [EIP-7002](./eip-7002), this EIP uses a system contract to consolidate deactivation, cancellation, and status queries into a single on-chain entry point. Alternatives considered:

- **Account-state field**: adding a `timestamp` field in account state requires account RLP encoding and p2p protocol changes.
- **Reusing existing account fields**: deactivation status could be encoded into the nonce or appended to the delegated EOA's 23-byte code. However, the delay mechanism requires storing a finalization timestamp. A nonce is an incrementing counter and a delegation designator is a code prefix. Neither is designed to carry a timestamp, and forcing one in complicates their original validation logic.
- **Precompile**: persisting per-account state through a precompile is difficult because precompiles have no storage access mechanism. Adding one would make protocol design and client implementations more complex, introduce a larger testing surface, and increase the likelihood of unexpected edge cases compared to reusing the established system contract pattern. Alternatively the state could be embedded in the account object, which falls back to the account-state field problem above.

Deactivation is intentionally irreversible. Allowing ECDSA key reactivation would defeat the post-quantum security guarantee. The 7-day delay provides a safety window for users who may have triggered deactivation accidentally or who detect an unauthorized deactivation attempt. During the delay period, the original ECDSA key can still cancel the deactivation.

The tradeoff is that transaction and authorization validation requires an additional `SLOAD` from the system contract, which is comparable to existing nonce and balance checks.

## Backwards Compatibility

No backwards compatibility issues. Deactivation state is maintained entirely within the system contract.

## Reference Implementation

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.24;

contract EIP7851KeyDeactivation {
    mapping(address => uint64) public finalizationTimestamp;

    uint64 public constant DEACTIVATION_DELAY = 604800; // 7 days in seconds

    uint8 internal constant ACTIVE = 0;
    uint8 internal constant PENDING = 1;
    uint8 internal constant DEACTIVATED = 2;

    error NotDelegatedEOA();
    error NotScheduled();
    error AlreadyScheduled();
    error AlreadyDeactivated();
    error AlreadyFinalized();

    event DeactivationScheduled(address indexed account, uint64 finalizationTimestamp);
    event DeactivationCancelled(address indexed account);

    receive() external payable {
        revert();
    }

    function deactivate() external {
        if (!_has7702DelegationPrefix(msg.sender)) revert NotDelegatedEOA();

        uint64 ts = finalizationTimestamp[msg.sender];
        if (ts != 0) {
            if (block.timestamp >= ts) revert AlreadyDeactivated();
            revert AlreadyScheduled();
        }

        uint64 ft = uint64(block.timestamp) + DEACTIVATION_DELAY;
        finalizationTimestamp[msg.sender] = ft;
        emit DeactivationScheduled(msg.sender, ft);
    }

    function cancel() external {
        uint64 ts = finalizationTimestamp[msg.sender];
        if (ts == 0) revert NotScheduled();
        if (block.timestamp >= ts) revert AlreadyFinalized();

        delete finalizationTimestamp[msg.sender];
        emit DeactivationCancelled(msg.sender);
    }

    function status(address account) external view returns (uint8) {
        uint64 ts = finalizationTimestamp[account];
        if (ts == 0) return ACTIVE;
        if (block.timestamp < ts) return PENDING;
        return DEACTIVATED;
    }

    function _has7702DelegationPrefix(address account) internal view returns (bool) {
        bytes memory code = account.code;
        return code.length == 23 && code[0] == 0xef && code[1] == 0x01 && code[2] == 0x00;
    }
}
```

## Security Considerations

### Contracts Using ECDSA Signatures

Deployed contracts using ECDSA signatures (e.g., `permit` of [ERC-2612](./eip-2612)) will not automatically respect deactivation. New or upgradeable contracts SHOULD call the system contract's `status()` to enforce deactivation-aware signature acceptance.

For non-upgradeable contracts, the above method cannot be applied directly. The only clear path available, at the protocol level, is to modify `ecRecover` precompiled contract: if the private key of the recovered address is deactivated, the `ecRecover` precompiled contract could return a precompile contract error (or, if not adding an error return path, return a zero address or a collision-resistant address, such as `0x1`). This is complemented by [EIP-8151](./eip-8151), which mitigates `ecRecover`-related risks by making the precompile deactivation-aware.

### Irreversible Deactivation by Design

Deactivation is intentionally irreversible at the protocol level to provide post-quantum security guarantees. Users should understand that once the 7-day delay period has passed, their ECDSA key cannot be reactivated. The 7-day delay provides a safety window for users to cancel if needed.

### 7-Day Delay Security

During the 7-day delay period, the original ECDSA key can cancel the deactivation. This is intentional as it provides a safety mechanism against unauthorized deactivation attempts. However, if an attacker has access to the ECDSA key during the delay period, they can also cancel the deactivation. Users who suspect key compromise should take immediate action to secure their account through other means.

### Delegation Revocation During Pending Period

If a user revokes delegation while a deactivation is pending, they can still cancel via a direct transaction to `cancel()`. If they fail to cancel before finalization, the ECDSA key becomes permanently deactivated. Users SHOULD cancel pending deactivations before revoking delegation.

### Replay Protection

For deactivation via EOA-signed transactions, nonces and [EIP-155](./eip-155) chain IDs provide replay protection. For deactivation via delegated contracts, the contract SHOULD implement its own replay protection mechanisms, especially when the EOA is delegated to the same implementation on multiple chains.

### Mempool and Reorg Considerations

Implementations SHOULD be aware that evicting transactions immediately upon deactivation may cause issues if the deactivation is reverted in a reorg. The SHOULD (rather than MUST) language for eviction provides flexibility.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
