---
eip: 7892
title: Blob Parameter Only Hardforks
description: Defines a mechanism for scaling Ethereum’s blob capacity via specialized hard forks that modify only blob-related parameters.
author: Mark Mackey (@ethDreamer)
discussions-to: https://ethereum-magicians.org/t/eip-7892-blob-parameter-only-hardforks/23018
status: Draft
type: Informational
created: 2025-02-28
requires: 7840
---

## Abstract

This EIP introduces **Blob Parameter Only (BPO) Hardforks**, a lightweight mechanism for incrementally scaling Ethereum’s blob capacity through targeted hard forks that modify only blob-related parameters: `blob target`, `blob limit`, and `baseFeeUpdateFraction`. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling of blob capacity in response to **real-world demand and network conditions**.

## Motivation

Ethereum's scaling strategy relies on Layer 2 (L2) solutions for transaction execution while using Ethereum as a **data availability (DA) layer**. However, the demand for DA has increased rapidly, and the current approach of only modifying blob parameters in large, infrequent hard forks is **not agile enough** to keep up with L2 growth. 

The key motivations for BPO forks are as follows:

1. **Continuous Scaling**  
   - L2 DA demand is growing rapidly, leading to ongoing saturation of blob capacity.
   - Large, infrequent blob parameter changes create high costs and inefficiencies.
   - BPO forks allow for more frequent, safer capacity increases.

2. **Reduced Operational Overhead**  
   - Performance improvements and further testing will continue to unlock additional capacity.
   - It is desirable to reduce the time between core devs agreeing on a parameter increase and its effective deployment.
   - Full Ethereum hard forks require significant coordination, testing, and upgrade efforts across clients.
   - By isolating blob parameter changes, BPO forks reduce the complexity of upgrades.

3. **Enhanced Stability with New Scaling Technologies**
   - Major scaling upgrades (e.g. [EIP-7594](./eip-7594.md)), introduce uncertainty in optimal blob limits.
   - Rather than forcing core developers to accept a suboptimal tradeoff between stability and capacity, BPO forks allow developers to safely increase parameters after observing mainnet performance and stability.

4. **Predictable Upgrades for Builders**  
   - Builders and L2s require confidence that Ethereum will continuously scale to support their needs.
   - A structured BPO framework provides predictability, allowing rollups to commit to Ethereum over alternative DA solutions.

## Specification

### Definition

BPO hardforks are defined as hardforks that only change blob-related protocol parameters at a designated point in time through configuration, without requiring client-side code changes. Activation of new parameters is instant.

### Blob schedule configuration

The following blob-related parameters are now managed by the blob schedule configuration:

- **Blob Target (`blob_target`)**: The expected number of blobs per block.
- **Blob Limit (`blob_limit`)**: The maximum number of blobs per block.
- **Blob Base Fee Update Fraction (`baseFeeUpdateFraction`)**: Determines how blob gas pricing adjusts per block.

To ensure consistency, when a regular hardfork changes any of these parameters, it MUST do so by adding an entry to the blob schedule configuration.

### Execution layer configuration

To facilitate these changes on the execution layer, the `blobSchedule` object specified in [EIP-7840](./eip-7840.md) is extended to allow for an arbitrary number of block timestamps at which these parameters **MAY** change.

```json
"blobSchedule": {
  "cancun": {
    "target": 3,
    "max": 6,
    "baseFeeUpdateFraction": 3338477
  },
  "prague": {
    "target": 6,
    "max": 9,
    "baseFeeUpdateFraction": 5007716
  },
  "12000000": {
    "target": 24,
    "max": 48,
    "baseFeeUpdateFraction": 5007716
  },
  "12300000": {
    "target": 36,
    "max": 56,
    "baseFeeUpdateFraction": 5007716
  }
}
```

### Consensus layer configuration

A new `BLOB_PARAMETER_SCHEDULE` field is added to consensus layer configuration, containing a sequence of entries representing blob parameter changes after `ELECTRA_FORK_EPOCH`.

Entry rules:

- One entry per fork that changes blob parameters (regular or BPO forks).
- `EPOCH` and `MAX_BLOBS_PER_BLOCK` required for all entries.
- `FORK_VERSION` required only for BPO forks (regular forks specify this in source).

```yaml
BLOB_PARAMETER_SCHEDULE:
  - EPOCH: 400000     ## A future anonymous BPO fork
    FORK_VERSION: 0x09000000
    MAX_BLOBS_PER_BLOCK: 24
  - EPOCH: 420000     ## A future anonymous BPO fork
    FORK_VERSION: 0x0A000000
    MAX_BLOBS_PER_BLOCK: 56
  - EPOCH: 440000     ## GLOAS_FORK_EPOCH; a future named fork introducing blob parameter changes
    FORK_VERSION: 0x0B000000  ## GLOAS_FORK_VERSION; duplicated here for extra safety
    MAX_BLOBS_PER_BLOCK: 72
```

The parameters and schedules above are purely illustrative. Actual values and schedules are beyond the scope of this specification.

**Requirements:**

- Execution and consensus clients **MUST** share consistent BPO fork schedules.
- The slot number in the EL's `blobSchedule` **MUST** align with the start of the epoch specified in the consensus layer configuration.
- The `max` field in the EL's `blobSchedule` **MUST** equal the `MAX_BLOBS_PER_BLOCK` value in the consensus layer configuration.

### Modified `compute_fork_version`

The `compute_fork_version` helper is updated to account for BPO forks:

```python
def compute_fork_version(epoch: Epoch, blob_schedule: Sequence[BlobScheduleEntry]) -> Version:
  # Start with named forks.
  forks = [
      (ELECTRA_FORK_EPOCH, ELECTRA_FORK_VERSION),
      (DENEB_FORK_EPOCH, DENEB_FORK_VERSION),
      (CAPELLA_FORK_EPOCH, CAPELLA_FORK_VERSION),
      (BELLATRIX_FORK_EPOCH, BELLATRIX_FORK_VERSION),
      (ALTAIR_FORK_EPOCH, ALTAIR_FORK_VERSION),
  ]
  
  # Add blob schedule entries that define fork versions (therefore representing BPO forks).
  bpo_forks = [
      (entry.epoch, entry.fork_version) 
      for entry in blob_schedule 
      if entry.fork_version is not None
  ]
  forks.extend(bpo_forks)
  
  # Sort forks list by epoch value, newest to oldest.
  forks.sort(key=lambda x: x[0], reverse=True)


  # Find the most recent fork for this epoch.
  for fork_epoch, fork_version in forks:
      if epoch >= fork_epoch:
          return fork_version
  
  return GENESIS_FORK_VERSION
```

### P2P Networking

In the consensus layer:

- The ENR fields `next_fork_version` and `next_fork_epoch` are set from the configuration for the next BPO fork, if applicable.
- It's worth noting that p2p topics will roll over when a BPO fork is activated, as the `fork_digest` parameter is derived from the `fork_version` (modified above to account for BPO forks).

## Rationale

### Why not just use regular hardforks?

Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need for this boilerplate code.

### Why specify parameters in the node configuration instead of code?

Allowing blob parameters to be configured externally enables rapid experimentation, testing, and adjustments without requiring code changes across client implementations. Testing teams can investigate different parameters with minimal involvement from client implementers.

### Why not create an on-chain voting mechanism for blob parameters?

- Ethereum's recent gas limit increase to 36M took nearly a year to coordinate
- Blob capacity is a rapidly evolving, moving target that the wider staking community is not currently well equipped to track
- An on-chain mechanism would require much more extensive code changes, testing cycles, and debates about governance structures.
- BPO forks provide a simpler, more predictable approach while leaving room for future on-chain voting mechanisms when blob capacity stabilizes

## Backwards Compatibility

BPO forks introduce no backwards compatibility concerns.

## Security Considerations

No security risks have been identified.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
