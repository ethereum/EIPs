---
eip: 7928
title: Block-Level Access Lists
description: Enforced block-level access lists for parallalizing transaction validation
author: Toni WahrstÃ¤tter (@nerolation), Dankrad Feist (@dankrad), Francesco D`Amato (@fradamt), Jochem Brouwer (jochem-brouwer), Ignacio Hagopian (@jsign), Yoav Weiss (@yoavw), Alex Forshtat (@forshtat)
discussions-to: https://ethereum-magicians.org/t/eip-xxxx-block-level-access-lists/23337
status: Draft
type: Standards Track
category: Core
created: 2025-03-31
---

## Abstract

This EIP proposes adding Block-Level Access Lists (BALs). By including a complete list of all addresses and storage keys accessed during a block, along with their post-execution values for writes, we enable parallel disk reads and parallel transaction validation. This improves execution efficiency and accelerates block verification, potentially allowing for future gas limit increases.

## Motivation

Currently, transactions without an explicit transaction access list cannot be efficiently parallelized, as the execution engine cannot determine in advance which addresses and storage slots will be accessed. While transaction-level access lists exist via EIP-2930, they are not enforced, making it difficult to optimize execution pipelines.

By enforcing access lists at the block level, we shift the responsibility of declaring storage accesses to the block builder. This enables to efficiently parallelize both disk reads and transaction execution, knowing in advance the exact scope of storage interactions for each transaction.

BALs map transactions to `(address, storage key, value)` tuples and include balance diffs. This approach facilitates parallel disk reads and parallel execution, reducing execution time to `parallel IO + parallel EVM` and improving overall network performance.

## Specification

### Block Structure Modification

We introduce two new components in the block body:

1. A Block Access List (BAL) that maps addresses to storage slots accessed, transaction indices, and post-execution values for writes.
2. Balance Diffs that track every address touched by value transfers along with the balance deltas.

### SSZ Data Structures

```python
# Type aliases
Address = ByteVector(20)
StorageKey = ByteVector(32)
StorageValue = ByteVector(32)
TxIndex = uint16

# Constants; chosen to support a 630m block gas limit
MAX_TXS = 30_000
MAX_SLOTS = 300_000
MAX_ACCOUNTS = 300_000

# SSZ containers
class PerTxAccess(Container):
    tx_index: TxIndex
    value_after: StorageValue # value in state after the last access

class SlotAccess(Container):
    slot: StorageKey
    accesses: List[PerTxAccess, MAX_TXS]

class AccountAccess(Container):
    address: Address
    accesses: List[SlotAccess, MAX_SLOTS]

BlockAccessList = List[AccountAccess, MAX_ACCOUNTS]

# Balance Diff structures
TxIndex = uint64
BalanceDelta = ByteVector(11)  # signed, two's complement encoding

class BalanceChange(Container):
    tx_index: TxIndex
    delta: BalanceDelta  # signed integer, encoded as 11-byte vector

class AccountBalanceDiff(Container):
    address: Address
    changes: List[BalanceChange, MAX_TXS]

BalanceDiffs = List[AccountBalanceDiff, MAX_ACCOUNTS]
```

The `BlockAccessList` is a deduplicated list of accessed addresses. For each address, it contains a list of accessed storage keys. For each storage key, it includes an ordered list of transaction indices that accessed this key, and for write operations, the final storage value after the last access.

The `BalanceDiffs` structure tracks every address with a balance change, including transaction senders, recipients, and the block's coinbase address. Each entry includes the transaction index and the signed balance delta for that transaction.

### State Transition Function

Modify the state transition function to validate the block-level access lists:

```python 
def state_transition(block: Block) -> None:
    computed_access_list = {}
    computed_balance_diffs = {}

    for idx, tx in enumerate(block.transactions):
        # Execute transaction and track state accesses
        accessed_items, balance_changes = execute_transaction(tx)
        
        # Process storage accesses
        for (address, slot), is_write, value in accessed_items:
            if (address, slot) not in computed_access_list:
                computed_access_list[(address, slot)] = []
            
            access_entry = {"tx_index": idx}
            if is_write:
                access_entry["value_after"] = value
            
            computed_access_list[(address, slot)].append(access_entry)
        
        # Process balance changes
        for address, delta in balance_changes:
            if address not in computed_balance_diffs:
                computed_balance_diffs[address] = []
            computed_balance_diffs[address].append({"tx_index": idx, "delta": delta})

    # Validate access list and balance diffs
    if not validate_access_list(block.block_access_list, computed_access_list):
        raise InvalidBlock("Mismatch in block-level access list.")
        
    if not validate_balance_diffs(block.balance_diffs, computed_balance_diffs):
        raise InvalidBlock("Mismatch in balance diffs.")
```

For contract deployments, the `value_after` must contain the runtime bytecode of the newly deployed contract.

## Rationale

### Full BAL Design Choice

We chose the BAL variant for several key reasons:

1. **Balance between size and parallelization benefits**: BALs enable both parallel disk reads and parallel EVM execution while keeping the size manageable.

2. **Storage value inclusion**: Including post-execution values for write operations facilitates state reconstruction during syncing, enabling faster chain catch-up.

3. **Balance diffs**: Including balance diffs ensures correct handling of execution that depends on account balances, crucial for parallel transaction execution.

4. **Efficiency**: An analysis of historical blocks shows that Full BALs would average around 57 KiB with balance diffs adding only 9.6 KiB on average, which is a reasonable overhead given the performance benefits.

### Block Size Considerations

Including access lists increases block size, potentially impacting network propagation times. Based on analysis of historical blocks:

- Average BAL size over 1,000 blocks was around 57 KiB (SSZ-encoded)
- Average balance diff size was approximately 9.6 KiB
- Worst-case BAL size for consuming the entire block gas limit with storage access operations would be approximately 0.93 MiB
- Worst-case balance diff size would be around 0.11 MiB

These sizes are manageable and less than the current worst-case block size achievable through calldata.

### Asynchronous Verification

Block execution can proceed with parallel IO and parallel EVM operations, with verification of the access list occurring alongside execution, ensuring correctness without delaying block processing.

## Backwards Compatibility

This proposal requires changes to the block structure that are not backwards compatible and require a hard fork.

## Security Considerations

### Validation Overhead

Nodes must verify that the access lists and balance diffs in the block accurately reflect the actual accesses and balance changes during execution. Discrepancies MUST result in block invalidation.

### Block Size

Including comprehensive access lists and balance diffs increases block size, potentially impacting network propagation times. However, as noted in the rationale section, the overhead is reasonable given the performance benefits, with typical Full BALs averaging around 67 KiB in total.

### State Sync Benefits

The inclusion of post-execution values for writes in Full BALs provides an additional benefit for state syncing. Nodes can use these values to reconstruct state without processing all transactions, verifying correctness by comparing the derived state root to the head block's state root.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
