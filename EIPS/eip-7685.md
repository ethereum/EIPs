---
eip: 7685
title: General purpose execution layer requests
description: A general purpose bus for sharing EL triggered requests with the CL
author: lightclient (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-7685-general-purpose-execution-layer-requests/19668
status: Review
type: Standards Track
category: Core
created: 2024-04-14
---

## Abstract

This proposal defines a general purpose framework for storing contract-triggered
requests. It extends the execution header with a single field as a commitment to
the request. Requests are later on exposed to the consensus layer.

Requests are not stored on the execution block, only a commitment to the requests
is stored in the execution block.

## Motivation

The proliferation of smart contract controlled validators has caused there to be
a demand for additional EL triggered behaviors. By allowing these systems to
delegate administrative operations to their governing smart contracts, they can
avoid intermediaries needing to step in and ensure certain operations occur.
This creates a safer system for end users. By abstracting each individual request
details from the EL, adding new request types is simpler and does not require an
update on the execution block structure.

## Specification

### Execution Layer

#### Requests

Let `request_data` be the output of a system call to a Request Smart Contract.

`request_data` consists of two parts: `request_type` (single byte) and
`request_list_ssz` (ssz list encoding of many requests) as following:

```
request_data = request_type ++ request_list_ssz
```

Let `requests` be the concatenation of each `request_data` returned from each request
contract:

```
requests = request_data_0 ++ request_data_1 ++ ... ++ request_data_n
```

Note: each `request_data` represents a different list of requests from a particular
smart contract, prepended by their type. They MUST be ordered by their first byte
(the `request_type`).

The ordering of requests within a type is to be defined by each request type and it
is the smart contract responsibility to choose.

#### Block Header

Extend the header with a new 32 byte value `requests_hash`:

```python
def compute_requests_hash(requests):
    return sha256(requests)

block.header.requests_hash = compute_requests_hash(requests)
```

As part of the EL validation for a new block, the EL MUST check that the parameter
`executionRequestsHash` matches their commitment for that block (`block.header.requests_hash`).

### Consensus Layer

Each proposal may choose how to extend the beacon chain types to include new EL request types.

As part of beacon block validation, the CL MUST calculate the hash of the requests
in the beacon block body, and pass the calculated hash to the EL to be incorporated into the `block_hash` validation process.
parameter when calling `engine_newPayloadV4`.

To calculate the hash of the requests, the CL appends the a byte representing the request
type, followed by the SSZ encoded list of requests of that type, repeating this process for
each one of the different request types the CL has on the `execution_requests` field of the
beacon block body and following the same ordering rules used on the EL (ordered by `request_type`).

Let `requests_list` be the list of requests of a type (one of many types from `beacon_block.body.execution_requests`).

`request_data` consists of two parts: `request_type` (single byte) and
`request_list_ssz` (ssz list encoding of `requests_list`) as following:

```
request_list_ssz = ssz(requests_list)
request_data = request_type ++ request_list_ssz
```

Let `requests` be the concatenation of each `request_data` for each request type in
of the requests on `beacon_block.body.execution_requests`:

```
requests = request_data_0 ++ request_data_1 ++ ... ++ request_data_n
```

Note: each `request_data` represents a different list of requests from `beacon_block.body.execution_requests`,
prepended by their type. They MUST be ordered by their first byte (the `request_type`), matching the
order used in the EL.

The execution_hash can be calculated as:

```
requests_hash = sha256(requests)
```

## Rationale

### Ssz byte array rather than an RLP array

Because the EL does not need to handle `request_data` or decode it. We can make let
the smart contract decide what encoding to use. For existing requests they are going
to use SSZ as requests are consumed by the CL.

### Request source and validity

This EIP makes no strict requirement where a request may come from nor when/how
a request MUST be validated. This is to provide future protocol designers
maximum flexibility.

The authors' recommendations on source and validity of requests are:

* The source of requests should be from the execution of transactions. More
  specifically, transactions which make calls to designated system contracts
  that store the request in account. The storage would later be retrieved by a
  post-block system call to the contract. Alternatively, if the system call does
  not need to be inherently concerned with rate limiting, it could rely simply
  on emitting an event which is later parsed post-block by the system and
  converted into a request.
* A request's validity can often not be fully verified at the execution layer.
  This is why they are referred to merely as "requests"; they do not carry the
  authority on their own to unilaterally catalyze an action. We expect the system
  contracts to perform whatever validation is possible by the EL and then pass
  it on to the CL for further validation.

### Ordering

The ordering across types is ascending by type. This is to simplify the process
of verifying that all requests which were committed to in `requests_hash` match.

An alternative could be to order by when the request was generated within the
block. Since it's expected that many requests will be accumulated at the end of
the block via system calls, this would be difficult to enforce. Therefore,
ordering by type is the most straightforward ordering which ensures integrity.

#### Intra-type

Within the same type, order is not defined. This is because the data of the
request is opaque as far as this EIP is concerned. Therefore, it is to be
determined by each request type individually.

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

TODO

## Security Considerations

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
